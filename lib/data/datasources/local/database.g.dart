// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $SupplementsTable extends Supplements
    with TableInfo<$SupplementsTable, SupplementRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SupplementsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _formMeta = const VerificationMeta('form');
  @override
  late final GeneratedColumn<int> form = GeneratedColumn<int>(
    'form',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dosageQuantityMeta = const VerificationMeta(
    'dosageQuantity',
  );
  @override
  late final GeneratedColumn<int> dosageQuantity = GeneratedColumn<int>(
    'dosage_quantity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dosageUnitMeta = const VerificationMeta(
    'dosageUnit',
  );
  @override
  late final GeneratedColumn<int> dosageUnit = GeneratedColumn<int>(
    'dosage_unit',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _customFormMeta = const VerificationMeta(
    'customForm',
  );
  @override
  late final GeneratedColumn<String> customForm = GeneratedColumn<String>(
    'custom_form',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _customDosageUnitMeta = const VerificationMeta(
    'customDosageUnit',
  );
  @override
  late final GeneratedColumn<String> customDosageUnit = GeneratedColumn<String>(
    'custom_dosage_unit',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _brandMeta = const VerificationMeta('brand');
  @override
  late final GeneratedColumn<String> brand = GeneratedColumn<String>(
    'brand',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant(''),
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant(''),
  );
  static const VerificationMeta _ingredientsMeta = const VerificationMeta(
    'ingredients',
  );
  @override
  late final GeneratedColumn<String> ingredients = GeneratedColumn<String>(
    'ingredients',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('[]'),
  );
  static const VerificationMeta _schedulesMeta = const VerificationMeta(
    'schedules',
  );
  @override
  late final GeneratedColumn<String> schedules = GeneratedColumn<String>(
    'schedules',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('[]'),
  );
  static const VerificationMeta _startDateMeta = const VerificationMeta(
    'startDate',
  );
  @override
  late final GeneratedColumn<int> startDate = GeneratedColumn<int>(
    'start_date',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _endDateMeta = const VerificationMeta(
    'endDate',
  );
  @override
  late final GeneratedColumn<int> endDate = GeneratedColumn<int>(
    'end_date',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isArchivedMeta = const VerificationMeta(
    'isArchived',
  );
  @override
  late final GeneratedColumn<bool> isArchived = GeneratedColumn<bool>(
    'is_archived',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_archived" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
    'source',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _pricePaidMeta = const VerificationMeta(
    'pricePaid',
  );
  @override
  late final GeneratedColumn<double> pricePaid = GeneratedColumn<double>(
    'price_paid',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _barcodeMeta = const VerificationMeta(
    'barcode',
  );
  @override
  late final GeneratedColumn<String> barcode = GeneratedColumn<String>(
    'barcode',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _importSourceMeta = const VerificationMeta(
    'importSource',
  );
  @override
  late final GeneratedColumn<String> importSource = GeneratedColumn<String>(
    'import_source',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    name,
    form,
    dosageQuantity,
    dosageUnit,
    customForm,
    customDosageUnit,
    brand,
    notes,
    ingredients,
    schedules,
    startDate,
    endDate,
    isArchived,
    source,
    pricePaid,
    barcode,
    importSource,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'supplements';
  @override
  VerificationContext validateIntegrity(
    Insertable<SupplementRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('form')) {
      context.handle(
        _formMeta,
        form.isAcceptableOrUnknown(data['form']!, _formMeta),
      );
    } else if (isInserting) {
      context.missing(_formMeta);
    }
    if (data.containsKey('dosage_quantity')) {
      context.handle(
        _dosageQuantityMeta,
        dosageQuantity.isAcceptableOrUnknown(
          data['dosage_quantity']!,
          _dosageQuantityMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_dosageQuantityMeta);
    }
    if (data.containsKey('dosage_unit')) {
      context.handle(
        _dosageUnitMeta,
        dosageUnit.isAcceptableOrUnknown(data['dosage_unit']!, _dosageUnitMeta),
      );
    } else if (isInserting) {
      context.missing(_dosageUnitMeta);
    }
    if (data.containsKey('custom_form')) {
      context.handle(
        _customFormMeta,
        customForm.isAcceptableOrUnknown(data['custom_form']!, _customFormMeta),
      );
    }
    if (data.containsKey('custom_dosage_unit')) {
      context.handle(
        _customDosageUnitMeta,
        customDosageUnit.isAcceptableOrUnknown(
          data['custom_dosage_unit']!,
          _customDosageUnitMeta,
        ),
      );
    }
    if (data.containsKey('brand')) {
      context.handle(
        _brandMeta,
        brand.isAcceptableOrUnknown(data['brand']!, _brandMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('ingredients')) {
      context.handle(
        _ingredientsMeta,
        ingredients.isAcceptableOrUnknown(
          data['ingredients']!,
          _ingredientsMeta,
        ),
      );
    }
    if (data.containsKey('schedules')) {
      context.handle(
        _schedulesMeta,
        schedules.isAcceptableOrUnknown(data['schedules']!, _schedulesMeta),
      );
    }
    if (data.containsKey('start_date')) {
      context.handle(
        _startDateMeta,
        startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta),
      );
    }
    if (data.containsKey('end_date')) {
      context.handle(
        _endDateMeta,
        endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta),
      );
    }
    if (data.containsKey('is_archived')) {
      context.handle(
        _isArchivedMeta,
        isArchived.isAcceptableOrUnknown(data['is_archived']!, _isArchivedMeta),
      );
    }
    if (data.containsKey('source')) {
      context.handle(
        _sourceMeta,
        source.isAcceptableOrUnknown(data['source']!, _sourceMeta),
      );
    }
    if (data.containsKey('price_paid')) {
      context.handle(
        _pricePaidMeta,
        pricePaid.isAcceptableOrUnknown(data['price_paid']!, _pricePaidMeta),
      );
    }
    if (data.containsKey('barcode')) {
      context.handle(
        _barcodeMeta,
        barcode.isAcceptableOrUnknown(data['barcode']!, _barcodeMeta),
      );
    }
    if (data.containsKey('import_source')) {
      context.handle(
        _importSourceMeta,
        importSource.isAcceptableOrUnknown(
          data['import_source']!,
          _importSourceMeta,
        ),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SupplementRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SupplementRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      form: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}form'],
      )!,
      dosageQuantity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}dosage_quantity'],
      )!,
      dosageUnit: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}dosage_unit'],
      )!,
      customForm: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}custom_form'],
      ),
      customDosageUnit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}custom_dosage_unit'],
      ),
      brand: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}brand'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      )!,
      ingredients: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ingredients'],
      )!,
      schedules: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}schedules'],
      )!,
      startDate: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}start_date'],
      ),
      endDate: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_date'],
      ),
      isArchived: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_archived'],
      )!,
      source: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source'],
      ),
      pricePaid: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price_paid'],
      ),
      barcode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}barcode'],
      ),
      importSource: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}import_source'],
      ),
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $SupplementsTable createAlias(String alias) {
    return $SupplementsTable(attachedDatabase, alias);
  }
}

class SupplementRow extends DataClass implements Insertable<SupplementRow> {
  final String id;
  final String clientId;
  final String profileId;
  final String name;
  final int form;
  final int dosageQuantity;
  final int dosageUnit;
  final String? customForm;
  final String? customDosageUnit;
  final String brand;
  final String notes;
  final String ingredients;
  final String schedules;
  final int? startDate;
  final int? endDate;
  final bool isArchived;
  final String? source;
  final double? pricePaid;
  final String? barcode;
  final String? importSource;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const SupplementRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.name,
    required this.form,
    required this.dosageQuantity,
    required this.dosageUnit,
    this.customForm,
    this.customDosageUnit,
    required this.brand,
    required this.notes,
    required this.ingredients,
    required this.schedules,
    this.startDate,
    this.endDate,
    required this.isArchived,
    this.source,
    this.pricePaid,
    this.barcode,
    this.importSource,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['name'] = Variable<String>(name);
    map['form'] = Variable<int>(form);
    map['dosage_quantity'] = Variable<int>(dosageQuantity);
    map['dosage_unit'] = Variable<int>(dosageUnit);
    if (!nullToAbsent || customForm != null) {
      map['custom_form'] = Variable<String>(customForm);
    }
    if (!nullToAbsent || customDosageUnit != null) {
      map['custom_dosage_unit'] = Variable<String>(customDosageUnit);
    }
    map['brand'] = Variable<String>(brand);
    map['notes'] = Variable<String>(notes);
    map['ingredients'] = Variable<String>(ingredients);
    map['schedules'] = Variable<String>(schedules);
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<int>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<int>(endDate);
    }
    map['is_archived'] = Variable<bool>(isArchived);
    if (!nullToAbsent || source != null) {
      map['source'] = Variable<String>(source);
    }
    if (!nullToAbsent || pricePaid != null) {
      map['price_paid'] = Variable<double>(pricePaid);
    }
    if (!nullToAbsent || barcode != null) {
      map['barcode'] = Variable<String>(barcode);
    }
    if (!nullToAbsent || importSource != null) {
      map['import_source'] = Variable<String>(importSource);
    }
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  SupplementsCompanion toCompanion(bool nullToAbsent) {
    return SupplementsCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      name: Value(name),
      form: Value(form),
      dosageQuantity: Value(dosageQuantity),
      dosageUnit: Value(dosageUnit),
      customForm: customForm == null && nullToAbsent
          ? const Value.absent()
          : Value(customForm),
      customDosageUnit: customDosageUnit == null && nullToAbsent
          ? const Value.absent()
          : Value(customDosageUnit),
      brand: Value(brand),
      notes: Value(notes),
      ingredients: Value(ingredients),
      schedules: Value(schedules),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      isArchived: Value(isArchived),
      source: source == null && nullToAbsent
          ? const Value.absent()
          : Value(source),
      pricePaid: pricePaid == null && nullToAbsent
          ? const Value.absent()
          : Value(pricePaid),
      barcode: barcode == null && nullToAbsent
          ? const Value.absent()
          : Value(barcode),
      importSource: importSource == null && nullToAbsent
          ? const Value.absent()
          : Value(importSource),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory SupplementRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SupplementRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      name: serializer.fromJson<String>(json['name']),
      form: serializer.fromJson<int>(json['form']),
      dosageQuantity: serializer.fromJson<int>(json['dosageQuantity']),
      dosageUnit: serializer.fromJson<int>(json['dosageUnit']),
      customForm: serializer.fromJson<String?>(json['customForm']),
      customDosageUnit: serializer.fromJson<String?>(json['customDosageUnit']),
      brand: serializer.fromJson<String>(json['brand']),
      notes: serializer.fromJson<String>(json['notes']),
      ingredients: serializer.fromJson<String>(json['ingredients']),
      schedules: serializer.fromJson<String>(json['schedules']),
      startDate: serializer.fromJson<int?>(json['startDate']),
      endDate: serializer.fromJson<int?>(json['endDate']),
      isArchived: serializer.fromJson<bool>(json['isArchived']),
      source: serializer.fromJson<String?>(json['source']),
      pricePaid: serializer.fromJson<double?>(json['pricePaid']),
      barcode: serializer.fromJson<String?>(json['barcode']),
      importSource: serializer.fromJson<String?>(json['importSource']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'name': serializer.toJson<String>(name),
      'form': serializer.toJson<int>(form),
      'dosageQuantity': serializer.toJson<int>(dosageQuantity),
      'dosageUnit': serializer.toJson<int>(dosageUnit),
      'customForm': serializer.toJson<String?>(customForm),
      'customDosageUnit': serializer.toJson<String?>(customDosageUnit),
      'brand': serializer.toJson<String>(brand),
      'notes': serializer.toJson<String>(notes),
      'ingredients': serializer.toJson<String>(ingredients),
      'schedules': serializer.toJson<String>(schedules),
      'startDate': serializer.toJson<int?>(startDate),
      'endDate': serializer.toJson<int?>(endDate),
      'isArchived': serializer.toJson<bool>(isArchived),
      'source': serializer.toJson<String?>(source),
      'pricePaid': serializer.toJson<double?>(pricePaid),
      'barcode': serializer.toJson<String?>(barcode),
      'importSource': serializer.toJson<String?>(importSource),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  SupplementRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    String? name,
    int? form,
    int? dosageQuantity,
    int? dosageUnit,
    Value<String?> customForm = const Value.absent(),
    Value<String?> customDosageUnit = const Value.absent(),
    String? brand,
    String? notes,
    String? ingredients,
    String? schedules,
    Value<int?> startDate = const Value.absent(),
    Value<int?> endDate = const Value.absent(),
    bool? isArchived,
    Value<String?> source = const Value.absent(),
    Value<double?> pricePaid = const Value.absent(),
    Value<String?> barcode = const Value.absent(),
    Value<String?> importSource = const Value.absent(),
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => SupplementRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    name: name ?? this.name,
    form: form ?? this.form,
    dosageQuantity: dosageQuantity ?? this.dosageQuantity,
    dosageUnit: dosageUnit ?? this.dosageUnit,
    customForm: customForm.present ? customForm.value : this.customForm,
    customDosageUnit: customDosageUnit.present
        ? customDosageUnit.value
        : this.customDosageUnit,
    brand: brand ?? this.brand,
    notes: notes ?? this.notes,
    ingredients: ingredients ?? this.ingredients,
    schedules: schedules ?? this.schedules,
    startDate: startDate.present ? startDate.value : this.startDate,
    endDate: endDate.present ? endDate.value : this.endDate,
    isArchived: isArchived ?? this.isArchived,
    source: source.present ? source.value : this.source,
    pricePaid: pricePaid.present ? pricePaid.value : this.pricePaid,
    barcode: barcode.present ? barcode.value : this.barcode,
    importSource: importSource.present ? importSource.value : this.importSource,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  SupplementRow copyWithCompanion(SupplementsCompanion data) {
    return SupplementRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      name: data.name.present ? data.name.value : this.name,
      form: data.form.present ? data.form.value : this.form,
      dosageQuantity: data.dosageQuantity.present
          ? data.dosageQuantity.value
          : this.dosageQuantity,
      dosageUnit: data.dosageUnit.present
          ? data.dosageUnit.value
          : this.dosageUnit,
      customForm: data.customForm.present
          ? data.customForm.value
          : this.customForm,
      customDosageUnit: data.customDosageUnit.present
          ? data.customDosageUnit.value
          : this.customDosageUnit,
      brand: data.brand.present ? data.brand.value : this.brand,
      notes: data.notes.present ? data.notes.value : this.notes,
      ingredients: data.ingredients.present
          ? data.ingredients.value
          : this.ingredients,
      schedules: data.schedules.present ? data.schedules.value : this.schedules,
      startDate: data.startDate.present ? data.startDate.value : this.startDate,
      endDate: data.endDate.present ? data.endDate.value : this.endDate,
      isArchived: data.isArchived.present
          ? data.isArchived.value
          : this.isArchived,
      source: data.source.present ? data.source.value : this.source,
      pricePaid: data.pricePaid.present ? data.pricePaid.value : this.pricePaid,
      barcode: data.barcode.present ? data.barcode.value : this.barcode,
      importSource: data.importSource.present
          ? data.importSource.value
          : this.importSource,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SupplementRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('name: $name, ')
          ..write('form: $form, ')
          ..write('dosageQuantity: $dosageQuantity, ')
          ..write('dosageUnit: $dosageUnit, ')
          ..write('customForm: $customForm, ')
          ..write('customDosageUnit: $customDosageUnit, ')
          ..write('brand: $brand, ')
          ..write('notes: $notes, ')
          ..write('ingredients: $ingredients, ')
          ..write('schedules: $schedules, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('isArchived: $isArchived, ')
          ..write('source: $source, ')
          ..write('pricePaid: $pricePaid, ')
          ..write('barcode: $barcode, ')
          ..write('importSource: $importSource, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    clientId,
    profileId,
    name,
    form,
    dosageQuantity,
    dosageUnit,
    customForm,
    customDosageUnit,
    brand,
    notes,
    ingredients,
    schedules,
    startDate,
    endDate,
    isArchived,
    source,
    pricePaid,
    barcode,
    importSource,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SupplementRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.name == this.name &&
          other.form == this.form &&
          other.dosageQuantity == this.dosageQuantity &&
          other.dosageUnit == this.dosageUnit &&
          other.customForm == this.customForm &&
          other.customDosageUnit == this.customDosageUnit &&
          other.brand == this.brand &&
          other.notes == this.notes &&
          other.ingredients == this.ingredients &&
          other.schedules == this.schedules &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.isArchived == this.isArchived &&
          other.source == this.source &&
          other.pricePaid == this.pricePaid &&
          other.barcode == this.barcode &&
          other.importSource == this.importSource &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class SupplementsCompanion extends UpdateCompanion<SupplementRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<String> name;
  final Value<int> form;
  final Value<int> dosageQuantity;
  final Value<int> dosageUnit;
  final Value<String?> customForm;
  final Value<String?> customDosageUnit;
  final Value<String> brand;
  final Value<String> notes;
  final Value<String> ingredients;
  final Value<String> schedules;
  final Value<int?> startDate;
  final Value<int?> endDate;
  final Value<bool> isArchived;
  final Value<String?> source;
  final Value<double?> pricePaid;
  final Value<String?> barcode;
  final Value<String?> importSource;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const SupplementsCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.name = const Value.absent(),
    this.form = const Value.absent(),
    this.dosageQuantity = const Value.absent(),
    this.dosageUnit = const Value.absent(),
    this.customForm = const Value.absent(),
    this.customDosageUnit = const Value.absent(),
    this.brand = const Value.absent(),
    this.notes = const Value.absent(),
    this.ingredients = const Value.absent(),
    this.schedules = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.isArchived = const Value.absent(),
    this.source = const Value.absent(),
    this.pricePaid = const Value.absent(),
    this.barcode = const Value.absent(),
    this.importSource = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SupplementsCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required String name,
    required int form,
    required int dosageQuantity,
    required int dosageUnit,
    this.customForm = const Value.absent(),
    this.customDosageUnit = const Value.absent(),
    this.brand = const Value.absent(),
    this.notes = const Value.absent(),
    this.ingredients = const Value.absent(),
    this.schedules = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.isArchived = const Value.absent(),
    this.source = const Value.absent(),
    this.pricePaid = const Value.absent(),
    this.barcode = const Value.absent(),
    this.importSource = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       name = Value(name),
       form = Value(form),
       dosageQuantity = Value(dosageQuantity),
       dosageUnit = Value(dosageUnit),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<SupplementRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<String>? name,
    Expression<int>? form,
    Expression<int>? dosageQuantity,
    Expression<int>? dosageUnit,
    Expression<String>? customForm,
    Expression<String>? customDosageUnit,
    Expression<String>? brand,
    Expression<String>? notes,
    Expression<String>? ingredients,
    Expression<String>? schedules,
    Expression<int>? startDate,
    Expression<int>? endDate,
    Expression<bool>? isArchived,
    Expression<String>? source,
    Expression<double>? pricePaid,
    Expression<String>? barcode,
    Expression<String>? importSource,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (name != null) 'name': name,
      if (form != null) 'form': form,
      if (dosageQuantity != null) 'dosage_quantity': dosageQuantity,
      if (dosageUnit != null) 'dosage_unit': dosageUnit,
      if (customForm != null) 'custom_form': customForm,
      if (customDosageUnit != null) 'custom_dosage_unit': customDosageUnit,
      if (brand != null) 'brand': brand,
      if (notes != null) 'notes': notes,
      if (ingredients != null) 'ingredients': ingredients,
      if (schedules != null) 'schedules': schedules,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (isArchived != null) 'is_archived': isArchived,
      if (source != null) 'source': source,
      if (pricePaid != null) 'price_paid': pricePaid,
      if (barcode != null) 'barcode': barcode,
      if (importSource != null) 'import_source': importSource,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SupplementsCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<String>? name,
    Value<int>? form,
    Value<int>? dosageQuantity,
    Value<int>? dosageUnit,
    Value<String?>? customForm,
    Value<String?>? customDosageUnit,
    Value<String>? brand,
    Value<String>? notes,
    Value<String>? ingredients,
    Value<String>? schedules,
    Value<int?>? startDate,
    Value<int?>? endDate,
    Value<bool>? isArchived,
    Value<String?>? source,
    Value<double?>? pricePaid,
    Value<String?>? barcode,
    Value<String?>? importSource,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return SupplementsCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      name: name ?? this.name,
      form: form ?? this.form,
      dosageQuantity: dosageQuantity ?? this.dosageQuantity,
      dosageUnit: dosageUnit ?? this.dosageUnit,
      customForm: customForm ?? this.customForm,
      customDosageUnit: customDosageUnit ?? this.customDosageUnit,
      brand: brand ?? this.brand,
      notes: notes ?? this.notes,
      ingredients: ingredients ?? this.ingredients,
      schedules: schedules ?? this.schedules,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      isArchived: isArchived ?? this.isArchived,
      source: source ?? this.source,
      pricePaid: pricePaid ?? this.pricePaid,
      barcode: barcode ?? this.barcode,
      importSource: importSource ?? this.importSource,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (form.present) {
      map['form'] = Variable<int>(form.value);
    }
    if (dosageQuantity.present) {
      map['dosage_quantity'] = Variable<int>(dosageQuantity.value);
    }
    if (dosageUnit.present) {
      map['dosage_unit'] = Variable<int>(dosageUnit.value);
    }
    if (customForm.present) {
      map['custom_form'] = Variable<String>(customForm.value);
    }
    if (customDosageUnit.present) {
      map['custom_dosage_unit'] = Variable<String>(customDosageUnit.value);
    }
    if (brand.present) {
      map['brand'] = Variable<String>(brand.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (ingredients.present) {
      map['ingredients'] = Variable<String>(ingredients.value);
    }
    if (schedules.present) {
      map['schedules'] = Variable<String>(schedules.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<int>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<int>(endDate.value);
    }
    if (isArchived.present) {
      map['is_archived'] = Variable<bool>(isArchived.value);
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    if (pricePaid.present) {
      map['price_paid'] = Variable<double>(pricePaid.value);
    }
    if (barcode.present) {
      map['barcode'] = Variable<String>(barcode.value);
    }
    if (importSource.present) {
      map['import_source'] = Variable<String>(importSource.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SupplementsCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('name: $name, ')
          ..write('form: $form, ')
          ..write('dosageQuantity: $dosageQuantity, ')
          ..write('dosageUnit: $dosageUnit, ')
          ..write('customForm: $customForm, ')
          ..write('customDosageUnit: $customDosageUnit, ')
          ..write('brand: $brand, ')
          ..write('notes: $notes, ')
          ..write('ingredients: $ingredients, ')
          ..write('schedules: $schedules, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('isArchived: $isArchived, ')
          ..write('source: $source, ')
          ..write('pricePaid: $pricePaid, ')
          ..write('barcode: $barcode, ')
          ..write('importSource: $importSource, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $IntakeLogsTable extends IntakeLogs
    with TableInfo<$IntakeLogsTable, IntakeLogRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $IntakeLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _supplementIdMeta = const VerificationMeta(
    'supplementId',
  );
  @override
  late final GeneratedColumn<String> supplementId = GeneratedColumn<String>(
    'supplement_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _scheduledTimeMeta = const VerificationMeta(
    'scheduledTime',
  );
  @override
  late final GeneratedColumn<int> scheduledTime = GeneratedColumn<int>(
    'scheduled_time',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<int> status = GeneratedColumn<int>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _actualTimeMeta = const VerificationMeta(
    'actualTime',
  );
  @override
  late final GeneratedColumn<int> actualTime = GeneratedColumn<int>(
    'actual_time',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
    'reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _noteMeta = const VerificationMeta('note');
  @override
  late final GeneratedColumn<String> note = GeneratedColumn<String>(
    'note',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _snoozeDurationMinutesMeta =
      const VerificationMeta('snoozeDurationMinutes');
  @override
  late final GeneratedColumn<int> snoozeDurationMinutes = GeneratedColumn<int>(
    'snooze_duration_minutes',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    supplementId,
    scheduledTime,
    status,
    actualTime,
    reason,
    note,
    snoozeDurationMinutes,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'intake_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<IntakeLogRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('supplement_id')) {
      context.handle(
        _supplementIdMeta,
        supplementId.isAcceptableOrUnknown(
          data['supplement_id']!,
          _supplementIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_supplementIdMeta);
    }
    if (data.containsKey('scheduled_time')) {
      context.handle(
        _scheduledTimeMeta,
        scheduledTime.isAcceptableOrUnknown(
          data['scheduled_time']!,
          _scheduledTimeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_scheduledTimeMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('actual_time')) {
      context.handle(
        _actualTimeMeta,
        actualTime.isAcceptableOrUnknown(data['actual_time']!, _actualTimeMeta),
      );
    }
    if (data.containsKey('reason')) {
      context.handle(
        _reasonMeta,
        reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta),
      );
    }
    if (data.containsKey('note')) {
      context.handle(
        _noteMeta,
        note.isAcceptableOrUnknown(data['note']!, _noteMeta),
      );
    }
    if (data.containsKey('snooze_duration_minutes')) {
      context.handle(
        _snoozeDurationMinutesMeta,
        snoozeDurationMinutes.isAcceptableOrUnknown(
          data['snooze_duration_minutes']!,
          _snoozeDurationMinutesMeta,
        ),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  IntakeLogRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return IntakeLogRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      supplementId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}supplement_id'],
      )!,
      scheduledTime: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}scheduled_time'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}status'],
      )!,
      actualTime: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}actual_time'],
      ),
      reason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reason'],
      ),
      note: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}note'],
      ),
      snoozeDurationMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}snooze_duration_minutes'],
      ),
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $IntakeLogsTable createAlias(String alias) {
    return $IntakeLogsTable(attachedDatabase, alias);
  }
}

class IntakeLogRow extends DataClass implements Insertable<IntakeLogRow> {
  final String id;
  final String clientId;
  final String profileId;
  final String supplementId;
  final int scheduledTime;
  final int status;
  final int? actualTime;
  final String? reason;
  final String? note;
  final int? snoozeDurationMinutes;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const IntakeLogRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.supplementId,
    required this.scheduledTime,
    required this.status,
    this.actualTime,
    this.reason,
    this.note,
    this.snoozeDurationMinutes,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['supplement_id'] = Variable<String>(supplementId);
    map['scheduled_time'] = Variable<int>(scheduledTime);
    map['status'] = Variable<int>(status);
    if (!nullToAbsent || actualTime != null) {
      map['actual_time'] = Variable<int>(actualTime);
    }
    if (!nullToAbsent || reason != null) {
      map['reason'] = Variable<String>(reason);
    }
    if (!nullToAbsent || note != null) {
      map['note'] = Variable<String>(note);
    }
    if (!nullToAbsent || snoozeDurationMinutes != null) {
      map['snooze_duration_minutes'] = Variable<int>(snoozeDurationMinutes);
    }
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  IntakeLogsCompanion toCompanion(bool nullToAbsent) {
    return IntakeLogsCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      supplementId: Value(supplementId),
      scheduledTime: Value(scheduledTime),
      status: Value(status),
      actualTime: actualTime == null && nullToAbsent
          ? const Value.absent()
          : Value(actualTime),
      reason: reason == null && nullToAbsent
          ? const Value.absent()
          : Value(reason),
      note: note == null && nullToAbsent ? const Value.absent() : Value(note),
      snoozeDurationMinutes: snoozeDurationMinutes == null && nullToAbsent
          ? const Value.absent()
          : Value(snoozeDurationMinutes),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory IntakeLogRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return IntakeLogRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      supplementId: serializer.fromJson<String>(json['supplementId']),
      scheduledTime: serializer.fromJson<int>(json['scheduledTime']),
      status: serializer.fromJson<int>(json['status']),
      actualTime: serializer.fromJson<int?>(json['actualTime']),
      reason: serializer.fromJson<String?>(json['reason']),
      note: serializer.fromJson<String?>(json['note']),
      snoozeDurationMinutes: serializer.fromJson<int?>(
        json['snoozeDurationMinutes'],
      ),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'supplementId': serializer.toJson<String>(supplementId),
      'scheduledTime': serializer.toJson<int>(scheduledTime),
      'status': serializer.toJson<int>(status),
      'actualTime': serializer.toJson<int?>(actualTime),
      'reason': serializer.toJson<String?>(reason),
      'note': serializer.toJson<String?>(note),
      'snoozeDurationMinutes': serializer.toJson<int?>(snoozeDurationMinutes),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  IntakeLogRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    String? supplementId,
    int? scheduledTime,
    int? status,
    Value<int?> actualTime = const Value.absent(),
    Value<String?> reason = const Value.absent(),
    Value<String?> note = const Value.absent(),
    Value<int?> snoozeDurationMinutes = const Value.absent(),
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => IntakeLogRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    supplementId: supplementId ?? this.supplementId,
    scheduledTime: scheduledTime ?? this.scheduledTime,
    status: status ?? this.status,
    actualTime: actualTime.present ? actualTime.value : this.actualTime,
    reason: reason.present ? reason.value : this.reason,
    note: note.present ? note.value : this.note,
    snoozeDurationMinutes: snoozeDurationMinutes.present
        ? snoozeDurationMinutes.value
        : this.snoozeDurationMinutes,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  IntakeLogRow copyWithCompanion(IntakeLogsCompanion data) {
    return IntakeLogRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      supplementId: data.supplementId.present
          ? data.supplementId.value
          : this.supplementId,
      scheduledTime: data.scheduledTime.present
          ? data.scheduledTime.value
          : this.scheduledTime,
      status: data.status.present ? data.status.value : this.status,
      actualTime: data.actualTime.present
          ? data.actualTime.value
          : this.actualTime,
      reason: data.reason.present ? data.reason.value : this.reason,
      note: data.note.present ? data.note.value : this.note,
      snoozeDurationMinutes: data.snoozeDurationMinutes.present
          ? data.snoozeDurationMinutes.value
          : this.snoozeDurationMinutes,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('IntakeLogRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('supplementId: $supplementId, ')
          ..write('scheduledTime: $scheduledTime, ')
          ..write('status: $status, ')
          ..write('actualTime: $actualTime, ')
          ..write('reason: $reason, ')
          ..write('note: $note, ')
          ..write('snoozeDurationMinutes: $snoozeDurationMinutes, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    clientId,
    profileId,
    supplementId,
    scheduledTime,
    status,
    actualTime,
    reason,
    note,
    snoozeDurationMinutes,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is IntakeLogRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.supplementId == this.supplementId &&
          other.scheduledTime == this.scheduledTime &&
          other.status == this.status &&
          other.actualTime == this.actualTime &&
          other.reason == this.reason &&
          other.note == this.note &&
          other.snoozeDurationMinutes == this.snoozeDurationMinutes &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class IntakeLogsCompanion extends UpdateCompanion<IntakeLogRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<String> supplementId;
  final Value<int> scheduledTime;
  final Value<int> status;
  final Value<int?> actualTime;
  final Value<String?> reason;
  final Value<String?> note;
  final Value<int?> snoozeDurationMinutes;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const IntakeLogsCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.supplementId = const Value.absent(),
    this.scheduledTime = const Value.absent(),
    this.status = const Value.absent(),
    this.actualTime = const Value.absent(),
    this.reason = const Value.absent(),
    this.note = const Value.absent(),
    this.snoozeDurationMinutes = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  IntakeLogsCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required String supplementId,
    required int scheduledTime,
    required int status,
    this.actualTime = const Value.absent(),
    this.reason = const Value.absent(),
    this.note = const Value.absent(),
    this.snoozeDurationMinutes = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       supplementId = Value(supplementId),
       scheduledTime = Value(scheduledTime),
       status = Value(status),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<IntakeLogRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<String>? supplementId,
    Expression<int>? scheduledTime,
    Expression<int>? status,
    Expression<int>? actualTime,
    Expression<String>? reason,
    Expression<String>? note,
    Expression<int>? snoozeDurationMinutes,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (supplementId != null) 'supplement_id': supplementId,
      if (scheduledTime != null) 'scheduled_time': scheduledTime,
      if (status != null) 'status': status,
      if (actualTime != null) 'actual_time': actualTime,
      if (reason != null) 'reason': reason,
      if (note != null) 'note': note,
      if (snoozeDurationMinutes != null)
        'snooze_duration_minutes': snoozeDurationMinutes,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  IntakeLogsCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<String>? supplementId,
    Value<int>? scheduledTime,
    Value<int>? status,
    Value<int?>? actualTime,
    Value<String?>? reason,
    Value<String?>? note,
    Value<int?>? snoozeDurationMinutes,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return IntakeLogsCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      supplementId: supplementId ?? this.supplementId,
      scheduledTime: scheduledTime ?? this.scheduledTime,
      status: status ?? this.status,
      actualTime: actualTime ?? this.actualTime,
      reason: reason ?? this.reason,
      note: note ?? this.note,
      snoozeDurationMinutes:
          snoozeDurationMinutes ?? this.snoozeDurationMinutes,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (supplementId.present) {
      map['supplement_id'] = Variable<String>(supplementId.value);
    }
    if (scheduledTime.present) {
      map['scheduled_time'] = Variable<int>(scheduledTime.value);
    }
    if (status.present) {
      map['status'] = Variable<int>(status.value);
    }
    if (actualTime.present) {
      map['actual_time'] = Variable<int>(actualTime.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (note.present) {
      map['note'] = Variable<String>(note.value);
    }
    if (snoozeDurationMinutes.present) {
      map['snooze_duration_minutes'] = Variable<int>(
        snoozeDurationMinutes.value,
      );
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('IntakeLogsCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('supplementId: $supplementId, ')
          ..write('scheduledTime: $scheduledTime, ')
          ..write('status: $status, ')
          ..write('actualTime: $actualTime, ')
          ..write('reason: $reason, ')
          ..write('note: $note, ')
          ..write('snoozeDurationMinutes: $snoozeDurationMinutes, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ConditionsTable extends Conditions
    with TableInfo<$ConditionsTable, ConditionRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ConditionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _categoryMeta = const VerificationMeta(
    'category',
  );
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
    'category',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bodyLocationsMeta = const VerificationMeta(
    'bodyLocations',
  );
  @override
  late final GeneratedColumn<String> bodyLocations = GeneratedColumn<String>(
    'body_locations',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('[]'),
  );
  static const VerificationMeta _triggersMeta = const VerificationMeta(
    'triggers',
  );
  @override
  late final GeneratedColumn<String> triggers = GeneratedColumn<String>(
    'triggers',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('[]'),
  );
  static const VerificationMeta _startTimeframeMeta = const VerificationMeta(
    'startTimeframe',
  );
  @override
  late final GeneratedColumn<int> startTimeframe = GeneratedColumn<int>(
    'start_timeframe',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<int> status = GeneratedColumn<int>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _baselinePhotoPathMeta = const VerificationMeta(
    'baselinePhotoPath',
  );
  @override
  late final GeneratedColumn<String> baselinePhotoPath =
      GeneratedColumn<String>(
        'baseline_photo_path',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _endDateMeta = const VerificationMeta(
    'endDate',
  );
  @override
  late final GeneratedColumn<int> endDate = GeneratedColumn<int>(
    'end_date',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isArchivedMeta = const VerificationMeta(
    'isArchived',
  );
  @override
  late final GeneratedColumn<bool> isArchived = GeneratedColumn<bool>(
    'is_archived',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_archived" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _activityIdMeta = const VerificationMeta(
    'activityId',
  );
  @override
  late final GeneratedColumn<String> activityId = GeneratedColumn<String>(
    'activity_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cloudStorageUrlMeta = const VerificationMeta(
    'cloudStorageUrl',
  );
  @override
  late final GeneratedColumn<String> cloudStorageUrl = GeneratedColumn<String>(
    'cloud_storage_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fileHashMeta = const VerificationMeta(
    'fileHash',
  );
  @override
  late final GeneratedColumn<String> fileHash = GeneratedColumn<String>(
    'file_hash',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fileSizeBytesMeta = const VerificationMeta(
    'fileSizeBytes',
  );
  @override
  late final GeneratedColumn<int> fileSizeBytes = GeneratedColumn<int>(
    'file_size_bytes',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isFileUploadedMeta = const VerificationMeta(
    'isFileUploaded',
  );
  @override
  late final GeneratedColumn<bool> isFileUploaded = GeneratedColumn<bool>(
    'is_file_uploaded',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_file_uploaded" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    name,
    category,
    bodyLocations,
    triggers,
    startTimeframe,
    status,
    description,
    baselinePhotoPath,
    endDate,
    isArchived,
    activityId,
    cloudStorageUrl,
    fileHash,
    fileSizeBytes,
    isFileUploaded,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'conditions';
  @override
  VerificationContext validateIntegrity(
    Insertable<ConditionRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('category')) {
      context.handle(
        _categoryMeta,
        category.isAcceptableOrUnknown(data['category']!, _categoryMeta),
      );
    } else if (isInserting) {
      context.missing(_categoryMeta);
    }
    if (data.containsKey('body_locations')) {
      context.handle(
        _bodyLocationsMeta,
        bodyLocations.isAcceptableOrUnknown(
          data['body_locations']!,
          _bodyLocationsMeta,
        ),
      );
    }
    if (data.containsKey('triggers')) {
      context.handle(
        _triggersMeta,
        triggers.isAcceptableOrUnknown(data['triggers']!, _triggersMeta),
      );
    }
    if (data.containsKey('start_timeframe')) {
      context.handle(
        _startTimeframeMeta,
        startTimeframe.isAcceptableOrUnknown(
          data['start_timeframe']!,
          _startTimeframeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_startTimeframeMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('baseline_photo_path')) {
      context.handle(
        _baselinePhotoPathMeta,
        baselinePhotoPath.isAcceptableOrUnknown(
          data['baseline_photo_path']!,
          _baselinePhotoPathMeta,
        ),
      );
    }
    if (data.containsKey('end_date')) {
      context.handle(
        _endDateMeta,
        endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta),
      );
    }
    if (data.containsKey('is_archived')) {
      context.handle(
        _isArchivedMeta,
        isArchived.isAcceptableOrUnknown(data['is_archived']!, _isArchivedMeta),
      );
    }
    if (data.containsKey('activity_id')) {
      context.handle(
        _activityIdMeta,
        activityId.isAcceptableOrUnknown(data['activity_id']!, _activityIdMeta),
      );
    }
    if (data.containsKey('cloud_storage_url')) {
      context.handle(
        _cloudStorageUrlMeta,
        cloudStorageUrl.isAcceptableOrUnknown(
          data['cloud_storage_url']!,
          _cloudStorageUrlMeta,
        ),
      );
    }
    if (data.containsKey('file_hash')) {
      context.handle(
        _fileHashMeta,
        fileHash.isAcceptableOrUnknown(data['file_hash']!, _fileHashMeta),
      );
    }
    if (data.containsKey('file_size_bytes')) {
      context.handle(
        _fileSizeBytesMeta,
        fileSizeBytes.isAcceptableOrUnknown(
          data['file_size_bytes']!,
          _fileSizeBytesMeta,
        ),
      );
    }
    if (data.containsKey('is_file_uploaded')) {
      context.handle(
        _isFileUploadedMeta,
        isFileUploaded.isAcceptableOrUnknown(
          data['is_file_uploaded']!,
          _isFileUploadedMeta,
        ),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ConditionRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ConditionRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      category: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category'],
      )!,
      bodyLocations: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}body_locations'],
      )!,
      triggers: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}triggers'],
      )!,
      startTimeframe: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}start_timeframe'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}status'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      baselinePhotoPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}baseline_photo_path'],
      ),
      endDate: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_date'],
      ),
      isArchived: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_archived'],
      )!,
      activityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}activity_id'],
      ),
      cloudStorageUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cloud_storage_url'],
      ),
      fileHash: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}file_hash'],
      ),
      fileSizeBytes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}file_size_bytes'],
      ),
      isFileUploaded: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_file_uploaded'],
      )!,
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $ConditionsTable createAlias(String alias) {
    return $ConditionsTable(attachedDatabase, alias);
  }
}

class ConditionRow extends DataClass implements Insertable<ConditionRow> {
  final String id;
  final String clientId;
  final String profileId;
  final String name;
  final String category;
  final String bodyLocations;
  final String triggers;
  final int startTimeframe;
  final int status;
  final String? description;
  final String? baselinePhotoPath;
  final int? endDate;
  final bool isArchived;
  final String? activityId;
  final String? cloudStorageUrl;
  final String? fileHash;
  final int? fileSizeBytes;
  final bool isFileUploaded;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const ConditionRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.name,
    required this.category,
    required this.bodyLocations,
    required this.triggers,
    required this.startTimeframe,
    required this.status,
    this.description,
    this.baselinePhotoPath,
    this.endDate,
    required this.isArchived,
    this.activityId,
    this.cloudStorageUrl,
    this.fileHash,
    this.fileSizeBytes,
    required this.isFileUploaded,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['name'] = Variable<String>(name);
    map['category'] = Variable<String>(category);
    map['body_locations'] = Variable<String>(bodyLocations);
    map['triggers'] = Variable<String>(triggers);
    map['start_timeframe'] = Variable<int>(startTimeframe);
    map['status'] = Variable<int>(status);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || baselinePhotoPath != null) {
      map['baseline_photo_path'] = Variable<String>(baselinePhotoPath);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<int>(endDate);
    }
    map['is_archived'] = Variable<bool>(isArchived);
    if (!nullToAbsent || activityId != null) {
      map['activity_id'] = Variable<String>(activityId);
    }
    if (!nullToAbsent || cloudStorageUrl != null) {
      map['cloud_storage_url'] = Variable<String>(cloudStorageUrl);
    }
    if (!nullToAbsent || fileHash != null) {
      map['file_hash'] = Variable<String>(fileHash);
    }
    if (!nullToAbsent || fileSizeBytes != null) {
      map['file_size_bytes'] = Variable<int>(fileSizeBytes);
    }
    map['is_file_uploaded'] = Variable<bool>(isFileUploaded);
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  ConditionsCompanion toCompanion(bool nullToAbsent) {
    return ConditionsCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      name: Value(name),
      category: Value(category),
      bodyLocations: Value(bodyLocations),
      triggers: Value(triggers),
      startTimeframe: Value(startTimeframe),
      status: Value(status),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      baselinePhotoPath: baselinePhotoPath == null && nullToAbsent
          ? const Value.absent()
          : Value(baselinePhotoPath),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      isArchived: Value(isArchived),
      activityId: activityId == null && nullToAbsent
          ? const Value.absent()
          : Value(activityId),
      cloudStorageUrl: cloudStorageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(cloudStorageUrl),
      fileHash: fileHash == null && nullToAbsent
          ? const Value.absent()
          : Value(fileHash),
      fileSizeBytes: fileSizeBytes == null && nullToAbsent
          ? const Value.absent()
          : Value(fileSizeBytes),
      isFileUploaded: Value(isFileUploaded),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory ConditionRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ConditionRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      name: serializer.fromJson<String>(json['name']),
      category: serializer.fromJson<String>(json['category']),
      bodyLocations: serializer.fromJson<String>(json['bodyLocations']),
      triggers: serializer.fromJson<String>(json['triggers']),
      startTimeframe: serializer.fromJson<int>(json['startTimeframe']),
      status: serializer.fromJson<int>(json['status']),
      description: serializer.fromJson<String?>(json['description']),
      baselinePhotoPath: serializer.fromJson<String?>(
        json['baselinePhotoPath'],
      ),
      endDate: serializer.fromJson<int?>(json['endDate']),
      isArchived: serializer.fromJson<bool>(json['isArchived']),
      activityId: serializer.fromJson<String?>(json['activityId']),
      cloudStorageUrl: serializer.fromJson<String?>(json['cloudStorageUrl']),
      fileHash: serializer.fromJson<String?>(json['fileHash']),
      fileSizeBytes: serializer.fromJson<int?>(json['fileSizeBytes']),
      isFileUploaded: serializer.fromJson<bool>(json['isFileUploaded']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'name': serializer.toJson<String>(name),
      'category': serializer.toJson<String>(category),
      'bodyLocations': serializer.toJson<String>(bodyLocations),
      'triggers': serializer.toJson<String>(triggers),
      'startTimeframe': serializer.toJson<int>(startTimeframe),
      'status': serializer.toJson<int>(status),
      'description': serializer.toJson<String?>(description),
      'baselinePhotoPath': serializer.toJson<String?>(baselinePhotoPath),
      'endDate': serializer.toJson<int?>(endDate),
      'isArchived': serializer.toJson<bool>(isArchived),
      'activityId': serializer.toJson<String?>(activityId),
      'cloudStorageUrl': serializer.toJson<String?>(cloudStorageUrl),
      'fileHash': serializer.toJson<String?>(fileHash),
      'fileSizeBytes': serializer.toJson<int?>(fileSizeBytes),
      'isFileUploaded': serializer.toJson<bool>(isFileUploaded),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  ConditionRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    String? name,
    String? category,
    String? bodyLocations,
    String? triggers,
    int? startTimeframe,
    int? status,
    Value<String?> description = const Value.absent(),
    Value<String?> baselinePhotoPath = const Value.absent(),
    Value<int?> endDate = const Value.absent(),
    bool? isArchived,
    Value<String?> activityId = const Value.absent(),
    Value<String?> cloudStorageUrl = const Value.absent(),
    Value<String?> fileHash = const Value.absent(),
    Value<int?> fileSizeBytes = const Value.absent(),
    bool? isFileUploaded,
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => ConditionRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    name: name ?? this.name,
    category: category ?? this.category,
    bodyLocations: bodyLocations ?? this.bodyLocations,
    triggers: triggers ?? this.triggers,
    startTimeframe: startTimeframe ?? this.startTimeframe,
    status: status ?? this.status,
    description: description.present ? description.value : this.description,
    baselinePhotoPath: baselinePhotoPath.present
        ? baselinePhotoPath.value
        : this.baselinePhotoPath,
    endDate: endDate.present ? endDate.value : this.endDate,
    isArchived: isArchived ?? this.isArchived,
    activityId: activityId.present ? activityId.value : this.activityId,
    cloudStorageUrl: cloudStorageUrl.present
        ? cloudStorageUrl.value
        : this.cloudStorageUrl,
    fileHash: fileHash.present ? fileHash.value : this.fileHash,
    fileSizeBytes: fileSizeBytes.present
        ? fileSizeBytes.value
        : this.fileSizeBytes,
    isFileUploaded: isFileUploaded ?? this.isFileUploaded,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  ConditionRow copyWithCompanion(ConditionsCompanion data) {
    return ConditionRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      name: data.name.present ? data.name.value : this.name,
      category: data.category.present ? data.category.value : this.category,
      bodyLocations: data.bodyLocations.present
          ? data.bodyLocations.value
          : this.bodyLocations,
      triggers: data.triggers.present ? data.triggers.value : this.triggers,
      startTimeframe: data.startTimeframe.present
          ? data.startTimeframe.value
          : this.startTimeframe,
      status: data.status.present ? data.status.value : this.status,
      description: data.description.present
          ? data.description.value
          : this.description,
      baselinePhotoPath: data.baselinePhotoPath.present
          ? data.baselinePhotoPath.value
          : this.baselinePhotoPath,
      endDate: data.endDate.present ? data.endDate.value : this.endDate,
      isArchived: data.isArchived.present
          ? data.isArchived.value
          : this.isArchived,
      activityId: data.activityId.present
          ? data.activityId.value
          : this.activityId,
      cloudStorageUrl: data.cloudStorageUrl.present
          ? data.cloudStorageUrl.value
          : this.cloudStorageUrl,
      fileHash: data.fileHash.present ? data.fileHash.value : this.fileHash,
      fileSizeBytes: data.fileSizeBytes.present
          ? data.fileSizeBytes.value
          : this.fileSizeBytes,
      isFileUploaded: data.isFileUploaded.present
          ? data.isFileUploaded.value
          : this.isFileUploaded,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ConditionRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('name: $name, ')
          ..write('category: $category, ')
          ..write('bodyLocations: $bodyLocations, ')
          ..write('triggers: $triggers, ')
          ..write('startTimeframe: $startTimeframe, ')
          ..write('status: $status, ')
          ..write('description: $description, ')
          ..write('baselinePhotoPath: $baselinePhotoPath, ')
          ..write('endDate: $endDate, ')
          ..write('isArchived: $isArchived, ')
          ..write('activityId: $activityId, ')
          ..write('cloudStorageUrl: $cloudStorageUrl, ')
          ..write('fileHash: $fileHash, ')
          ..write('fileSizeBytes: $fileSizeBytes, ')
          ..write('isFileUploaded: $isFileUploaded, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    clientId,
    profileId,
    name,
    category,
    bodyLocations,
    triggers,
    startTimeframe,
    status,
    description,
    baselinePhotoPath,
    endDate,
    isArchived,
    activityId,
    cloudStorageUrl,
    fileHash,
    fileSizeBytes,
    isFileUploaded,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ConditionRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.name == this.name &&
          other.category == this.category &&
          other.bodyLocations == this.bodyLocations &&
          other.triggers == this.triggers &&
          other.startTimeframe == this.startTimeframe &&
          other.status == this.status &&
          other.description == this.description &&
          other.baselinePhotoPath == this.baselinePhotoPath &&
          other.endDate == this.endDate &&
          other.isArchived == this.isArchived &&
          other.activityId == this.activityId &&
          other.cloudStorageUrl == this.cloudStorageUrl &&
          other.fileHash == this.fileHash &&
          other.fileSizeBytes == this.fileSizeBytes &&
          other.isFileUploaded == this.isFileUploaded &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class ConditionsCompanion extends UpdateCompanion<ConditionRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<String> name;
  final Value<String> category;
  final Value<String> bodyLocations;
  final Value<String> triggers;
  final Value<int> startTimeframe;
  final Value<int> status;
  final Value<String?> description;
  final Value<String?> baselinePhotoPath;
  final Value<int?> endDate;
  final Value<bool> isArchived;
  final Value<String?> activityId;
  final Value<String?> cloudStorageUrl;
  final Value<String?> fileHash;
  final Value<int?> fileSizeBytes;
  final Value<bool> isFileUploaded;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const ConditionsCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.name = const Value.absent(),
    this.category = const Value.absent(),
    this.bodyLocations = const Value.absent(),
    this.triggers = const Value.absent(),
    this.startTimeframe = const Value.absent(),
    this.status = const Value.absent(),
    this.description = const Value.absent(),
    this.baselinePhotoPath = const Value.absent(),
    this.endDate = const Value.absent(),
    this.isArchived = const Value.absent(),
    this.activityId = const Value.absent(),
    this.cloudStorageUrl = const Value.absent(),
    this.fileHash = const Value.absent(),
    this.fileSizeBytes = const Value.absent(),
    this.isFileUploaded = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ConditionsCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required String name,
    required String category,
    this.bodyLocations = const Value.absent(),
    this.triggers = const Value.absent(),
    required int startTimeframe,
    required int status,
    this.description = const Value.absent(),
    this.baselinePhotoPath = const Value.absent(),
    this.endDate = const Value.absent(),
    this.isArchived = const Value.absent(),
    this.activityId = const Value.absent(),
    this.cloudStorageUrl = const Value.absent(),
    this.fileHash = const Value.absent(),
    this.fileSizeBytes = const Value.absent(),
    this.isFileUploaded = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       name = Value(name),
       category = Value(category),
       startTimeframe = Value(startTimeframe),
       status = Value(status),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<ConditionRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<String>? name,
    Expression<String>? category,
    Expression<String>? bodyLocations,
    Expression<String>? triggers,
    Expression<int>? startTimeframe,
    Expression<int>? status,
    Expression<String>? description,
    Expression<String>? baselinePhotoPath,
    Expression<int>? endDate,
    Expression<bool>? isArchived,
    Expression<String>? activityId,
    Expression<String>? cloudStorageUrl,
    Expression<String>? fileHash,
    Expression<int>? fileSizeBytes,
    Expression<bool>? isFileUploaded,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (name != null) 'name': name,
      if (category != null) 'category': category,
      if (bodyLocations != null) 'body_locations': bodyLocations,
      if (triggers != null) 'triggers': triggers,
      if (startTimeframe != null) 'start_timeframe': startTimeframe,
      if (status != null) 'status': status,
      if (description != null) 'description': description,
      if (baselinePhotoPath != null) 'baseline_photo_path': baselinePhotoPath,
      if (endDate != null) 'end_date': endDate,
      if (isArchived != null) 'is_archived': isArchived,
      if (activityId != null) 'activity_id': activityId,
      if (cloudStorageUrl != null) 'cloud_storage_url': cloudStorageUrl,
      if (fileHash != null) 'file_hash': fileHash,
      if (fileSizeBytes != null) 'file_size_bytes': fileSizeBytes,
      if (isFileUploaded != null) 'is_file_uploaded': isFileUploaded,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ConditionsCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<String>? name,
    Value<String>? category,
    Value<String>? bodyLocations,
    Value<String>? triggers,
    Value<int>? startTimeframe,
    Value<int>? status,
    Value<String?>? description,
    Value<String?>? baselinePhotoPath,
    Value<int?>? endDate,
    Value<bool>? isArchived,
    Value<String?>? activityId,
    Value<String?>? cloudStorageUrl,
    Value<String?>? fileHash,
    Value<int?>? fileSizeBytes,
    Value<bool>? isFileUploaded,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return ConditionsCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      name: name ?? this.name,
      category: category ?? this.category,
      bodyLocations: bodyLocations ?? this.bodyLocations,
      triggers: triggers ?? this.triggers,
      startTimeframe: startTimeframe ?? this.startTimeframe,
      status: status ?? this.status,
      description: description ?? this.description,
      baselinePhotoPath: baselinePhotoPath ?? this.baselinePhotoPath,
      endDate: endDate ?? this.endDate,
      isArchived: isArchived ?? this.isArchived,
      activityId: activityId ?? this.activityId,
      cloudStorageUrl: cloudStorageUrl ?? this.cloudStorageUrl,
      fileHash: fileHash ?? this.fileHash,
      fileSizeBytes: fileSizeBytes ?? this.fileSizeBytes,
      isFileUploaded: isFileUploaded ?? this.isFileUploaded,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (bodyLocations.present) {
      map['body_locations'] = Variable<String>(bodyLocations.value);
    }
    if (triggers.present) {
      map['triggers'] = Variable<String>(triggers.value);
    }
    if (startTimeframe.present) {
      map['start_timeframe'] = Variable<int>(startTimeframe.value);
    }
    if (status.present) {
      map['status'] = Variable<int>(status.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (baselinePhotoPath.present) {
      map['baseline_photo_path'] = Variable<String>(baselinePhotoPath.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<int>(endDate.value);
    }
    if (isArchived.present) {
      map['is_archived'] = Variable<bool>(isArchived.value);
    }
    if (activityId.present) {
      map['activity_id'] = Variable<String>(activityId.value);
    }
    if (cloudStorageUrl.present) {
      map['cloud_storage_url'] = Variable<String>(cloudStorageUrl.value);
    }
    if (fileHash.present) {
      map['file_hash'] = Variable<String>(fileHash.value);
    }
    if (fileSizeBytes.present) {
      map['file_size_bytes'] = Variable<int>(fileSizeBytes.value);
    }
    if (isFileUploaded.present) {
      map['is_file_uploaded'] = Variable<bool>(isFileUploaded.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ConditionsCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('name: $name, ')
          ..write('category: $category, ')
          ..write('bodyLocations: $bodyLocations, ')
          ..write('triggers: $triggers, ')
          ..write('startTimeframe: $startTimeframe, ')
          ..write('status: $status, ')
          ..write('description: $description, ')
          ..write('baselinePhotoPath: $baselinePhotoPath, ')
          ..write('endDate: $endDate, ')
          ..write('isArchived: $isArchived, ')
          ..write('activityId: $activityId, ')
          ..write('cloudStorageUrl: $cloudStorageUrl, ')
          ..write('fileHash: $fileHash, ')
          ..write('fileSizeBytes: $fileSizeBytes, ')
          ..write('isFileUploaded: $isFileUploaded, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ConditionLogsTable extends ConditionLogs
    with TableInfo<$ConditionLogsTable, ConditionLogRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ConditionLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _conditionIdMeta = const VerificationMeta(
    'conditionId',
  );
  @override
  late final GeneratedColumn<String> conditionId = GeneratedColumn<String>(
    'condition_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<int> timestamp = GeneratedColumn<int>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _severityMeta = const VerificationMeta(
    'severity',
  );
  @override
  late final GeneratedColumn<int> severity = GeneratedColumn<int>(
    'severity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isFlareMeta = const VerificationMeta(
    'isFlare',
  );
  @override
  late final GeneratedColumn<bool> isFlare = GeneratedColumn<bool>(
    'is_flare',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_flare" IN (0, 1))',
    ),
  );
  static const VerificationMeta _flarePhotoIdsMeta = const VerificationMeta(
    'flarePhotoIds',
  );
  @override
  late final GeneratedColumn<String> flarePhotoIds = GeneratedColumn<String>(
    'flare_photo_ids',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant(''),
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _photoPathMeta = const VerificationMeta(
    'photoPath',
  );
  @override
  late final GeneratedColumn<String> photoPath = GeneratedColumn<String>(
    'photo_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _activityIdMeta = const VerificationMeta(
    'activityId',
  );
  @override
  late final GeneratedColumn<String> activityId = GeneratedColumn<String>(
    'activity_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _triggersMeta = const VerificationMeta(
    'triggers',
  );
  @override
  late final GeneratedColumn<String> triggers = GeneratedColumn<String>(
    'triggers',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cloudStorageUrlMeta = const VerificationMeta(
    'cloudStorageUrl',
  );
  @override
  late final GeneratedColumn<String> cloudStorageUrl = GeneratedColumn<String>(
    'cloud_storage_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fileHashMeta = const VerificationMeta(
    'fileHash',
  );
  @override
  late final GeneratedColumn<String> fileHash = GeneratedColumn<String>(
    'file_hash',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fileSizeBytesMeta = const VerificationMeta(
    'fileSizeBytes',
  );
  @override
  late final GeneratedColumn<int> fileSizeBytes = GeneratedColumn<int>(
    'file_size_bytes',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isFileUploadedMeta = const VerificationMeta(
    'isFileUploaded',
  );
  @override
  late final GeneratedColumn<bool> isFileUploaded = GeneratedColumn<bool>(
    'is_file_uploaded',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_file_uploaded" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    conditionId,
    timestamp,
    severity,
    isFlare,
    flarePhotoIds,
    notes,
    photoPath,
    activityId,
    triggers,
    cloudStorageUrl,
    fileHash,
    fileSizeBytes,
    isFileUploaded,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'condition_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<ConditionLogRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('condition_id')) {
      context.handle(
        _conditionIdMeta,
        conditionId.isAcceptableOrUnknown(
          data['condition_id']!,
          _conditionIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_conditionIdMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('severity')) {
      context.handle(
        _severityMeta,
        severity.isAcceptableOrUnknown(data['severity']!, _severityMeta),
      );
    } else if (isInserting) {
      context.missing(_severityMeta);
    }
    if (data.containsKey('is_flare')) {
      context.handle(
        _isFlareMeta,
        isFlare.isAcceptableOrUnknown(data['is_flare']!, _isFlareMeta),
      );
    } else if (isInserting) {
      context.missing(_isFlareMeta);
    }
    if (data.containsKey('flare_photo_ids')) {
      context.handle(
        _flarePhotoIdsMeta,
        flarePhotoIds.isAcceptableOrUnknown(
          data['flare_photo_ids']!,
          _flarePhotoIdsMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('photo_path')) {
      context.handle(
        _photoPathMeta,
        photoPath.isAcceptableOrUnknown(data['photo_path']!, _photoPathMeta),
      );
    }
    if (data.containsKey('activity_id')) {
      context.handle(
        _activityIdMeta,
        activityId.isAcceptableOrUnknown(data['activity_id']!, _activityIdMeta),
      );
    }
    if (data.containsKey('triggers')) {
      context.handle(
        _triggersMeta,
        triggers.isAcceptableOrUnknown(data['triggers']!, _triggersMeta),
      );
    }
    if (data.containsKey('cloud_storage_url')) {
      context.handle(
        _cloudStorageUrlMeta,
        cloudStorageUrl.isAcceptableOrUnknown(
          data['cloud_storage_url']!,
          _cloudStorageUrlMeta,
        ),
      );
    }
    if (data.containsKey('file_hash')) {
      context.handle(
        _fileHashMeta,
        fileHash.isAcceptableOrUnknown(data['file_hash']!, _fileHashMeta),
      );
    }
    if (data.containsKey('file_size_bytes')) {
      context.handle(
        _fileSizeBytesMeta,
        fileSizeBytes.isAcceptableOrUnknown(
          data['file_size_bytes']!,
          _fileSizeBytesMeta,
        ),
      );
    }
    if (data.containsKey('is_file_uploaded')) {
      context.handle(
        _isFileUploadedMeta,
        isFileUploaded.isAcceptableOrUnknown(
          data['is_file_uploaded']!,
          _isFileUploadedMeta,
        ),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ConditionLogRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ConditionLogRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      conditionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}condition_id'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}timestamp'],
      )!,
      severity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}severity'],
      )!,
      isFlare: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_flare'],
      )!,
      flarePhotoIds: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}flare_photo_ids'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      photoPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}photo_path'],
      ),
      activityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}activity_id'],
      ),
      triggers: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}triggers'],
      ),
      cloudStorageUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cloud_storage_url'],
      ),
      fileHash: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}file_hash'],
      ),
      fileSizeBytes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}file_size_bytes'],
      ),
      isFileUploaded: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_file_uploaded'],
      )!,
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $ConditionLogsTable createAlias(String alias) {
    return $ConditionLogsTable(attachedDatabase, alias);
  }
}

class ConditionLogRow extends DataClass implements Insertable<ConditionLogRow> {
  final String id;
  final String clientId;
  final String profileId;
  final String conditionId;
  final int timestamp;
  final int severity;
  final bool isFlare;
  final String flarePhotoIds;
  final String? notes;
  final String? photoPath;
  final String? activityId;
  final String? triggers;
  final String? cloudStorageUrl;
  final String? fileHash;
  final int? fileSizeBytes;
  final bool isFileUploaded;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const ConditionLogRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.conditionId,
    required this.timestamp,
    required this.severity,
    required this.isFlare,
    required this.flarePhotoIds,
    this.notes,
    this.photoPath,
    this.activityId,
    this.triggers,
    this.cloudStorageUrl,
    this.fileHash,
    this.fileSizeBytes,
    required this.isFileUploaded,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['condition_id'] = Variable<String>(conditionId);
    map['timestamp'] = Variable<int>(timestamp);
    map['severity'] = Variable<int>(severity);
    map['is_flare'] = Variable<bool>(isFlare);
    map['flare_photo_ids'] = Variable<String>(flarePhotoIds);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    if (!nullToAbsent || photoPath != null) {
      map['photo_path'] = Variable<String>(photoPath);
    }
    if (!nullToAbsent || activityId != null) {
      map['activity_id'] = Variable<String>(activityId);
    }
    if (!nullToAbsent || triggers != null) {
      map['triggers'] = Variable<String>(triggers);
    }
    if (!nullToAbsent || cloudStorageUrl != null) {
      map['cloud_storage_url'] = Variable<String>(cloudStorageUrl);
    }
    if (!nullToAbsent || fileHash != null) {
      map['file_hash'] = Variable<String>(fileHash);
    }
    if (!nullToAbsent || fileSizeBytes != null) {
      map['file_size_bytes'] = Variable<int>(fileSizeBytes);
    }
    map['is_file_uploaded'] = Variable<bool>(isFileUploaded);
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  ConditionLogsCompanion toCompanion(bool nullToAbsent) {
    return ConditionLogsCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      conditionId: Value(conditionId),
      timestamp: Value(timestamp),
      severity: Value(severity),
      isFlare: Value(isFlare),
      flarePhotoIds: Value(flarePhotoIds),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      photoPath: photoPath == null && nullToAbsent
          ? const Value.absent()
          : Value(photoPath),
      activityId: activityId == null && nullToAbsent
          ? const Value.absent()
          : Value(activityId),
      triggers: triggers == null && nullToAbsent
          ? const Value.absent()
          : Value(triggers),
      cloudStorageUrl: cloudStorageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(cloudStorageUrl),
      fileHash: fileHash == null && nullToAbsent
          ? const Value.absent()
          : Value(fileHash),
      fileSizeBytes: fileSizeBytes == null && nullToAbsent
          ? const Value.absent()
          : Value(fileSizeBytes),
      isFileUploaded: Value(isFileUploaded),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory ConditionLogRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ConditionLogRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      conditionId: serializer.fromJson<String>(json['conditionId']),
      timestamp: serializer.fromJson<int>(json['timestamp']),
      severity: serializer.fromJson<int>(json['severity']),
      isFlare: serializer.fromJson<bool>(json['isFlare']),
      flarePhotoIds: serializer.fromJson<String>(json['flarePhotoIds']),
      notes: serializer.fromJson<String?>(json['notes']),
      photoPath: serializer.fromJson<String?>(json['photoPath']),
      activityId: serializer.fromJson<String?>(json['activityId']),
      triggers: serializer.fromJson<String?>(json['triggers']),
      cloudStorageUrl: serializer.fromJson<String?>(json['cloudStorageUrl']),
      fileHash: serializer.fromJson<String?>(json['fileHash']),
      fileSizeBytes: serializer.fromJson<int?>(json['fileSizeBytes']),
      isFileUploaded: serializer.fromJson<bool>(json['isFileUploaded']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'conditionId': serializer.toJson<String>(conditionId),
      'timestamp': serializer.toJson<int>(timestamp),
      'severity': serializer.toJson<int>(severity),
      'isFlare': serializer.toJson<bool>(isFlare),
      'flarePhotoIds': serializer.toJson<String>(flarePhotoIds),
      'notes': serializer.toJson<String?>(notes),
      'photoPath': serializer.toJson<String?>(photoPath),
      'activityId': serializer.toJson<String?>(activityId),
      'triggers': serializer.toJson<String?>(triggers),
      'cloudStorageUrl': serializer.toJson<String?>(cloudStorageUrl),
      'fileHash': serializer.toJson<String?>(fileHash),
      'fileSizeBytes': serializer.toJson<int?>(fileSizeBytes),
      'isFileUploaded': serializer.toJson<bool>(isFileUploaded),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  ConditionLogRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    String? conditionId,
    int? timestamp,
    int? severity,
    bool? isFlare,
    String? flarePhotoIds,
    Value<String?> notes = const Value.absent(),
    Value<String?> photoPath = const Value.absent(),
    Value<String?> activityId = const Value.absent(),
    Value<String?> triggers = const Value.absent(),
    Value<String?> cloudStorageUrl = const Value.absent(),
    Value<String?> fileHash = const Value.absent(),
    Value<int?> fileSizeBytes = const Value.absent(),
    bool? isFileUploaded,
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => ConditionLogRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    conditionId: conditionId ?? this.conditionId,
    timestamp: timestamp ?? this.timestamp,
    severity: severity ?? this.severity,
    isFlare: isFlare ?? this.isFlare,
    flarePhotoIds: flarePhotoIds ?? this.flarePhotoIds,
    notes: notes.present ? notes.value : this.notes,
    photoPath: photoPath.present ? photoPath.value : this.photoPath,
    activityId: activityId.present ? activityId.value : this.activityId,
    triggers: triggers.present ? triggers.value : this.triggers,
    cloudStorageUrl: cloudStorageUrl.present
        ? cloudStorageUrl.value
        : this.cloudStorageUrl,
    fileHash: fileHash.present ? fileHash.value : this.fileHash,
    fileSizeBytes: fileSizeBytes.present
        ? fileSizeBytes.value
        : this.fileSizeBytes,
    isFileUploaded: isFileUploaded ?? this.isFileUploaded,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  ConditionLogRow copyWithCompanion(ConditionLogsCompanion data) {
    return ConditionLogRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      conditionId: data.conditionId.present
          ? data.conditionId.value
          : this.conditionId,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      severity: data.severity.present ? data.severity.value : this.severity,
      isFlare: data.isFlare.present ? data.isFlare.value : this.isFlare,
      flarePhotoIds: data.flarePhotoIds.present
          ? data.flarePhotoIds.value
          : this.flarePhotoIds,
      notes: data.notes.present ? data.notes.value : this.notes,
      photoPath: data.photoPath.present ? data.photoPath.value : this.photoPath,
      activityId: data.activityId.present
          ? data.activityId.value
          : this.activityId,
      triggers: data.triggers.present ? data.triggers.value : this.triggers,
      cloudStorageUrl: data.cloudStorageUrl.present
          ? data.cloudStorageUrl.value
          : this.cloudStorageUrl,
      fileHash: data.fileHash.present ? data.fileHash.value : this.fileHash,
      fileSizeBytes: data.fileSizeBytes.present
          ? data.fileSizeBytes.value
          : this.fileSizeBytes,
      isFileUploaded: data.isFileUploaded.present
          ? data.isFileUploaded.value
          : this.isFileUploaded,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ConditionLogRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('conditionId: $conditionId, ')
          ..write('timestamp: $timestamp, ')
          ..write('severity: $severity, ')
          ..write('isFlare: $isFlare, ')
          ..write('flarePhotoIds: $flarePhotoIds, ')
          ..write('notes: $notes, ')
          ..write('photoPath: $photoPath, ')
          ..write('activityId: $activityId, ')
          ..write('triggers: $triggers, ')
          ..write('cloudStorageUrl: $cloudStorageUrl, ')
          ..write('fileHash: $fileHash, ')
          ..write('fileSizeBytes: $fileSizeBytes, ')
          ..write('isFileUploaded: $isFileUploaded, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    clientId,
    profileId,
    conditionId,
    timestamp,
    severity,
    isFlare,
    flarePhotoIds,
    notes,
    photoPath,
    activityId,
    triggers,
    cloudStorageUrl,
    fileHash,
    fileSizeBytes,
    isFileUploaded,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ConditionLogRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.conditionId == this.conditionId &&
          other.timestamp == this.timestamp &&
          other.severity == this.severity &&
          other.isFlare == this.isFlare &&
          other.flarePhotoIds == this.flarePhotoIds &&
          other.notes == this.notes &&
          other.photoPath == this.photoPath &&
          other.activityId == this.activityId &&
          other.triggers == this.triggers &&
          other.cloudStorageUrl == this.cloudStorageUrl &&
          other.fileHash == this.fileHash &&
          other.fileSizeBytes == this.fileSizeBytes &&
          other.isFileUploaded == this.isFileUploaded &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class ConditionLogsCompanion extends UpdateCompanion<ConditionLogRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<String> conditionId;
  final Value<int> timestamp;
  final Value<int> severity;
  final Value<bool> isFlare;
  final Value<String> flarePhotoIds;
  final Value<String?> notes;
  final Value<String?> photoPath;
  final Value<String?> activityId;
  final Value<String?> triggers;
  final Value<String?> cloudStorageUrl;
  final Value<String?> fileHash;
  final Value<int?> fileSizeBytes;
  final Value<bool> isFileUploaded;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const ConditionLogsCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.conditionId = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.severity = const Value.absent(),
    this.isFlare = const Value.absent(),
    this.flarePhotoIds = const Value.absent(),
    this.notes = const Value.absent(),
    this.photoPath = const Value.absent(),
    this.activityId = const Value.absent(),
    this.triggers = const Value.absent(),
    this.cloudStorageUrl = const Value.absent(),
    this.fileHash = const Value.absent(),
    this.fileSizeBytes = const Value.absent(),
    this.isFileUploaded = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ConditionLogsCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required String conditionId,
    required int timestamp,
    required int severity,
    required bool isFlare,
    this.flarePhotoIds = const Value.absent(),
    this.notes = const Value.absent(),
    this.photoPath = const Value.absent(),
    this.activityId = const Value.absent(),
    this.triggers = const Value.absent(),
    this.cloudStorageUrl = const Value.absent(),
    this.fileHash = const Value.absent(),
    this.fileSizeBytes = const Value.absent(),
    this.isFileUploaded = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       conditionId = Value(conditionId),
       timestamp = Value(timestamp),
       severity = Value(severity),
       isFlare = Value(isFlare),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<ConditionLogRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<String>? conditionId,
    Expression<int>? timestamp,
    Expression<int>? severity,
    Expression<bool>? isFlare,
    Expression<String>? flarePhotoIds,
    Expression<String>? notes,
    Expression<String>? photoPath,
    Expression<String>? activityId,
    Expression<String>? triggers,
    Expression<String>? cloudStorageUrl,
    Expression<String>? fileHash,
    Expression<int>? fileSizeBytes,
    Expression<bool>? isFileUploaded,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (conditionId != null) 'condition_id': conditionId,
      if (timestamp != null) 'timestamp': timestamp,
      if (severity != null) 'severity': severity,
      if (isFlare != null) 'is_flare': isFlare,
      if (flarePhotoIds != null) 'flare_photo_ids': flarePhotoIds,
      if (notes != null) 'notes': notes,
      if (photoPath != null) 'photo_path': photoPath,
      if (activityId != null) 'activity_id': activityId,
      if (triggers != null) 'triggers': triggers,
      if (cloudStorageUrl != null) 'cloud_storage_url': cloudStorageUrl,
      if (fileHash != null) 'file_hash': fileHash,
      if (fileSizeBytes != null) 'file_size_bytes': fileSizeBytes,
      if (isFileUploaded != null) 'is_file_uploaded': isFileUploaded,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ConditionLogsCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<String>? conditionId,
    Value<int>? timestamp,
    Value<int>? severity,
    Value<bool>? isFlare,
    Value<String>? flarePhotoIds,
    Value<String?>? notes,
    Value<String?>? photoPath,
    Value<String?>? activityId,
    Value<String?>? triggers,
    Value<String?>? cloudStorageUrl,
    Value<String?>? fileHash,
    Value<int?>? fileSizeBytes,
    Value<bool>? isFileUploaded,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return ConditionLogsCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      conditionId: conditionId ?? this.conditionId,
      timestamp: timestamp ?? this.timestamp,
      severity: severity ?? this.severity,
      isFlare: isFlare ?? this.isFlare,
      flarePhotoIds: flarePhotoIds ?? this.flarePhotoIds,
      notes: notes ?? this.notes,
      photoPath: photoPath ?? this.photoPath,
      activityId: activityId ?? this.activityId,
      triggers: triggers ?? this.triggers,
      cloudStorageUrl: cloudStorageUrl ?? this.cloudStorageUrl,
      fileHash: fileHash ?? this.fileHash,
      fileSizeBytes: fileSizeBytes ?? this.fileSizeBytes,
      isFileUploaded: isFileUploaded ?? this.isFileUploaded,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (conditionId.present) {
      map['condition_id'] = Variable<String>(conditionId.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<int>(timestamp.value);
    }
    if (severity.present) {
      map['severity'] = Variable<int>(severity.value);
    }
    if (isFlare.present) {
      map['is_flare'] = Variable<bool>(isFlare.value);
    }
    if (flarePhotoIds.present) {
      map['flare_photo_ids'] = Variable<String>(flarePhotoIds.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (photoPath.present) {
      map['photo_path'] = Variable<String>(photoPath.value);
    }
    if (activityId.present) {
      map['activity_id'] = Variable<String>(activityId.value);
    }
    if (triggers.present) {
      map['triggers'] = Variable<String>(triggers.value);
    }
    if (cloudStorageUrl.present) {
      map['cloud_storage_url'] = Variable<String>(cloudStorageUrl.value);
    }
    if (fileHash.present) {
      map['file_hash'] = Variable<String>(fileHash.value);
    }
    if (fileSizeBytes.present) {
      map['file_size_bytes'] = Variable<int>(fileSizeBytes.value);
    }
    if (isFileUploaded.present) {
      map['is_file_uploaded'] = Variable<bool>(isFileUploaded.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ConditionLogsCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('conditionId: $conditionId, ')
          ..write('timestamp: $timestamp, ')
          ..write('severity: $severity, ')
          ..write('isFlare: $isFlare, ')
          ..write('flarePhotoIds: $flarePhotoIds, ')
          ..write('notes: $notes, ')
          ..write('photoPath: $photoPath, ')
          ..write('activityId: $activityId, ')
          ..write('triggers: $triggers, ')
          ..write('cloudStorageUrl: $cloudStorageUrl, ')
          ..write('fileHash: $fileHash, ')
          ..write('fileSizeBytes: $fileSizeBytes, ')
          ..write('isFileUploaded: $isFileUploaded, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FlareUpsTable extends FlareUps
    with TableInfo<$FlareUpsTable, FlareUpRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FlareUpsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _conditionIdMeta = const VerificationMeta(
    'conditionId',
  );
  @override
  late final GeneratedColumn<String> conditionId = GeneratedColumn<String>(
    'condition_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _startDateMeta = const VerificationMeta(
    'startDate',
  );
  @override
  late final GeneratedColumn<int> startDate = GeneratedColumn<int>(
    'start_date',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _endDateMeta = const VerificationMeta(
    'endDate',
  );
  @override
  late final GeneratedColumn<int> endDate = GeneratedColumn<int>(
    'end_date',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _severityMeta = const VerificationMeta(
    'severity',
  );
  @override
  late final GeneratedColumn<int> severity = GeneratedColumn<int>(
    'severity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _triggersMeta = const VerificationMeta(
    'triggers',
  );
  @override
  late final GeneratedColumn<String> triggers = GeneratedColumn<String>(
    'triggers',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _activityIdMeta = const VerificationMeta(
    'activityId',
  );
  @override
  late final GeneratedColumn<String> activityId = GeneratedColumn<String>(
    'activity_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _photoPathMeta = const VerificationMeta(
    'photoPath',
  );
  @override
  late final GeneratedColumn<String> photoPath = GeneratedColumn<String>(
    'photo_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    conditionId,
    startDate,
    endDate,
    severity,
    notes,
    triggers,
    activityId,
    photoPath,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'flare_ups';
  @override
  VerificationContext validateIntegrity(
    Insertable<FlareUpRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('condition_id')) {
      context.handle(
        _conditionIdMeta,
        conditionId.isAcceptableOrUnknown(
          data['condition_id']!,
          _conditionIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_conditionIdMeta);
    }
    if (data.containsKey('start_date')) {
      context.handle(
        _startDateMeta,
        startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta),
      );
    } else if (isInserting) {
      context.missing(_startDateMeta);
    }
    if (data.containsKey('end_date')) {
      context.handle(
        _endDateMeta,
        endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta),
      );
    }
    if (data.containsKey('severity')) {
      context.handle(
        _severityMeta,
        severity.isAcceptableOrUnknown(data['severity']!, _severityMeta),
      );
    } else if (isInserting) {
      context.missing(_severityMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('triggers')) {
      context.handle(
        _triggersMeta,
        triggers.isAcceptableOrUnknown(data['triggers']!, _triggersMeta),
      );
    } else if (isInserting) {
      context.missing(_triggersMeta);
    }
    if (data.containsKey('activity_id')) {
      context.handle(
        _activityIdMeta,
        activityId.isAcceptableOrUnknown(data['activity_id']!, _activityIdMeta),
      );
    }
    if (data.containsKey('photo_path')) {
      context.handle(
        _photoPathMeta,
        photoPath.isAcceptableOrUnknown(data['photo_path']!, _photoPathMeta),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FlareUpRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FlareUpRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      conditionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}condition_id'],
      )!,
      startDate: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}start_date'],
      )!,
      endDate: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_date'],
      ),
      severity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}severity'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      triggers: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}triggers'],
      )!,
      activityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}activity_id'],
      ),
      photoPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}photo_path'],
      ),
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $FlareUpsTable createAlias(String alias) {
    return $FlareUpsTable(attachedDatabase, alias);
  }
}

class FlareUpRow extends DataClass implements Insertable<FlareUpRow> {
  final String id;
  final String clientId;
  final String profileId;
  final String conditionId;
  final int startDate;
  final int? endDate;
  final int severity;
  final String? notes;
  final String triggers;
  final String? activityId;
  final String? photoPath;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const FlareUpRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.conditionId,
    required this.startDate,
    this.endDate,
    required this.severity,
    this.notes,
    required this.triggers,
    this.activityId,
    this.photoPath,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['condition_id'] = Variable<String>(conditionId);
    map['start_date'] = Variable<int>(startDate);
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<int>(endDate);
    }
    map['severity'] = Variable<int>(severity);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['triggers'] = Variable<String>(triggers);
    if (!nullToAbsent || activityId != null) {
      map['activity_id'] = Variable<String>(activityId);
    }
    if (!nullToAbsent || photoPath != null) {
      map['photo_path'] = Variable<String>(photoPath);
    }
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  FlareUpsCompanion toCompanion(bool nullToAbsent) {
    return FlareUpsCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      conditionId: Value(conditionId),
      startDate: Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      severity: Value(severity),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      triggers: Value(triggers),
      activityId: activityId == null && nullToAbsent
          ? const Value.absent()
          : Value(activityId),
      photoPath: photoPath == null && nullToAbsent
          ? const Value.absent()
          : Value(photoPath),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory FlareUpRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FlareUpRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      conditionId: serializer.fromJson<String>(json['conditionId']),
      startDate: serializer.fromJson<int>(json['startDate']),
      endDate: serializer.fromJson<int?>(json['endDate']),
      severity: serializer.fromJson<int>(json['severity']),
      notes: serializer.fromJson<String?>(json['notes']),
      triggers: serializer.fromJson<String>(json['triggers']),
      activityId: serializer.fromJson<String?>(json['activityId']),
      photoPath: serializer.fromJson<String?>(json['photoPath']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'conditionId': serializer.toJson<String>(conditionId),
      'startDate': serializer.toJson<int>(startDate),
      'endDate': serializer.toJson<int?>(endDate),
      'severity': serializer.toJson<int>(severity),
      'notes': serializer.toJson<String?>(notes),
      'triggers': serializer.toJson<String>(triggers),
      'activityId': serializer.toJson<String?>(activityId),
      'photoPath': serializer.toJson<String?>(photoPath),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  FlareUpRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    String? conditionId,
    int? startDate,
    Value<int?> endDate = const Value.absent(),
    int? severity,
    Value<String?> notes = const Value.absent(),
    String? triggers,
    Value<String?> activityId = const Value.absent(),
    Value<String?> photoPath = const Value.absent(),
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => FlareUpRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    conditionId: conditionId ?? this.conditionId,
    startDate: startDate ?? this.startDate,
    endDate: endDate.present ? endDate.value : this.endDate,
    severity: severity ?? this.severity,
    notes: notes.present ? notes.value : this.notes,
    triggers: triggers ?? this.triggers,
    activityId: activityId.present ? activityId.value : this.activityId,
    photoPath: photoPath.present ? photoPath.value : this.photoPath,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  FlareUpRow copyWithCompanion(FlareUpsCompanion data) {
    return FlareUpRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      conditionId: data.conditionId.present
          ? data.conditionId.value
          : this.conditionId,
      startDate: data.startDate.present ? data.startDate.value : this.startDate,
      endDate: data.endDate.present ? data.endDate.value : this.endDate,
      severity: data.severity.present ? data.severity.value : this.severity,
      notes: data.notes.present ? data.notes.value : this.notes,
      triggers: data.triggers.present ? data.triggers.value : this.triggers,
      activityId: data.activityId.present
          ? data.activityId.value
          : this.activityId,
      photoPath: data.photoPath.present ? data.photoPath.value : this.photoPath,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FlareUpRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('conditionId: $conditionId, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('severity: $severity, ')
          ..write('notes: $notes, ')
          ..write('triggers: $triggers, ')
          ..write('activityId: $activityId, ')
          ..write('photoPath: $photoPath, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    clientId,
    profileId,
    conditionId,
    startDate,
    endDate,
    severity,
    notes,
    triggers,
    activityId,
    photoPath,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FlareUpRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.conditionId == this.conditionId &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.severity == this.severity &&
          other.notes == this.notes &&
          other.triggers == this.triggers &&
          other.activityId == this.activityId &&
          other.photoPath == this.photoPath &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class FlareUpsCompanion extends UpdateCompanion<FlareUpRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<String> conditionId;
  final Value<int> startDate;
  final Value<int?> endDate;
  final Value<int> severity;
  final Value<String?> notes;
  final Value<String> triggers;
  final Value<String?> activityId;
  final Value<String?> photoPath;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const FlareUpsCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.conditionId = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.severity = const Value.absent(),
    this.notes = const Value.absent(),
    this.triggers = const Value.absent(),
    this.activityId = const Value.absent(),
    this.photoPath = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FlareUpsCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required String conditionId,
    required int startDate,
    this.endDate = const Value.absent(),
    required int severity,
    this.notes = const Value.absent(),
    required String triggers,
    this.activityId = const Value.absent(),
    this.photoPath = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       conditionId = Value(conditionId),
       startDate = Value(startDate),
       severity = Value(severity),
       triggers = Value(triggers),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<FlareUpRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<String>? conditionId,
    Expression<int>? startDate,
    Expression<int>? endDate,
    Expression<int>? severity,
    Expression<String>? notes,
    Expression<String>? triggers,
    Expression<String>? activityId,
    Expression<String>? photoPath,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (conditionId != null) 'condition_id': conditionId,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (severity != null) 'severity': severity,
      if (notes != null) 'notes': notes,
      if (triggers != null) 'triggers': triggers,
      if (activityId != null) 'activity_id': activityId,
      if (photoPath != null) 'photo_path': photoPath,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FlareUpsCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<String>? conditionId,
    Value<int>? startDate,
    Value<int?>? endDate,
    Value<int>? severity,
    Value<String?>? notes,
    Value<String>? triggers,
    Value<String?>? activityId,
    Value<String?>? photoPath,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return FlareUpsCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      conditionId: conditionId ?? this.conditionId,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      severity: severity ?? this.severity,
      notes: notes ?? this.notes,
      triggers: triggers ?? this.triggers,
      activityId: activityId ?? this.activityId,
      photoPath: photoPath ?? this.photoPath,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (conditionId.present) {
      map['condition_id'] = Variable<String>(conditionId.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<int>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<int>(endDate.value);
    }
    if (severity.present) {
      map['severity'] = Variable<int>(severity.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (triggers.present) {
      map['triggers'] = Variable<String>(triggers.value);
    }
    if (activityId.present) {
      map['activity_id'] = Variable<String>(activityId.value);
    }
    if (photoPath.present) {
      map['photo_path'] = Variable<String>(photoPath.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FlareUpsCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('conditionId: $conditionId, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('severity: $severity, ')
          ..write('notes: $notes, ')
          ..write('triggers: $triggers, ')
          ..write('activityId: $activityId, ')
          ..write('photoPath: $photoPath, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FluidsEntriesTable extends FluidsEntries
    with TableInfo<$FluidsEntriesTable, FluidsEntryRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FluidsEntriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entryDateMeta = const VerificationMeta(
    'entryDate',
  );
  @override
  late final GeneratedColumn<int> entryDate = GeneratedColumn<int>(
    'entry_date',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _waterIntakeMlMeta = const VerificationMeta(
    'waterIntakeMl',
  );
  @override
  late final GeneratedColumn<int> waterIntakeMl = GeneratedColumn<int>(
    'water_intake_ml',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _waterIntakeNotesMeta = const VerificationMeta(
    'waterIntakeNotes',
  );
  @override
  late final GeneratedColumn<String> waterIntakeNotes = GeneratedColumn<String>(
    'water_intake_notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _hasBowelMovementMeta = const VerificationMeta(
    'hasBowelMovement',
  );
  @override
  late final GeneratedColumn<bool> hasBowelMovement = GeneratedColumn<bool>(
    'has_bowel_movement',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("has_bowel_movement" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _bowelConditionMeta = const VerificationMeta(
    'bowelCondition',
  );
  @override
  late final GeneratedColumn<int> bowelCondition = GeneratedColumn<int>(
    'bowel_condition',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bowelCustomConditionMeta =
      const VerificationMeta('bowelCustomCondition');
  @override
  late final GeneratedColumn<String> bowelCustomCondition =
      GeneratedColumn<String>(
        'bowel_custom_condition',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _bowelSizeMeta = const VerificationMeta(
    'bowelSize',
  );
  @override
  late final GeneratedColumn<int> bowelSize = GeneratedColumn<int>(
    'bowel_size',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bowelPhotoPathMeta = const VerificationMeta(
    'bowelPhotoPath',
  );
  @override
  late final GeneratedColumn<String> bowelPhotoPath = GeneratedColumn<String>(
    'bowel_photo_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _hasUrineMovementMeta = const VerificationMeta(
    'hasUrineMovement',
  );
  @override
  late final GeneratedColumn<bool> hasUrineMovement = GeneratedColumn<bool>(
    'has_urine_movement',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("has_urine_movement" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _urineConditionMeta = const VerificationMeta(
    'urineCondition',
  );
  @override
  late final GeneratedColumn<int> urineCondition = GeneratedColumn<int>(
    'urine_condition',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _urineCustomConditionMeta =
      const VerificationMeta('urineCustomCondition');
  @override
  late final GeneratedColumn<String> urineCustomCondition =
      GeneratedColumn<String>(
        'urine_custom_condition',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _urineSizeMeta = const VerificationMeta(
    'urineSize',
  );
  @override
  late final GeneratedColumn<int> urineSize = GeneratedColumn<int>(
    'urine_size',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _urinePhotoPathMeta = const VerificationMeta(
    'urinePhotoPath',
  );
  @override
  late final GeneratedColumn<String> urinePhotoPath = GeneratedColumn<String>(
    'urine_photo_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _menstruationFlowMeta = const VerificationMeta(
    'menstruationFlow',
  );
  @override
  late final GeneratedColumn<int> menstruationFlow = GeneratedColumn<int>(
    'menstruation_flow',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _basalBodyTemperatureMeta =
      const VerificationMeta('basalBodyTemperature');
  @override
  late final GeneratedColumn<double> basalBodyTemperature =
      GeneratedColumn<double>(
        'basal_body_temperature',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _bbtRecordedTimeMeta = const VerificationMeta(
    'bbtRecordedTime',
  );
  @override
  late final GeneratedColumn<int> bbtRecordedTime = GeneratedColumn<int>(
    'bbt_recorded_time',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _otherFluidNameMeta = const VerificationMeta(
    'otherFluidName',
  );
  @override
  late final GeneratedColumn<String> otherFluidName = GeneratedColumn<String>(
    'other_fluid_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _otherFluidAmountMeta = const VerificationMeta(
    'otherFluidAmount',
  );
  @override
  late final GeneratedColumn<String> otherFluidAmount = GeneratedColumn<String>(
    'other_fluid_amount',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _otherFluidNotesMeta = const VerificationMeta(
    'otherFluidNotes',
  );
  @override
  late final GeneratedColumn<String> otherFluidNotes = GeneratedColumn<String>(
    'other_fluid_notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _importSourceMeta = const VerificationMeta(
    'importSource',
  );
  @override
  late final GeneratedColumn<String> importSource = GeneratedColumn<String>(
    'import_source',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _importExternalIdMeta = const VerificationMeta(
    'importExternalId',
  );
  @override
  late final GeneratedColumn<String> importExternalId = GeneratedColumn<String>(
    'import_external_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cloudStorageUrlMeta = const VerificationMeta(
    'cloudStorageUrl',
  );
  @override
  late final GeneratedColumn<String> cloudStorageUrl = GeneratedColumn<String>(
    'cloud_storage_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fileHashMeta = const VerificationMeta(
    'fileHash',
  );
  @override
  late final GeneratedColumn<String> fileHash = GeneratedColumn<String>(
    'file_hash',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fileSizeBytesMeta = const VerificationMeta(
    'fileSizeBytes',
  );
  @override
  late final GeneratedColumn<int> fileSizeBytes = GeneratedColumn<int>(
    'file_size_bytes',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isFileUploadedMeta = const VerificationMeta(
    'isFileUploaded',
  );
  @override
  late final GeneratedColumn<bool> isFileUploaded = GeneratedColumn<bool>(
    'is_file_uploaded',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_file_uploaded" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant(''),
  );
  static const VerificationMeta _photoIdsMeta = const VerificationMeta(
    'photoIds',
  );
  @override
  late final GeneratedColumn<String> photoIds = GeneratedColumn<String>(
    'photo_ids',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('[]'),
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    entryDate,
    waterIntakeMl,
    waterIntakeNotes,
    hasBowelMovement,
    bowelCondition,
    bowelCustomCondition,
    bowelSize,
    bowelPhotoPath,
    hasUrineMovement,
    urineCondition,
    urineCustomCondition,
    urineSize,
    urinePhotoPath,
    menstruationFlow,
    basalBodyTemperature,
    bbtRecordedTime,
    otherFluidName,
    otherFluidAmount,
    otherFluidNotes,
    importSource,
    importExternalId,
    cloudStorageUrl,
    fileHash,
    fileSizeBytes,
    isFileUploaded,
    notes,
    photoIds,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'fluids_entries';
  @override
  VerificationContext validateIntegrity(
    Insertable<FluidsEntryRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('entry_date')) {
      context.handle(
        _entryDateMeta,
        entryDate.isAcceptableOrUnknown(data['entry_date']!, _entryDateMeta),
      );
    } else if (isInserting) {
      context.missing(_entryDateMeta);
    }
    if (data.containsKey('water_intake_ml')) {
      context.handle(
        _waterIntakeMlMeta,
        waterIntakeMl.isAcceptableOrUnknown(
          data['water_intake_ml']!,
          _waterIntakeMlMeta,
        ),
      );
    }
    if (data.containsKey('water_intake_notes')) {
      context.handle(
        _waterIntakeNotesMeta,
        waterIntakeNotes.isAcceptableOrUnknown(
          data['water_intake_notes']!,
          _waterIntakeNotesMeta,
        ),
      );
    }
    if (data.containsKey('has_bowel_movement')) {
      context.handle(
        _hasBowelMovementMeta,
        hasBowelMovement.isAcceptableOrUnknown(
          data['has_bowel_movement']!,
          _hasBowelMovementMeta,
        ),
      );
    }
    if (data.containsKey('bowel_condition')) {
      context.handle(
        _bowelConditionMeta,
        bowelCondition.isAcceptableOrUnknown(
          data['bowel_condition']!,
          _bowelConditionMeta,
        ),
      );
    }
    if (data.containsKey('bowel_custom_condition')) {
      context.handle(
        _bowelCustomConditionMeta,
        bowelCustomCondition.isAcceptableOrUnknown(
          data['bowel_custom_condition']!,
          _bowelCustomConditionMeta,
        ),
      );
    }
    if (data.containsKey('bowel_size')) {
      context.handle(
        _bowelSizeMeta,
        bowelSize.isAcceptableOrUnknown(data['bowel_size']!, _bowelSizeMeta),
      );
    }
    if (data.containsKey('bowel_photo_path')) {
      context.handle(
        _bowelPhotoPathMeta,
        bowelPhotoPath.isAcceptableOrUnknown(
          data['bowel_photo_path']!,
          _bowelPhotoPathMeta,
        ),
      );
    }
    if (data.containsKey('has_urine_movement')) {
      context.handle(
        _hasUrineMovementMeta,
        hasUrineMovement.isAcceptableOrUnknown(
          data['has_urine_movement']!,
          _hasUrineMovementMeta,
        ),
      );
    }
    if (data.containsKey('urine_condition')) {
      context.handle(
        _urineConditionMeta,
        urineCondition.isAcceptableOrUnknown(
          data['urine_condition']!,
          _urineConditionMeta,
        ),
      );
    }
    if (data.containsKey('urine_custom_condition')) {
      context.handle(
        _urineCustomConditionMeta,
        urineCustomCondition.isAcceptableOrUnknown(
          data['urine_custom_condition']!,
          _urineCustomConditionMeta,
        ),
      );
    }
    if (data.containsKey('urine_size')) {
      context.handle(
        _urineSizeMeta,
        urineSize.isAcceptableOrUnknown(data['urine_size']!, _urineSizeMeta),
      );
    }
    if (data.containsKey('urine_photo_path')) {
      context.handle(
        _urinePhotoPathMeta,
        urinePhotoPath.isAcceptableOrUnknown(
          data['urine_photo_path']!,
          _urinePhotoPathMeta,
        ),
      );
    }
    if (data.containsKey('menstruation_flow')) {
      context.handle(
        _menstruationFlowMeta,
        menstruationFlow.isAcceptableOrUnknown(
          data['menstruation_flow']!,
          _menstruationFlowMeta,
        ),
      );
    }
    if (data.containsKey('basal_body_temperature')) {
      context.handle(
        _basalBodyTemperatureMeta,
        basalBodyTemperature.isAcceptableOrUnknown(
          data['basal_body_temperature']!,
          _basalBodyTemperatureMeta,
        ),
      );
    }
    if (data.containsKey('bbt_recorded_time')) {
      context.handle(
        _bbtRecordedTimeMeta,
        bbtRecordedTime.isAcceptableOrUnknown(
          data['bbt_recorded_time']!,
          _bbtRecordedTimeMeta,
        ),
      );
    }
    if (data.containsKey('other_fluid_name')) {
      context.handle(
        _otherFluidNameMeta,
        otherFluidName.isAcceptableOrUnknown(
          data['other_fluid_name']!,
          _otherFluidNameMeta,
        ),
      );
    }
    if (data.containsKey('other_fluid_amount')) {
      context.handle(
        _otherFluidAmountMeta,
        otherFluidAmount.isAcceptableOrUnknown(
          data['other_fluid_amount']!,
          _otherFluidAmountMeta,
        ),
      );
    }
    if (data.containsKey('other_fluid_notes')) {
      context.handle(
        _otherFluidNotesMeta,
        otherFluidNotes.isAcceptableOrUnknown(
          data['other_fluid_notes']!,
          _otherFluidNotesMeta,
        ),
      );
    }
    if (data.containsKey('import_source')) {
      context.handle(
        _importSourceMeta,
        importSource.isAcceptableOrUnknown(
          data['import_source']!,
          _importSourceMeta,
        ),
      );
    }
    if (data.containsKey('import_external_id')) {
      context.handle(
        _importExternalIdMeta,
        importExternalId.isAcceptableOrUnknown(
          data['import_external_id']!,
          _importExternalIdMeta,
        ),
      );
    }
    if (data.containsKey('cloud_storage_url')) {
      context.handle(
        _cloudStorageUrlMeta,
        cloudStorageUrl.isAcceptableOrUnknown(
          data['cloud_storage_url']!,
          _cloudStorageUrlMeta,
        ),
      );
    }
    if (data.containsKey('file_hash')) {
      context.handle(
        _fileHashMeta,
        fileHash.isAcceptableOrUnknown(data['file_hash']!, _fileHashMeta),
      );
    }
    if (data.containsKey('file_size_bytes')) {
      context.handle(
        _fileSizeBytesMeta,
        fileSizeBytes.isAcceptableOrUnknown(
          data['file_size_bytes']!,
          _fileSizeBytesMeta,
        ),
      );
    }
    if (data.containsKey('is_file_uploaded')) {
      context.handle(
        _isFileUploadedMeta,
        isFileUploaded.isAcceptableOrUnknown(
          data['is_file_uploaded']!,
          _isFileUploadedMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('photo_ids')) {
      context.handle(
        _photoIdsMeta,
        photoIds.isAcceptableOrUnknown(data['photo_ids']!, _photoIdsMeta),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FluidsEntryRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FluidsEntryRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      entryDate: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}entry_date'],
      )!,
      waterIntakeMl: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}water_intake_ml'],
      ),
      waterIntakeNotes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}water_intake_notes'],
      ),
      hasBowelMovement: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}has_bowel_movement'],
      )!,
      bowelCondition: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}bowel_condition'],
      ),
      bowelCustomCondition: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bowel_custom_condition'],
      ),
      bowelSize: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}bowel_size'],
      ),
      bowelPhotoPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bowel_photo_path'],
      ),
      hasUrineMovement: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}has_urine_movement'],
      )!,
      urineCondition: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}urine_condition'],
      ),
      urineCustomCondition: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}urine_custom_condition'],
      ),
      urineSize: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}urine_size'],
      ),
      urinePhotoPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}urine_photo_path'],
      ),
      menstruationFlow: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}menstruation_flow'],
      ),
      basalBodyTemperature: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}basal_body_temperature'],
      ),
      bbtRecordedTime: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}bbt_recorded_time'],
      ),
      otherFluidName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}other_fluid_name'],
      ),
      otherFluidAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}other_fluid_amount'],
      ),
      otherFluidNotes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}other_fluid_notes'],
      ),
      importSource: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}import_source'],
      ),
      importExternalId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}import_external_id'],
      ),
      cloudStorageUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cloud_storage_url'],
      ),
      fileHash: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}file_hash'],
      ),
      fileSizeBytes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}file_size_bytes'],
      ),
      isFileUploaded: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_file_uploaded'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      )!,
      photoIds: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}photo_ids'],
      )!,
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $FluidsEntriesTable createAlias(String alias) {
    return $FluidsEntriesTable(attachedDatabase, alias);
  }
}

class FluidsEntryRow extends DataClass implements Insertable<FluidsEntryRow> {
  final String id;
  final String clientId;
  final String profileId;
  final int entryDate;
  final int? waterIntakeMl;
  final String? waterIntakeNotes;
  final bool hasBowelMovement;
  final int? bowelCondition;
  final String? bowelCustomCondition;
  final int? bowelSize;
  final String? bowelPhotoPath;
  final bool hasUrineMovement;
  final int? urineCondition;
  final String? urineCustomCondition;
  final int? urineSize;
  final String? urinePhotoPath;
  final int? menstruationFlow;
  final double? basalBodyTemperature;
  final int? bbtRecordedTime;
  final String? otherFluidName;
  final String? otherFluidAmount;
  final String? otherFluidNotes;
  final String? importSource;
  final String? importExternalId;
  final String? cloudStorageUrl;
  final String? fileHash;
  final int? fileSizeBytes;
  final bool isFileUploaded;
  final String notes;
  final String photoIds;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const FluidsEntryRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.entryDate,
    this.waterIntakeMl,
    this.waterIntakeNotes,
    required this.hasBowelMovement,
    this.bowelCondition,
    this.bowelCustomCondition,
    this.bowelSize,
    this.bowelPhotoPath,
    required this.hasUrineMovement,
    this.urineCondition,
    this.urineCustomCondition,
    this.urineSize,
    this.urinePhotoPath,
    this.menstruationFlow,
    this.basalBodyTemperature,
    this.bbtRecordedTime,
    this.otherFluidName,
    this.otherFluidAmount,
    this.otherFluidNotes,
    this.importSource,
    this.importExternalId,
    this.cloudStorageUrl,
    this.fileHash,
    this.fileSizeBytes,
    required this.isFileUploaded,
    required this.notes,
    required this.photoIds,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['entry_date'] = Variable<int>(entryDate);
    if (!nullToAbsent || waterIntakeMl != null) {
      map['water_intake_ml'] = Variable<int>(waterIntakeMl);
    }
    if (!nullToAbsent || waterIntakeNotes != null) {
      map['water_intake_notes'] = Variable<String>(waterIntakeNotes);
    }
    map['has_bowel_movement'] = Variable<bool>(hasBowelMovement);
    if (!nullToAbsent || bowelCondition != null) {
      map['bowel_condition'] = Variable<int>(bowelCondition);
    }
    if (!nullToAbsent || bowelCustomCondition != null) {
      map['bowel_custom_condition'] = Variable<String>(bowelCustomCondition);
    }
    if (!nullToAbsent || bowelSize != null) {
      map['bowel_size'] = Variable<int>(bowelSize);
    }
    if (!nullToAbsent || bowelPhotoPath != null) {
      map['bowel_photo_path'] = Variable<String>(bowelPhotoPath);
    }
    map['has_urine_movement'] = Variable<bool>(hasUrineMovement);
    if (!nullToAbsent || urineCondition != null) {
      map['urine_condition'] = Variable<int>(urineCondition);
    }
    if (!nullToAbsent || urineCustomCondition != null) {
      map['urine_custom_condition'] = Variable<String>(urineCustomCondition);
    }
    if (!nullToAbsent || urineSize != null) {
      map['urine_size'] = Variable<int>(urineSize);
    }
    if (!nullToAbsent || urinePhotoPath != null) {
      map['urine_photo_path'] = Variable<String>(urinePhotoPath);
    }
    if (!nullToAbsent || menstruationFlow != null) {
      map['menstruation_flow'] = Variable<int>(menstruationFlow);
    }
    if (!nullToAbsent || basalBodyTemperature != null) {
      map['basal_body_temperature'] = Variable<double>(basalBodyTemperature);
    }
    if (!nullToAbsent || bbtRecordedTime != null) {
      map['bbt_recorded_time'] = Variable<int>(bbtRecordedTime);
    }
    if (!nullToAbsent || otherFluidName != null) {
      map['other_fluid_name'] = Variable<String>(otherFluidName);
    }
    if (!nullToAbsent || otherFluidAmount != null) {
      map['other_fluid_amount'] = Variable<String>(otherFluidAmount);
    }
    if (!nullToAbsent || otherFluidNotes != null) {
      map['other_fluid_notes'] = Variable<String>(otherFluidNotes);
    }
    if (!nullToAbsent || importSource != null) {
      map['import_source'] = Variable<String>(importSource);
    }
    if (!nullToAbsent || importExternalId != null) {
      map['import_external_id'] = Variable<String>(importExternalId);
    }
    if (!nullToAbsent || cloudStorageUrl != null) {
      map['cloud_storage_url'] = Variable<String>(cloudStorageUrl);
    }
    if (!nullToAbsent || fileHash != null) {
      map['file_hash'] = Variable<String>(fileHash);
    }
    if (!nullToAbsent || fileSizeBytes != null) {
      map['file_size_bytes'] = Variable<int>(fileSizeBytes);
    }
    map['is_file_uploaded'] = Variable<bool>(isFileUploaded);
    map['notes'] = Variable<String>(notes);
    map['photo_ids'] = Variable<String>(photoIds);
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  FluidsEntriesCompanion toCompanion(bool nullToAbsent) {
    return FluidsEntriesCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      entryDate: Value(entryDate),
      waterIntakeMl: waterIntakeMl == null && nullToAbsent
          ? const Value.absent()
          : Value(waterIntakeMl),
      waterIntakeNotes: waterIntakeNotes == null && nullToAbsent
          ? const Value.absent()
          : Value(waterIntakeNotes),
      hasBowelMovement: Value(hasBowelMovement),
      bowelCondition: bowelCondition == null && nullToAbsent
          ? const Value.absent()
          : Value(bowelCondition),
      bowelCustomCondition: bowelCustomCondition == null && nullToAbsent
          ? const Value.absent()
          : Value(bowelCustomCondition),
      bowelSize: bowelSize == null && nullToAbsent
          ? const Value.absent()
          : Value(bowelSize),
      bowelPhotoPath: bowelPhotoPath == null && nullToAbsent
          ? const Value.absent()
          : Value(bowelPhotoPath),
      hasUrineMovement: Value(hasUrineMovement),
      urineCondition: urineCondition == null && nullToAbsent
          ? const Value.absent()
          : Value(urineCondition),
      urineCustomCondition: urineCustomCondition == null && nullToAbsent
          ? const Value.absent()
          : Value(urineCustomCondition),
      urineSize: urineSize == null && nullToAbsent
          ? const Value.absent()
          : Value(urineSize),
      urinePhotoPath: urinePhotoPath == null && nullToAbsent
          ? const Value.absent()
          : Value(urinePhotoPath),
      menstruationFlow: menstruationFlow == null && nullToAbsent
          ? const Value.absent()
          : Value(menstruationFlow),
      basalBodyTemperature: basalBodyTemperature == null && nullToAbsent
          ? const Value.absent()
          : Value(basalBodyTemperature),
      bbtRecordedTime: bbtRecordedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(bbtRecordedTime),
      otherFluidName: otherFluidName == null && nullToAbsent
          ? const Value.absent()
          : Value(otherFluidName),
      otherFluidAmount: otherFluidAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(otherFluidAmount),
      otherFluidNotes: otherFluidNotes == null && nullToAbsent
          ? const Value.absent()
          : Value(otherFluidNotes),
      importSource: importSource == null && nullToAbsent
          ? const Value.absent()
          : Value(importSource),
      importExternalId: importExternalId == null && nullToAbsent
          ? const Value.absent()
          : Value(importExternalId),
      cloudStorageUrl: cloudStorageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(cloudStorageUrl),
      fileHash: fileHash == null && nullToAbsent
          ? const Value.absent()
          : Value(fileHash),
      fileSizeBytes: fileSizeBytes == null && nullToAbsent
          ? const Value.absent()
          : Value(fileSizeBytes),
      isFileUploaded: Value(isFileUploaded),
      notes: Value(notes),
      photoIds: Value(photoIds),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory FluidsEntryRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FluidsEntryRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      entryDate: serializer.fromJson<int>(json['entryDate']),
      waterIntakeMl: serializer.fromJson<int?>(json['waterIntakeMl']),
      waterIntakeNotes: serializer.fromJson<String?>(json['waterIntakeNotes']),
      hasBowelMovement: serializer.fromJson<bool>(json['hasBowelMovement']),
      bowelCondition: serializer.fromJson<int?>(json['bowelCondition']),
      bowelCustomCondition: serializer.fromJson<String?>(
        json['bowelCustomCondition'],
      ),
      bowelSize: serializer.fromJson<int?>(json['bowelSize']),
      bowelPhotoPath: serializer.fromJson<String?>(json['bowelPhotoPath']),
      hasUrineMovement: serializer.fromJson<bool>(json['hasUrineMovement']),
      urineCondition: serializer.fromJson<int?>(json['urineCondition']),
      urineCustomCondition: serializer.fromJson<String?>(
        json['urineCustomCondition'],
      ),
      urineSize: serializer.fromJson<int?>(json['urineSize']),
      urinePhotoPath: serializer.fromJson<String?>(json['urinePhotoPath']),
      menstruationFlow: serializer.fromJson<int?>(json['menstruationFlow']),
      basalBodyTemperature: serializer.fromJson<double?>(
        json['basalBodyTemperature'],
      ),
      bbtRecordedTime: serializer.fromJson<int?>(json['bbtRecordedTime']),
      otherFluidName: serializer.fromJson<String?>(json['otherFluidName']),
      otherFluidAmount: serializer.fromJson<String?>(json['otherFluidAmount']),
      otherFluidNotes: serializer.fromJson<String?>(json['otherFluidNotes']),
      importSource: serializer.fromJson<String?>(json['importSource']),
      importExternalId: serializer.fromJson<String?>(json['importExternalId']),
      cloudStorageUrl: serializer.fromJson<String?>(json['cloudStorageUrl']),
      fileHash: serializer.fromJson<String?>(json['fileHash']),
      fileSizeBytes: serializer.fromJson<int?>(json['fileSizeBytes']),
      isFileUploaded: serializer.fromJson<bool>(json['isFileUploaded']),
      notes: serializer.fromJson<String>(json['notes']),
      photoIds: serializer.fromJson<String>(json['photoIds']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'entryDate': serializer.toJson<int>(entryDate),
      'waterIntakeMl': serializer.toJson<int?>(waterIntakeMl),
      'waterIntakeNotes': serializer.toJson<String?>(waterIntakeNotes),
      'hasBowelMovement': serializer.toJson<bool>(hasBowelMovement),
      'bowelCondition': serializer.toJson<int?>(bowelCondition),
      'bowelCustomCondition': serializer.toJson<String?>(bowelCustomCondition),
      'bowelSize': serializer.toJson<int?>(bowelSize),
      'bowelPhotoPath': serializer.toJson<String?>(bowelPhotoPath),
      'hasUrineMovement': serializer.toJson<bool>(hasUrineMovement),
      'urineCondition': serializer.toJson<int?>(urineCondition),
      'urineCustomCondition': serializer.toJson<String?>(urineCustomCondition),
      'urineSize': serializer.toJson<int?>(urineSize),
      'urinePhotoPath': serializer.toJson<String?>(urinePhotoPath),
      'menstruationFlow': serializer.toJson<int?>(menstruationFlow),
      'basalBodyTemperature': serializer.toJson<double?>(basalBodyTemperature),
      'bbtRecordedTime': serializer.toJson<int?>(bbtRecordedTime),
      'otherFluidName': serializer.toJson<String?>(otherFluidName),
      'otherFluidAmount': serializer.toJson<String?>(otherFluidAmount),
      'otherFluidNotes': serializer.toJson<String?>(otherFluidNotes),
      'importSource': serializer.toJson<String?>(importSource),
      'importExternalId': serializer.toJson<String?>(importExternalId),
      'cloudStorageUrl': serializer.toJson<String?>(cloudStorageUrl),
      'fileHash': serializer.toJson<String?>(fileHash),
      'fileSizeBytes': serializer.toJson<int?>(fileSizeBytes),
      'isFileUploaded': serializer.toJson<bool>(isFileUploaded),
      'notes': serializer.toJson<String>(notes),
      'photoIds': serializer.toJson<String>(photoIds),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  FluidsEntryRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    int? entryDate,
    Value<int?> waterIntakeMl = const Value.absent(),
    Value<String?> waterIntakeNotes = const Value.absent(),
    bool? hasBowelMovement,
    Value<int?> bowelCondition = const Value.absent(),
    Value<String?> bowelCustomCondition = const Value.absent(),
    Value<int?> bowelSize = const Value.absent(),
    Value<String?> bowelPhotoPath = const Value.absent(),
    bool? hasUrineMovement,
    Value<int?> urineCondition = const Value.absent(),
    Value<String?> urineCustomCondition = const Value.absent(),
    Value<int?> urineSize = const Value.absent(),
    Value<String?> urinePhotoPath = const Value.absent(),
    Value<int?> menstruationFlow = const Value.absent(),
    Value<double?> basalBodyTemperature = const Value.absent(),
    Value<int?> bbtRecordedTime = const Value.absent(),
    Value<String?> otherFluidName = const Value.absent(),
    Value<String?> otherFluidAmount = const Value.absent(),
    Value<String?> otherFluidNotes = const Value.absent(),
    Value<String?> importSource = const Value.absent(),
    Value<String?> importExternalId = const Value.absent(),
    Value<String?> cloudStorageUrl = const Value.absent(),
    Value<String?> fileHash = const Value.absent(),
    Value<int?> fileSizeBytes = const Value.absent(),
    bool? isFileUploaded,
    String? notes,
    String? photoIds,
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => FluidsEntryRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    entryDate: entryDate ?? this.entryDate,
    waterIntakeMl: waterIntakeMl.present
        ? waterIntakeMl.value
        : this.waterIntakeMl,
    waterIntakeNotes: waterIntakeNotes.present
        ? waterIntakeNotes.value
        : this.waterIntakeNotes,
    hasBowelMovement: hasBowelMovement ?? this.hasBowelMovement,
    bowelCondition: bowelCondition.present
        ? bowelCondition.value
        : this.bowelCondition,
    bowelCustomCondition: bowelCustomCondition.present
        ? bowelCustomCondition.value
        : this.bowelCustomCondition,
    bowelSize: bowelSize.present ? bowelSize.value : this.bowelSize,
    bowelPhotoPath: bowelPhotoPath.present
        ? bowelPhotoPath.value
        : this.bowelPhotoPath,
    hasUrineMovement: hasUrineMovement ?? this.hasUrineMovement,
    urineCondition: urineCondition.present
        ? urineCondition.value
        : this.urineCondition,
    urineCustomCondition: urineCustomCondition.present
        ? urineCustomCondition.value
        : this.urineCustomCondition,
    urineSize: urineSize.present ? urineSize.value : this.urineSize,
    urinePhotoPath: urinePhotoPath.present
        ? urinePhotoPath.value
        : this.urinePhotoPath,
    menstruationFlow: menstruationFlow.present
        ? menstruationFlow.value
        : this.menstruationFlow,
    basalBodyTemperature: basalBodyTemperature.present
        ? basalBodyTemperature.value
        : this.basalBodyTemperature,
    bbtRecordedTime: bbtRecordedTime.present
        ? bbtRecordedTime.value
        : this.bbtRecordedTime,
    otherFluidName: otherFluidName.present
        ? otherFluidName.value
        : this.otherFluidName,
    otherFluidAmount: otherFluidAmount.present
        ? otherFluidAmount.value
        : this.otherFluidAmount,
    otherFluidNotes: otherFluidNotes.present
        ? otherFluidNotes.value
        : this.otherFluidNotes,
    importSource: importSource.present ? importSource.value : this.importSource,
    importExternalId: importExternalId.present
        ? importExternalId.value
        : this.importExternalId,
    cloudStorageUrl: cloudStorageUrl.present
        ? cloudStorageUrl.value
        : this.cloudStorageUrl,
    fileHash: fileHash.present ? fileHash.value : this.fileHash,
    fileSizeBytes: fileSizeBytes.present
        ? fileSizeBytes.value
        : this.fileSizeBytes,
    isFileUploaded: isFileUploaded ?? this.isFileUploaded,
    notes: notes ?? this.notes,
    photoIds: photoIds ?? this.photoIds,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  FluidsEntryRow copyWithCompanion(FluidsEntriesCompanion data) {
    return FluidsEntryRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      entryDate: data.entryDate.present ? data.entryDate.value : this.entryDate,
      waterIntakeMl: data.waterIntakeMl.present
          ? data.waterIntakeMl.value
          : this.waterIntakeMl,
      waterIntakeNotes: data.waterIntakeNotes.present
          ? data.waterIntakeNotes.value
          : this.waterIntakeNotes,
      hasBowelMovement: data.hasBowelMovement.present
          ? data.hasBowelMovement.value
          : this.hasBowelMovement,
      bowelCondition: data.bowelCondition.present
          ? data.bowelCondition.value
          : this.bowelCondition,
      bowelCustomCondition: data.bowelCustomCondition.present
          ? data.bowelCustomCondition.value
          : this.bowelCustomCondition,
      bowelSize: data.bowelSize.present ? data.bowelSize.value : this.bowelSize,
      bowelPhotoPath: data.bowelPhotoPath.present
          ? data.bowelPhotoPath.value
          : this.bowelPhotoPath,
      hasUrineMovement: data.hasUrineMovement.present
          ? data.hasUrineMovement.value
          : this.hasUrineMovement,
      urineCondition: data.urineCondition.present
          ? data.urineCondition.value
          : this.urineCondition,
      urineCustomCondition: data.urineCustomCondition.present
          ? data.urineCustomCondition.value
          : this.urineCustomCondition,
      urineSize: data.urineSize.present ? data.urineSize.value : this.urineSize,
      urinePhotoPath: data.urinePhotoPath.present
          ? data.urinePhotoPath.value
          : this.urinePhotoPath,
      menstruationFlow: data.menstruationFlow.present
          ? data.menstruationFlow.value
          : this.menstruationFlow,
      basalBodyTemperature: data.basalBodyTemperature.present
          ? data.basalBodyTemperature.value
          : this.basalBodyTemperature,
      bbtRecordedTime: data.bbtRecordedTime.present
          ? data.bbtRecordedTime.value
          : this.bbtRecordedTime,
      otherFluidName: data.otherFluidName.present
          ? data.otherFluidName.value
          : this.otherFluidName,
      otherFluidAmount: data.otherFluidAmount.present
          ? data.otherFluidAmount.value
          : this.otherFluidAmount,
      otherFluidNotes: data.otherFluidNotes.present
          ? data.otherFluidNotes.value
          : this.otherFluidNotes,
      importSource: data.importSource.present
          ? data.importSource.value
          : this.importSource,
      importExternalId: data.importExternalId.present
          ? data.importExternalId.value
          : this.importExternalId,
      cloudStorageUrl: data.cloudStorageUrl.present
          ? data.cloudStorageUrl.value
          : this.cloudStorageUrl,
      fileHash: data.fileHash.present ? data.fileHash.value : this.fileHash,
      fileSizeBytes: data.fileSizeBytes.present
          ? data.fileSizeBytes.value
          : this.fileSizeBytes,
      isFileUploaded: data.isFileUploaded.present
          ? data.isFileUploaded.value
          : this.isFileUploaded,
      notes: data.notes.present ? data.notes.value : this.notes,
      photoIds: data.photoIds.present ? data.photoIds.value : this.photoIds,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FluidsEntryRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('entryDate: $entryDate, ')
          ..write('waterIntakeMl: $waterIntakeMl, ')
          ..write('waterIntakeNotes: $waterIntakeNotes, ')
          ..write('hasBowelMovement: $hasBowelMovement, ')
          ..write('bowelCondition: $bowelCondition, ')
          ..write('bowelCustomCondition: $bowelCustomCondition, ')
          ..write('bowelSize: $bowelSize, ')
          ..write('bowelPhotoPath: $bowelPhotoPath, ')
          ..write('hasUrineMovement: $hasUrineMovement, ')
          ..write('urineCondition: $urineCondition, ')
          ..write('urineCustomCondition: $urineCustomCondition, ')
          ..write('urineSize: $urineSize, ')
          ..write('urinePhotoPath: $urinePhotoPath, ')
          ..write('menstruationFlow: $menstruationFlow, ')
          ..write('basalBodyTemperature: $basalBodyTemperature, ')
          ..write('bbtRecordedTime: $bbtRecordedTime, ')
          ..write('otherFluidName: $otherFluidName, ')
          ..write('otherFluidAmount: $otherFluidAmount, ')
          ..write('otherFluidNotes: $otherFluidNotes, ')
          ..write('importSource: $importSource, ')
          ..write('importExternalId: $importExternalId, ')
          ..write('cloudStorageUrl: $cloudStorageUrl, ')
          ..write('fileHash: $fileHash, ')
          ..write('fileSizeBytes: $fileSizeBytes, ')
          ..write('isFileUploaded: $isFileUploaded, ')
          ..write('notes: $notes, ')
          ..write('photoIds: $photoIds, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    clientId,
    profileId,
    entryDate,
    waterIntakeMl,
    waterIntakeNotes,
    hasBowelMovement,
    bowelCondition,
    bowelCustomCondition,
    bowelSize,
    bowelPhotoPath,
    hasUrineMovement,
    urineCondition,
    urineCustomCondition,
    urineSize,
    urinePhotoPath,
    menstruationFlow,
    basalBodyTemperature,
    bbtRecordedTime,
    otherFluidName,
    otherFluidAmount,
    otherFluidNotes,
    importSource,
    importExternalId,
    cloudStorageUrl,
    fileHash,
    fileSizeBytes,
    isFileUploaded,
    notes,
    photoIds,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FluidsEntryRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.entryDate == this.entryDate &&
          other.waterIntakeMl == this.waterIntakeMl &&
          other.waterIntakeNotes == this.waterIntakeNotes &&
          other.hasBowelMovement == this.hasBowelMovement &&
          other.bowelCondition == this.bowelCondition &&
          other.bowelCustomCondition == this.bowelCustomCondition &&
          other.bowelSize == this.bowelSize &&
          other.bowelPhotoPath == this.bowelPhotoPath &&
          other.hasUrineMovement == this.hasUrineMovement &&
          other.urineCondition == this.urineCondition &&
          other.urineCustomCondition == this.urineCustomCondition &&
          other.urineSize == this.urineSize &&
          other.urinePhotoPath == this.urinePhotoPath &&
          other.menstruationFlow == this.menstruationFlow &&
          other.basalBodyTemperature == this.basalBodyTemperature &&
          other.bbtRecordedTime == this.bbtRecordedTime &&
          other.otherFluidName == this.otherFluidName &&
          other.otherFluidAmount == this.otherFluidAmount &&
          other.otherFluidNotes == this.otherFluidNotes &&
          other.importSource == this.importSource &&
          other.importExternalId == this.importExternalId &&
          other.cloudStorageUrl == this.cloudStorageUrl &&
          other.fileHash == this.fileHash &&
          other.fileSizeBytes == this.fileSizeBytes &&
          other.isFileUploaded == this.isFileUploaded &&
          other.notes == this.notes &&
          other.photoIds == this.photoIds &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class FluidsEntriesCompanion extends UpdateCompanion<FluidsEntryRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<int> entryDate;
  final Value<int?> waterIntakeMl;
  final Value<String?> waterIntakeNotes;
  final Value<bool> hasBowelMovement;
  final Value<int?> bowelCondition;
  final Value<String?> bowelCustomCondition;
  final Value<int?> bowelSize;
  final Value<String?> bowelPhotoPath;
  final Value<bool> hasUrineMovement;
  final Value<int?> urineCondition;
  final Value<String?> urineCustomCondition;
  final Value<int?> urineSize;
  final Value<String?> urinePhotoPath;
  final Value<int?> menstruationFlow;
  final Value<double?> basalBodyTemperature;
  final Value<int?> bbtRecordedTime;
  final Value<String?> otherFluidName;
  final Value<String?> otherFluidAmount;
  final Value<String?> otherFluidNotes;
  final Value<String?> importSource;
  final Value<String?> importExternalId;
  final Value<String?> cloudStorageUrl;
  final Value<String?> fileHash;
  final Value<int?> fileSizeBytes;
  final Value<bool> isFileUploaded;
  final Value<String> notes;
  final Value<String> photoIds;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const FluidsEntriesCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.entryDate = const Value.absent(),
    this.waterIntakeMl = const Value.absent(),
    this.waterIntakeNotes = const Value.absent(),
    this.hasBowelMovement = const Value.absent(),
    this.bowelCondition = const Value.absent(),
    this.bowelCustomCondition = const Value.absent(),
    this.bowelSize = const Value.absent(),
    this.bowelPhotoPath = const Value.absent(),
    this.hasUrineMovement = const Value.absent(),
    this.urineCondition = const Value.absent(),
    this.urineCustomCondition = const Value.absent(),
    this.urineSize = const Value.absent(),
    this.urinePhotoPath = const Value.absent(),
    this.menstruationFlow = const Value.absent(),
    this.basalBodyTemperature = const Value.absent(),
    this.bbtRecordedTime = const Value.absent(),
    this.otherFluidName = const Value.absent(),
    this.otherFluidAmount = const Value.absent(),
    this.otherFluidNotes = const Value.absent(),
    this.importSource = const Value.absent(),
    this.importExternalId = const Value.absent(),
    this.cloudStorageUrl = const Value.absent(),
    this.fileHash = const Value.absent(),
    this.fileSizeBytes = const Value.absent(),
    this.isFileUploaded = const Value.absent(),
    this.notes = const Value.absent(),
    this.photoIds = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FluidsEntriesCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required int entryDate,
    this.waterIntakeMl = const Value.absent(),
    this.waterIntakeNotes = const Value.absent(),
    this.hasBowelMovement = const Value.absent(),
    this.bowelCondition = const Value.absent(),
    this.bowelCustomCondition = const Value.absent(),
    this.bowelSize = const Value.absent(),
    this.bowelPhotoPath = const Value.absent(),
    this.hasUrineMovement = const Value.absent(),
    this.urineCondition = const Value.absent(),
    this.urineCustomCondition = const Value.absent(),
    this.urineSize = const Value.absent(),
    this.urinePhotoPath = const Value.absent(),
    this.menstruationFlow = const Value.absent(),
    this.basalBodyTemperature = const Value.absent(),
    this.bbtRecordedTime = const Value.absent(),
    this.otherFluidName = const Value.absent(),
    this.otherFluidAmount = const Value.absent(),
    this.otherFluidNotes = const Value.absent(),
    this.importSource = const Value.absent(),
    this.importExternalId = const Value.absent(),
    this.cloudStorageUrl = const Value.absent(),
    this.fileHash = const Value.absent(),
    this.fileSizeBytes = const Value.absent(),
    this.isFileUploaded = const Value.absent(),
    this.notes = const Value.absent(),
    this.photoIds = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       entryDate = Value(entryDate),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<FluidsEntryRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<int>? entryDate,
    Expression<int>? waterIntakeMl,
    Expression<String>? waterIntakeNotes,
    Expression<bool>? hasBowelMovement,
    Expression<int>? bowelCondition,
    Expression<String>? bowelCustomCondition,
    Expression<int>? bowelSize,
    Expression<String>? bowelPhotoPath,
    Expression<bool>? hasUrineMovement,
    Expression<int>? urineCondition,
    Expression<String>? urineCustomCondition,
    Expression<int>? urineSize,
    Expression<String>? urinePhotoPath,
    Expression<int>? menstruationFlow,
    Expression<double>? basalBodyTemperature,
    Expression<int>? bbtRecordedTime,
    Expression<String>? otherFluidName,
    Expression<String>? otherFluidAmount,
    Expression<String>? otherFluidNotes,
    Expression<String>? importSource,
    Expression<String>? importExternalId,
    Expression<String>? cloudStorageUrl,
    Expression<String>? fileHash,
    Expression<int>? fileSizeBytes,
    Expression<bool>? isFileUploaded,
    Expression<String>? notes,
    Expression<String>? photoIds,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (entryDate != null) 'entry_date': entryDate,
      if (waterIntakeMl != null) 'water_intake_ml': waterIntakeMl,
      if (waterIntakeNotes != null) 'water_intake_notes': waterIntakeNotes,
      if (hasBowelMovement != null) 'has_bowel_movement': hasBowelMovement,
      if (bowelCondition != null) 'bowel_condition': bowelCondition,
      if (bowelCustomCondition != null)
        'bowel_custom_condition': bowelCustomCondition,
      if (bowelSize != null) 'bowel_size': bowelSize,
      if (bowelPhotoPath != null) 'bowel_photo_path': bowelPhotoPath,
      if (hasUrineMovement != null) 'has_urine_movement': hasUrineMovement,
      if (urineCondition != null) 'urine_condition': urineCondition,
      if (urineCustomCondition != null)
        'urine_custom_condition': urineCustomCondition,
      if (urineSize != null) 'urine_size': urineSize,
      if (urinePhotoPath != null) 'urine_photo_path': urinePhotoPath,
      if (menstruationFlow != null) 'menstruation_flow': menstruationFlow,
      if (basalBodyTemperature != null)
        'basal_body_temperature': basalBodyTemperature,
      if (bbtRecordedTime != null) 'bbt_recorded_time': bbtRecordedTime,
      if (otherFluidName != null) 'other_fluid_name': otherFluidName,
      if (otherFluidAmount != null) 'other_fluid_amount': otherFluidAmount,
      if (otherFluidNotes != null) 'other_fluid_notes': otherFluidNotes,
      if (importSource != null) 'import_source': importSource,
      if (importExternalId != null) 'import_external_id': importExternalId,
      if (cloudStorageUrl != null) 'cloud_storage_url': cloudStorageUrl,
      if (fileHash != null) 'file_hash': fileHash,
      if (fileSizeBytes != null) 'file_size_bytes': fileSizeBytes,
      if (isFileUploaded != null) 'is_file_uploaded': isFileUploaded,
      if (notes != null) 'notes': notes,
      if (photoIds != null) 'photo_ids': photoIds,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FluidsEntriesCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<int>? entryDate,
    Value<int?>? waterIntakeMl,
    Value<String?>? waterIntakeNotes,
    Value<bool>? hasBowelMovement,
    Value<int?>? bowelCondition,
    Value<String?>? bowelCustomCondition,
    Value<int?>? bowelSize,
    Value<String?>? bowelPhotoPath,
    Value<bool>? hasUrineMovement,
    Value<int?>? urineCondition,
    Value<String?>? urineCustomCondition,
    Value<int?>? urineSize,
    Value<String?>? urinePhotoPath,
    Value<int?>? menstruationFlow,
    Value<double?>? basalBodyTemperature,
    Value<int?>? bbtRecordedTime,
    Value<String?>? otherFluidName,
    Value<String?>? otherFluidAmount,
    Value<String?>? otherFluidNotes,
    Value<String?>? importSource,
    Value<String?>? importExternalId,
    Value<String?>? cloudStorageUrl,
    Value<String?>? fileHash,
    Value<int?>? fileSizeBytes,
    Value<bool>? isFileUploaded,
    Value<String>? notes,
    Value<String>? photoIds,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return FluidsEntriesCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      entryDate: entryDate ?? this.entryDate,
      waterIntakeMl: waterIntakeMl ?? this.waterIntakeMl,
      waterIntakeNotes: waterIntakeNotes ?? this.waterIntakeNotes,
      hasBowelMovement: hasBowelMovement ?? this.hasBowelMovement,
      bowelCondition: bowelCondition ?? this.bowelCondition,
      bowelCustomCondition: bowelCustomCondition ?? this.bowelCustomCondition,
      bowelSize: bowelSize ?? this.bowelSize,
      bowelPhotoPath: bowelPhotoPath ?? this.bowelPhotoPath,
      hasUrineMovement: hasUrineMovement ?? this.hasUrineMovement,
      urineCondition: urineCondition ?? this.urineCondition,
      urineCustomCondition: urineCustomCondition ?? this.urineCustomCondition,
      urineSize: urineSize ?? this.urineSize,
      urinePhotoPath: urinePhotoPath ?? this.urinePhotoPath,
      menstruationFlow: menstruationFlow ?? this.menstruationFlow,
      basalBodyTemperature: basalBodyTemperature ?? this.basalBodyTemperature,
      bbtRecordedTime: bbtRecordedTime ?? this.bbtRecordedTime,
      otherFluidName: otherFluidName ?? this.otherFluidName,
      otherFluidAmount: otherFluidAmount ?? this.otherFluidAmount,
      otherFluidNotes: otherFluidNotes ?? this.otherFluidNotes,
      importSource: importSource ?? this.importSource,
      importExternalId: importExternalId ?? this.importExternalId,
      cloudStorageUrl: cloudStorageUrl ?? this.cloudStorageUrl,
      fileHash: fileHash ?? this.fileHash,
      fileSizeBytes: fileSizeBytes ?? this.fileSizeBytes,
      isFileUploaded: isFileUploaded ?? this.isFileUploaded,
      notes: notes ?? this.notes,
      photoIds: photoIds ?? this.photoIds,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (entryDate.present) {
      map['entry_date'] = Variable<int>(entryDate.value);
    }
    if (waterIntakeMl.present) {
      map['water_intake_ml'] = Variable<int>(waterIntakeMl.value);
    }
    if (waterIntakeNotes.present) {
      map['water_intake_notes'] = Variable<String>(waterIntakeNotes.value);
    }
    if (hasBowelMovement.present) {
      map['has_bowel_movement'] = Variable<bool>(hasBowelMovement.value);
    }
    if (bowelCondition.present) {
      map['bowel_condition'] = Variable<int>(bowelCondition.value);
    }
    if (bowelCustomCondition.present) {
      map['bowel_custom_condition'] = Variable<String>(
        bowelCustomCondition.value,
      );
    }
    if (bowelSize.present) {
      map['bowel_size'] = Variable<int>(bowelSize.value);
    }
    if (bowelPhotoPath.present) {
      map['bowel_photo_path'] = Variable<String>(bowelPhotoPath.value);
    }
    if (hasUrineMovement.present) {
      map['has_urine_movement'] = Variable<bool>(hasUrineMovement.value);
    }
    if (urineCondition.present) {
      map['urine_condition'] = Variable<int>(urineCondition.value);
    }
    if (urineCustomCondition.present) {
      map['urine_custom_condition'] = Variable<String>(
        urineCustomCondition.value,
      );
    }
    if (urineSize.present) {
      map['urine_size'] = Variable<int>(urineSize.value);
    }
    if (urinePhotoPath.present) {
      map['urine_photo_path'] = Variable<String>(urinePhotoPath.value);
    }
    if (menstruationFlow.present) {
      map['menstruation_flow'] = Variable<int>(menstruationFlow.value);
    }
    if (basalBodyTemperature.present) {
      map['basal_body_temperature'] = Variable<double>(
        basalBodyTemperature.value,
      );
    }
    if (bbtRecordedTime.present) {
      map['bbt_recorded_time'] = Variable<int>(bbtRecordedTime.value);
    }
    if (otherFluidName.present) {
      map['other_fluid_name'] = Variable<String>(otherFluidName.value);
    }
    if (otherFluidAmount.present) {
      map['other_fluid_amount'] = Variable<String>(otherFluidAmount.value);
    }
    if (otherFluidNotes.present) {
      map['other_fluid_notes'] = Variable<String>(otherFluidNotes.value);
    }
    if (importSource.present) {
      map['import_source'] = Variable<String>(importSource.value);
    }
    if (importExternalId.present) {
      map['import_external_id'] = Variable<String>(importExternalId.value);
    }
    if (cloudStorageUrl.present) {
      map['cloud_storage_url'] = Variable<String>(cloudStorageUrl.value);
    }
    if (fileHash.present) {
      map['file_hash'] = Variable<String>(fileHash.value);
    }
    if (fileSizeBytes.present) {
      map['file_size_bytes'] = Variable<int>(fileSizeBytes.value);
    }
    if (isFileUploaded.present) {
      map['is_file_uploaded'] = Variable<bool>(isFileUploaded.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (photoIds.present) {
      map['photo_ids'] = Variable<String>(photoIds.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FluidsEntriesCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('entryDate: $entryDate, ')
          ..write('waterIntakeMl: $waterIntakeMl, ')
          ..write('waterIntakeNotes: $waterIntakeNotes, ')
          ..write('hasBowelMovement: $hasBowelMovement, ')
          ..write('bowelCondition: $bowelCondition, ')
          ..write('bowelCustomCondition: $bowelCustomCondition, ')
          ..write('bowelSize: $bowelSize, ')
          ..write('bowelPhotoPath: $bowelPhotoPath, ')
          ..write('hasUrineMovement: $hasUrineMovement, ')
          ..write('urineCondition: $urineCondition, ')
          ..write('urineCustomCondition: $urineCustomCondition, ')
          ..write('urineSize: $urineSize, ')
          ..write('urinePhotoPath: $urinePhotoPath, ')
          ..write('menstruationFlow: $menstruationFlow, ')
          ..write('basalBodyTemperature: $basalBodyTemperature, ')
          ..write('bbtRecordedTime: $bbtRecordedTime, ')
          ..write('otherFluidName: $otherFluidName, ')
          ..write('otherFluidAmount: $otherFluidAmount, ')
          ..write('otherFluidNotes: $otherFluidNotes, ')
          ..write('importSource: $importSource, ')
          ..write('importExternalId: $importExternalId, ')
          ..write('cloudStorageUrl: $cloudStorageUrl, ')
          ..write('fileHash: $fileHash, ')
          ..write('fileSizeBytes: $fileSizeBytes, ')
          ..write('isFileUploaded: $isFileUploaded, ')
          ..write('notes: $notes, ')
          ..write('photoIds: $photoIds, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SleepEntriesTable extends SleepEntries
    with TableInfo<$SleepEntriesTable, SleepEntryRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SleepEntriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bedTimeMeta = const VerificationMeta(
    'bedTime',
  );
  @override
  late final GeneratedColumn<int> bedTime = GeneratedColumn<int>(
    'bed_time',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _wakeTimeMeta = const VerificationMeta(
    'wakeTime',
  );
  @override
  late final GeneratedColumn<int> wakeTime = GeneratedColumn<int>(
    'wake_time',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _deepSleepMinutesMeta = const VerificationMeta(
    'deepSleepMinutes',
  );
  @override
  late final GeneratedColumn<int> deepSleepMinutes = GeneratedColumn<int>(
    'deep_sleep_minutes',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _lightSleepMinutesMeta = const VerificationMeta(
    'lightSleepMinutes',
  );
  @override
  late final GeneratedColumn<int> lightSleepMinutes = GeneratedColumn<int>(
    'light_sleep_minutes',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _restlessSleepMinutesMeta =
      const VerificationMeta('restlessSleepMinutes');
  @override
  late final GeneratedColumn<int> restlessSleepMinutes = GeneratedColumn<int>(
    'restless_sleep_minutes',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _dreamTypeMeta = const VerificationMeta(
    'dreamType',
  );
  @override
  late final GeneratedColumn<int> dreamType = GeneratedColumn<int>(
    'dream_type',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _wakingFeelingMeta = const VerificationMeta(
    'wakingFeeling',
  );
  @override
  late final GeneratedColumn<int> wakingFeeling = GeneratedColumn<int>(
    'waking_feeling',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _importSourceMeta = const VerificationMeta(
    'importSource',
  );
  @override
  late final GeneratedColumn<String> importSource = GeneratedColumn<String>(
    'import_source',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _importExternalIdMeta = const VerificationMeta(
    'importExternalId',
  );
  @override
  late final GeneratedColumn<String> importExternalId = GeneratedColumn<String>(
    'import_external_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    bedTime,
    wakeTime,
    deepSleepMinutes,
    lightSleepMinutes,
    restlessSleepMinutes,
    dreamType,
    wakingFeeling,
    notes,
    importSource,
    importExternalId,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sleep_entries';
  @override
  VerificationContext validateIntegrity(
    Insertable<SleepEntryRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('bed_time')) {
      context.handle(
        _bedTimeMeta,
        bedTime.isAcceptableOrUnknown(data['bed_time']!, _bedTimeMeta),
      );
    } else if (isInserting) {
      context.missing(_bedTimeMeta);
    }
    if (data.containsKey('wake_time')) {
      context.handle(
        _wakeTimeMeta,
        wakeTime.isAcceptableOrUnknown(data['wake_time']!, _wakeTimeMeta),
      );
    }
    if (data.containsKey('deep_sleep_minutes')) {
      context.handle(
        _deepSleepMinutesMeta,
        deepSleepMinutes.isAcceptableOrUnknown(
          data['deep_sleep_minutes']!,
          _deepSleepMinutesMeta,
        ),
      );
    }
    if (data.containsKey('light_sleep_minutes')) {
      context.handle(
        _lightSleepMinutesMeta,
        lightSleepMinutes.isAcceptableOrUnknown(
          data['light_sleep_minutes']!,
          _lightSleepMinutesMeta,
        ),
      );
    }
    if (data.containsKey('restless_sleep_minutes')) {
      context.handle(
        _restlessSleepMinutesMeta,
        restlessSleepMinutes.isAcceptableOrUnknown(
          data['restless_sleep_minutes']!,
          _restlessSleepMinutesMeta,
        ),
      );
    }
    if (data.containsKey('dream_type')) {
      context.handle(
        _dreamTypeMeta,
        dreamType.isAcceptableOrUnknown(data['dream_type']!, _dreamTypeMeta),
      );
    }
    if (data.containsKey('waking_feeling')) {
      context.handle(
        _wakingFeelingMeta,
        wakingFeeling.isAcceptableOrUnknown(
          data['waking_feeling']!,
          _wakingFeelingMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('import_source')) {
      context.handle(
        _importSourceMeta,
        importSource.isAcceptableOrUnknown(
          data['import_source']!,
          _importSourceMeta,
        ),
      );
    }
    if (data.containsKey('import_external_id')) {
      context.handle(
        _importExternalIdMeta,
        importExternalId.isAcceptableOrUnknown(
          data['import_external_id']!,
          _importExternalIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SleepEntryRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SleepEntryRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      bedTime: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}bed_time'],
      )!,
      wakeTime: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}wake_time'],
      ),
      deepSleepMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}deep_sleep_minutes'],
      )!,
      lightSleepMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}light_sleep_minutes'],
      )!,
      restlessSleepMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}restless_sleep_minutes'],
      )!,
      dreamType: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}dream_type'],
      )!,
      wakingFeeling: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}waking_feeling'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      importSource: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}import_source'],
      ),
      importExternalId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}import_external_id'],
      ),
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $SleepEntriesTable createAlias(String alias) {
    return $SleepEntriesTable(attachedDatabase, alias);
  }
}

class SleepEntryRow extends DataClass implements Insertable<SleepEntryRow> {
  final String id;
  final String clientId;
  final String profileId;
  final int bedTime;
  final int? wakeTime;
  final int deepSleepMinutes;
  final int lightSleepMinutes;
  final int restlessSleepMinutes;
  final int dreamType;
  final int wakingFeeling;
  final String? notes;
  final String? importSource;
  final String? importExternalId;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const SleepEntryRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.bedTime,
    this.wakeTime,
    required this.deepSleepMinutes,
    required this.lightSleepMinutes,
    required this.restlessSleepMinutes,
    required this.dreamType,
    required this.wakingFeeling,
    this.notes,
    this.importSource,
    this.importExternalId,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['bed_time'] = Variable<int>(bedTime);
    if (!nullToAbsent || wakeTime != null) {
      map['wake_time'] = Variable<int>(wakeTime);
    }
    map['deep_sleep_minutes'] = Variable<int>(deepSleepMinutes);
    map['light_sleep_minutes'] = Variable<int>(lightSleepMinutes);
    map['restless_sleep_minutes'] = Variable<int>(restlessSleepMinutes);
    map['dream_type'] = Variable<int>(dreamType);
    map['waking_feeling'] = Variable<int>(wakingFeeling);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    if (!nullToAbsent || importSource != null) {
      map['import_source'] = Variable<String>(importSource);
    }
    if (!nullToAbsent || importExternalId != null) {
      map['import_external_id'] = Variable<String>(importExternalId);
    }
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  SleepEntriesCompanion toCompanion(bool nullToAbsent) {
    return SleepEntriesCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      bedTime: Value(bedTime),
      wakeTime: wakeTime == null && nullToAbsent
          ? const Value.absent()
          : Value(wakeTime),
      deepSleepMinutes: Value(deepSleepMinutes),
      lightSleepMinutes: Value(lightSleepMinutes),
      restlessSleepMinutes: Value(restlessSleepMinutes),
      dreamType: Value(dreamType),
      wakingFeeling: Value(wakingFeeling),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      importSource: importSource == null && nullToAbsent
          ? const Value.absent()
          : Value(importSource),
      importExternalId: importExternalId == null && nullToAbsent
          ? const Value.absent()
          : Value(importExternalId),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory SleepEntryRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SleepEntryRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      bedTime: serializer.fromJson<int>(json['bedTime']),
      wakeTime: serializer.fromJson<int?>(json['wakeTime']),
      deepSleepMinutes: serializer.fromJson<int>(json['deepSleepMinutes']),
      lightSleepMinutes: serializer.fromJson<int>(json['lightSleepMinutes']),
      restlessSleepMinutes: serializer.fromJson<int>(
        json['restlessSleepMinutes'],
      ),
      dreamType: serializer.fromJson<int>(json['dreamType']),
      wakingFeeling: serializer.fromJson<int>(json['wakingFeeling']),
      notes: serializer.fromJson<String?>(json['notes']),
      importSource: serializer.fromJson<String?>(json['importSource']),
      importExternalId: serializer.fromJson<String?>(json['importExternalId']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'bedTime': serializer.toJson<int>(bedTime),
      'wakeTime': serializer.toJson<int?>(wakeTime),
      'deepSleepMinutes': serializer.toJson<int>(deepSleepMinutes),
      'lightSleepMinutes': serializer.toJson<int>(lightSleepMinutes),
      'restlessSleepMinutes': serializer.toJson<int>(restlessSleepMinutes),
      'dreamType': serializer.toJson<int>(dreamType),
      'wakingFeeling': serializer.toJson<int>(wakingFeeling),
      'notes': serializer.toJson<String?>(notes),
      'importSource': serializer.toJson<String?>(importSource),
      'importExternalId': serializer.toJson<String?>(importExternalId),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  SleepEntryRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    int? bedTime,
    Value<int?> wakeTime = const Value.absent(),
    int? deepSleepMinutes,
    int? lightSleepMinutes,
    int? restlessSleepMinutes,
    int? dreamType,
    int? wakingFeeling,
    Value<String?> notes = const Value.absent(),
    Value<String?> importSource = const Value.absent(),
    Value<String?> importExternalId = const Value.absent(),
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => SleepEntryRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    bedTime: bedTime ?? this.bedTime,
    wakeTime: wakeTime.present ? wakeTime.value : this.wakeTime,
    deepSleepMinutes: deepSleepMinutes ?? this.deepSleepMinutes,
    lightSleepMinutes: lightSleepMinutes ?? this.lightSleepMinutes,
    restlessSleepMinutes: restlessSleepMinutes ?? this.restlessSleepMinutes,
    dreamType: dreamType ?? this.dreamType,
    wakingFeeling: wakingFeeling ?? this.wakingFeeling,
    notes: notes.present ? notes.value : this.notes,
    importSource: importSource.present ? importSource.value : this.importSource,
    importExternalId: importExternalId.present
        ? importExternalId.value
        : this.importExternalId,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  SleepEntryRow copyWithCompanion(SleepEntriesCompanion data) {
    return SleepEntryRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      bedTime: data.bedTime.present ? data.bedTime.value : this.bedTime,
      wakeTime: data.wakeTime.present ? data.wakeTime.value : this.wakeTime,
      deepSleepMinutes: data.deepSleepMinutes.present
          ? data.deepSleepMinutes.value
          : this.deepSleepMinutes,
      lightSleepMinutes: data.lightSleepMinutes.present
          ? data.lightSleepMinutes.value
          : this.lightSleepMinutes,
      restlessSleepMinutes: data.restlessSleepMinutes.present
          ? data.restlessSleepMinutes.value
          : this.restlessSleepMinutes,
      dreamType: data.dreamType.present ? data.dreamType.value : this.dreamType,
      wakingFeeling: data.wakingFeeling.present
          ? data.wakingFeeling.value
          : this.wakingFeeling,
      notes: data.notes.present ? data.notes.value : this.notes,
      importSource: data.importSource.present
          ? data.importSource.value
          : this.importSource,
      importExternalId: data.importExternalId.present
          ? data.importExternalId.value
          : this.importExternalId,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SleepEntryRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('bedTime: $bedTime, ')
          ..write('wakeTime: $wakeTime, ')
          ..write('deepSleepMinutes: $deepSleepMinutes, ')
          ..write('lightSleepMinutes: $lightSleepMinutes, ')
          ..write('restlessSleepMinutes: $restlessSleepMinutes, ')
          ..write('dreamType: $dreamType, ')
          ..write('wakingFeeling: $wakingFeeling, ')
          ..write('notes: $notes, ')
          ..write('importSource: $importSource, ')
          ..write('importExternalId: $importExternalId, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    clientId,
    profileId,
    bedTime,
    wakeTime,
    deepSleepMinutes,
    lightSleepMinutes,
    restlessSleepMinutes,
    dreamType,
    wakingFeeling,
    notes,
    importSource,
    importExternalId,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SleepEntryRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.bedTime == this.bedTime &&
          other.wakeTime == this.wakeTime &&
          other.deepSleepMinutes == this.deepSleepMinutes &&
          other.lightSleepMinutes == this.lightSleepMinutes &&
          other.restlessSleepMinutes == this.restlessSleepMinutes &&
          other.dreamType == this.dreamType &&
          other.wakingFeeling == this.wakingFeeling &&
          other.notes == this.notes &&
          other.importSource == this.importSource &&
          other.importExternalId == this.importExternalId &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class SleepEntriesCompanion extends UpdateCompanion<SleepEntryRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<int> bedTime;
  final Value<int?> wakeTime;
  final Value<int> deepSleepMinutes;
  final Value<int> lightSleepMinutes;
  final Value<int> restlessSleepMinutes;
  final Value<int> dreamType;
  final Value<int> wakingFeeling;
  final Value<String?> notes;
  final Value<String?> importSource;
  final Value<String?> importExternalId;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const SleepEntriesCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.bedTime = const Value.absent(),
    this.wakeTime = const Value.absent(),
    this.deepSleepMinutes = const Value.absent(),
    this.lightSleepMinutes = const Value.absent(),
    this.restlessSleepMinutes = const Value.absent(),
    this.dreamType = const Value.absent(),
    this.wakingFeeling = const Value.absent(),
    this.notes = const Value.absent(),
    this.importSource = const Value.absent(),
    this.importExternalId = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SleepEntriesCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required int bedTime,
    this.wakeTime = const Value.absent(),
    this.deepSleepMinutes = const Value.absent(),
    this.lightSleepMinutes = const Value.absent(),
    this.restlessSleepMinutes = const Value.absent(),
    this.dreamType = const Value.absent(),
    this.wakingFeeling = const Value.absent(),
    this.notes = const Value.absent(),
    this.importSource = const Value.absent(),
    this.importExternalId = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       bedTime = Value(bedTime),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<SleepEntryRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<int>? bedTime,
    Expression<int>? wakeTime,
    Expression<int>? deepSleepMinutes,
    Expression<int>? lightSleepMinutes,
    Expression<int>? restlessSleepMinutes,
    Expression<int>? dreamType,
    Expression<int>? wakingFeeling,
    Expression<String>? notes,
    Expression<String>? importSource,
    Expression<String>? importExternalId,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (bedTime != null) 'bed_time': bedTime,
      if (wakeTime != null) 'wake_time': wakeTime,
      if (deepSleepMinutes != null) 'deep_sleep_minutes': deepSleepMinutes,
      if (lightSleepMinutes != null) 'light_sleep_minutes': lightSleepMinutes,
      if (restlessSleepMinutes != null)
        'restless_sleep_minutes': restlessSleepMinutes,
      if (dreamType != null) 'dream_type': dreamType,
      if (wakingFeeling != null) 'waking_feeling': wakingFeeling,
      if (notes != null) 'notes': notes,
      if (importSource != null) 'import_source': importSource,
      if (importExternalId != null) 'import_external_id': importExternalId,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SleepEntriesCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<int>? bedTime,
    Value<int?>? wakeTime,
    Value<int>? deepSleepMinutes,
    Value<int>? lightSleepMinutes,
    Value<int>? restlessSleepMinutes,
    Value<int>? dreamType,
    Value<int>? wakingFeeling,
    Value<String?>? notes,
    Value<String?>? importSource,
    Value<String?>? importExternalId,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return SleepEntriesCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      bedTime: bedTime ?? this.bedTime,
      wakeTime: wakeTime ?? this.wakeTime,
      deepSleepMinutes: deepSleepMinutes ?? this.deepSleepMinutes,
      lightSleepMinutes: lightSleepMinutes ?? this.lightSleepMinutes,
      restlessSleepMinutes: restlessSleepMinutes ?? this.restlessSleepMinutes,
      dreamType: dreamType ?? this.dreamType,
      wakingFeeling: wakingFeeling ?? this.wakingFeeling,
      notes: notes ?? this.notes,
      importSource: importSource ?? this.importSource,
      importExternalId: importExternalId ?? this.importExternalId,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (bedTime.present) {
      map['bed_time'] = Variable<int>(bedTime.value);
    }
    if (wakeTime.present) {
      map['wake_time'] = Variable<int>(wakeTime.value);
    }
    if (deepSleepMinutes.present) {
      map['deep_sleep_minutes'] = Variable<int>(deepSleepMinutes.value);
    }
    if (lightSleepMinutes.present) {
      map['light_sleep_minutes'] = Variable<int>(lightSleepMinutes.value);
    }
    if (restlessSleepMinutes.present) {
      map['restless_sleep_minutes'] = Variable<int>(restlessSleepMinutes.value);
    }
    if (dreamType.present) {
      map['dream_type'] = Variable<int>(dreamType.value);
    }
    if (wakingFeeling.present) {
      map['waking_feeling'] = Variable<int>(wakingFeeling.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (importSource.present) {
      map['import_source'] = Variable<String>(importSource.value);
    }
    if (importExternalId.present) {
      map['import_external_id'] = Variable<String>(importExternalId.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SleepEntriesCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('bedTime: $bedTime, ')
          ..write('wakeTime: $wakeTime, ')
          ..write('deepSleepMinutes: $deepSleepMinutes, ')
          ..write('lightSleepMinutes: $lightSleepMinutes, ')
          ..write('restlessSleepMinutes: $restlessSleepMinutes, ')
          ..write('dreamType: $dreamType, ')
          ..write('wakingFeeling: $wakingFeeling, ')
          ..write('notes: $notes, ')
          ..write('importSource: $importSource, ')
          ..write('importExternalId: $importExternalId, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ActivitiesTable extends Activities
    with TableInfo<$ActivitiesTable, ActivityRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActivitiesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _locationMeta = const VerificationMeta(
    'location',
  );
  @override
  late final GeneratedColumn<String> location = GeneratedColumn<String>(
    'location',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _triggersMeta = const VerificationMeta(
    'triggers',
  );
  @override
  late final GeneratedColumn<String> triggers = GeneratedColumn<String>(
    'triggers',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _durationMinutesMeta = const VerificationMeta(
    'durationMinutes',
  );
  @override
  late final GeneratedColumn<int> durationMinutes = GeneratedColumn<int>(
    'duration_minutes',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isArchivedMeta = const VerificationMeta(
    'isArchived',
  );
  @override
  late final GeneratedColumn<bool> isArchived = GeneratedColumn<bool>(
    'is_archived',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_archived" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    name,
    description,
    location,
    triggers,
    durationMinutes,
    isArchived,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'activities';
  @override
  VerificationContext validateIntegrity(
    Insertable<ActivityRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('location')) {
      context.handle(
        _locationMeta,
        location.isAcceptableOrUnknown(data['location']!, _locationMeta),
      );
    }
    if (data.containsKey('triggers')) {
      context.handle(
        _triggersMeta,
        triggers.isAcceptableOrUnknown(data['triggers']!, _triggersMeta),
      );
    }
    if (data.containsKey('duration_minutes')) {
      context.handle(
        _durationMinutesMeta,
        durationMinutes.isAcceptableOrUnknown(
          data['duration_minutes']!,
          _durationMinutesMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_durationMinutesMeta);
    }
    if (data.containsKey('is_archived')) {
      context.handle(
        _isArchivedMeta,
        isArchived.isAcceptableOrUnknown(data['is_archived']!, _isArchivedMeta),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ActivityRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ActivityRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      location: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location'],
      ),
      triggers: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}triggers'],
      ),
      durationMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}duration_minutes'],
      )!,
      isArchived: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_archived'],
      )!,
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $ActivitiesTable createAlias(String alias) {
    return $ActivitiesTable(attachedDatabase, alias);
  }
}

class ActivityRow extends DataClass implements Insertable<ActivityRow> {
  final String id;
  final String clientId;
  final String profileId;
  final String name;
  final String? description;
  final String? location;
  final String? triggers;
  final int durationMinutes;
  final bool isArchived;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const ActivityRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.name,
    this.description,
    this.location,
    this.triggers,
    required this.durationMinutes,
    required this.isArchived,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || location != null) {
      map['location'] = Variable<String>(location);
    }
    if (!nullToAbsent || triggers != null) {
      map['triggers'] = Variable<String>(triggers);
    }
    map['duration_minutes'] = Variable<int>(durationMinutes);
    map['is_archived'] = Variable<bool>(isArchived);
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  ActivitiesCompanion toCompanion(bool nullToAbsent) {
    return ActivitiesCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      location: location == null && nullToAbsent
          ? const Value.absent()
          : Value(location),
      triggers: triggers == null && nullToAbsent
          ? const Value.absent()
          : Value(triggers),
      durationMinutes: Value(durationMinutes),
      isArchived: Value(isArchived),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory ActivityRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ActivityRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      location: serializer.fromJson<String?>(json['location']),
      triggers: serializer.fromJson<String?>(json['triggers']),
      durationMinutes: serializer.fromJson<int>(json['durationMinutes']),
      isArchived: serializer.fromJson<bool>(json['isArchived']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'location': serializer.toJson<String?>(location),
      'triggers': serializer.toJson<String?>(triggers),
      'durationMinutes': serializer.toJson<int>(durationMinutes),
      'isArchived': serializer.toJson<bool>(isArchived),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  ActivityRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    String? name,
    Value<String?> description = const Value.absent(),
    Value<String?> location = const Value.absent(),
    Value<String?> triggers = const Value.absent(),
    int? durationMinutes,
    bool? isArchived,
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => ActivityRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    location: location.present ? location.value : this.location,
    triggers: triggers.present ? triggers.value : this.triggers,
    durationMinutes: durationMinutes ?? this.durationMinutes,
    isArchived: isArchived ?? this.isArchived,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  ActivityRow copyWithCompanion(ActivitiesCompanion data) {
    return ActivityRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      location: data.location.present ? data.location.value : this.location,
      triggers: data.triggers.present ? data.triggers.value : this.triggers,
      durationMinutes: data.durationMinutes.present
          ? data.durationMinutes.value
          : this.durationMinutes,
      isArchived: data.isArchived.present
          ? data.isArchived.value
          : this.isArchived,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ActivityRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('location: $location, ')
          ..write('triggers: $triggers, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('isArchived: $isArchived, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    clientId,
    profileId,
    name,
    description,
    location,
    triggers,
    durationMinutes,
    isArchived,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ActivityRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.name == this.name &&
          other.description == this.description &&
          other.location == this.location &&
          other.triggers == this.triggers &&
          other.durationMinutes == this.durationMinutes &&
          other.isArchived == this.isArchived &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class ActivitiesCompanion extends UpdateCompanion<ActivityRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<String> name;
  final Value<String?> description;
  final Value<String?> location;
  final Value<String?> triggers;
  final Value<int> durationMinutes;
  final Value<bool> isArchived;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const ActivitiesCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.location = const Value.absent(),
    this.triggers = const Value.absent(),
    this.durationMinutes = const Value.absent(),
    this.isArchived = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActivitiesCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required String name,
    this.description = const Value.absent(),
    this.location = const Value.absent(),
    this.triggers = const Value.absent(),
    required int durationMinutes,
    this.isArchived = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       name = Value(name),
       durationMinutes = Value(durationMinutes),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<ActivityRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<String>? name,
    Expression<String>? description,
    Expression<String>? location,
    Expression<String>? triggers,
    Expression<int>? durationMinutes,
    Expression<bool>? isArchived,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (location != null) 'location': location,
      if (triggers != null) 'triggers': triggers,
      if (durationMinutes != null) 'duration_minutes': durationMinutes,
      if (isArchived != null) 'is_archived': isArchived,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActivitiesCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<String>? name,
    Value<String?>? description,
    Value<String?>? location,
    Value<String?>? triggers,
    Value<int>? durationMinutes,
    Value<bool>? isArchived,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return ActivitiesCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      name: name ?? this.name,
      description: description ?? this.description,
      location: location ?? this.location,
      triggers: triggers ?? this.triggers,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      isArchived: isArchived ?? this.isArchived,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (location.present) {
      map['location'] = Variable<String>(location.value);
    }
    if (triggers.present) {
      map['triggers'] = Variable<String>(triggers.value);
    }
    if (durationMinutes.present) {
      map['duration_minutes'] = Variable<int>(durationMinutes.value);
    }
    if (isArchived.present) {
      map['is_archived'] = Variable<bool>(isArchived.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActivitiesCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('location: $location, ')
          ..write('triggers: $triggers, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('isArchived: $isArchived, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ActivityLogsTable extends ActivityLogs
    with TableInfo<$ActivityLogsTable, ActivityLogRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActivityLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<int> timestamp = GeneratedColumn<int>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _activityIdsMeta = const VerificationMeta(
    'activityIds',
  );
  @override
  late final GeneratedColumn<String> activityIds = GeneratedColumn<String>(
    'activity_ids',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _adHocActivitiesMeta = const VerificationMeta(
    'adHocActivities',
  );
  @override
  late final GeneratedColumn<String> adHocActivities = GeneratedColumn<String>(
    'ad_hoc_activities',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _durationMeta = const VerificationMeta(
    'duration',
  );
  @override
  late final GeneratedColumn<int> duration = GeneratedColumn<int>(
    'duration',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _importSourceMeta = const VerificationMeta(
    'importSource',
  );
  @override
  late final GeneratedColumn<String> importSource = GeneratedColumn<String>(
    'import_source',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _importExternalIdMeta = const VerificationMeta(
    'importExternalId',
  );
  @override
  late final GeneratedColumn<String> importExternalId = GeneratedColumn<String>(
    'import_external_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    timestamp,
    activityIds,
    adHocActivities,
    duration,
    notes,
    importSource,
    importExternalId,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'activity_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<ActivityLogRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('activity_ids')) {
      context.handle(
        _activityIdsMeta,
        activityIds.isAcceptableOrUnknown(
          data['activity_ids']!,
          _activityIdsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_activityIdsMeta);
    }
    if (data.containsKey('ad_hoc_activities')) {
      context.handle(
        _adHocActivitiesMeta,
        adHocActivities.isAcceptableOrUnknown(
          data['ad_hoc_activities']!,
          _adHocActivitiesMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_adHocActivitiesMeta);
    }
    if (data.containsKey('duration')) {
      context.handle(
        _durationMeta,
        duration.isAcceptableOrUnknown(data['duration']!, _durationMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('import_source')) {
      context.handle(
        _importSourceMeta,
        importSource.isAcceptableOrUnknown(
          data['import_source']!,
          _importSourceMeta,
        ),
      );
    }
    if (data.containsKey('import_external_id')) {
      context.handle(
        _importExternalIdMeta,
        importExternalId.isAcceptableOrUnknown(
          data['import_external_id']!,
          _importExternalIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ActivityLogRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ActivityLogRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}timestamp'],
      )!,
      activityIds: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}activity_ids'],
      )!,
      adHocActivities: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ad_hoc_activities'],
      )!,
      duration: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}duration'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      importSource: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}import_source'],
      ),
      importExternalId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}import_external_id'],
      ),
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $ActivityLogsTable createAlias(String alias) {
    return $ActivityLogsTable(attachedDatabase, alias);
  }
}

class ActivityLogRow extends DataClass implements Insertable<ActivityLogRow> {
  final String id;
  final String clientId;
  final String profileId;
  final int timestamp;
  final String activityIds;
  final String adHocActivities;
  final int? duration;
  final String? notes;
  final String? importSource;
  final String? importExternalId;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const ActivityLogRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.timestamp,
    required this.activityIds,
    required this.adHocActivities,
    this.duration,
    this.notes,
    this.importSource,
    this.importExternalId,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['timestamp'] = Variable<int>(timestamp);
    map['activity_ids'] = Variable<String>(activityIds);
    map['ad_hoc_activities'] = Variable<String>(adHocActivities);
    if (!nullToAbsent || duration != null) {
      map['duration'] = Variable<int>(duration);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    if (!nullToAbsent || importSource != null) {
      map['import_source'] = Variable<String>(importSource);
    }
    if (!nullToAbsent || importExternalId != null) {
      map['import_external_id'] = Variable<String>(importExternalId);
    }
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  ActivityLogsCompanion toCompanion(bool nullToAbsent) {
    return ActivityLogsCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      timestamp: Value(timestamp),
      activityIds: Value(activityIds),
      adHocActivities: Value(adHocActivities),
      duration: duration == null && nullToAbsent
          ? const Value.absent()
          : Value(duration),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      importSource: importSource == null && nullToAbsent
          ? const Value.absent()
          : Value(importSource),
      importExternalId: importExternalId == null && nullToAbsent
          ? const Value.absent()
          : Value(importExternalId),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory ActivityLogRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ActivityLogRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      timestamp: serializer.fromJson<int>(json['timestamp']),
      activityIds: serializer.fromJson<String>(json['activityIds']),
      adHocActivities: serializer.fromJson<String>(json['adHocActivities']),
      duration: serializer.fromJson<int?>(json['duration']),
      notes: serializer.fromJson<String?>(json['notes']),
      importSource: serializer.fromJson<String?>(json['importSource']),
      importExternalId: serializer.fromJson<String?>(json['importExternalId']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'timestamp': serializer.toJson<int>(timestamp),
      'activityIds': serializer.toJson<String>(activityIds),
      'adHocActivities': serializer.toJson<String>(adHocActivities),
      'duration': serializer.toJson<int?>(duration),
      'notes': serializer.toJson<String?>(notes),
      'importSource': serializer.toJson<String?>(importSource),
      'importExternalId': serializer.toJson<String?>(importExternalId),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  ActivityLogRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    int? timestamp,
    String? activityIds,
    String? adHocActivities,
    Value<int?> duration = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    Value<String?> importSource = const Value.absent(),
    Value<String?> importExternalId = const Value.absent(),
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => ActivityLogRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    timestamp: timestamp ?? this.timestamp,
    activityIds: activityIds ?? this.activityIds,
    adHocActivities: adHocActivities ?? this.adHocActivities,
    duration: duration.present ? duration.value : this.duration,
    notes: notes.present ? notes.value : this.notes,
    importSource: importSource.present ? importSource.value : this.importSource,
    importExternalId: importExternalId.present
        ? importExternalId.value
        : this.importExternalId,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  ActivityLogRow copyWithCompanion(ActivityLogsCompanion data) {
    return ActivityLogRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      activityIds: data.activityIds.present
          ? data.activityIds.value
          : this.activityIds,
      adHocActivities: data.adHocActivities.present
          ? data.adHocActivities.value
          : this.adHocActivities,
      duration: data.duration.present ? data.duration.value : this.duration,
      notes: data.notes.present ? data.notes.value : this.notes,
      importSource: data.importSource.present
          ? data.importSource.value
          : this.importSource,
      importExternalId: data.importExternalId.present
          ? data.importExternalId.value
          : this.importExternalId,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ActivityLogRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('timestamp: $timestamp, ')
          ..write('activityIds: $activityIds, ')
          ..write('adHocActivities: $adHocActivities, ')
          ..write('duration: $duration, ')
          ..write('notes: $notes, ')
          ..write('importSource: $importSource, ')
          ..write('importExternalId: $importExternalId, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    clientId,
    profileId,
    timestamp,
    activityIds,
    adHocActivities,
    duration,
    notes,
    importSource,
    importExternalId,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ActivityLogRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.timestamp == this.timestamp &&
          other.activityIds == this.activityIds &&
          other.adHocActivities == this.adHocActivities &&
          other.duration == this.duration &&
          other.notes == this.notes &&
          other.importSource == this.importSource &&
          other.importExternalId == this.importExternalId &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class ActivityLogsCompanion extends UpdateCompanion<ActivityLogRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<int> timestamp;
  final Value<String> activityIds;
  final Value<String> adHocActivities;
  final Value<int?> duration;
  final Value<String?> notes;
  final Value<String?> importSource;
  final Value<String?> importExternalId;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const ActivityLogsCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.activityIds = const Value.absent(),
    this.adHocActivities = const Value.absent(),
    this.duration = const Value.absent(),
    this.notes = const Value.absent(),
    this.importSource = const Value.absent(),
    this.importExternalId = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActivityLogsCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required int timestamp,
    required String activityIds,
    required String adHocActivities,
    this.duration = const Value.absent(),
    this.notes = const Value.absent(),
    this.importSource = const Value.absent(),
    this.importExternalId = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       timestamp = Value(timestamp),
       activityIds = Value(activityIds),
       adHocActivities = Value(adHocActivities),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<ActivityLogRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<int>? timestamp,
    Expression<String>? activityIds,
    Expression<String>? adHocActivities,
    Expression<int>? duration,
    Expression<String>? notes,
    Expression<String>? importSource,
    Expression<String>? importExternalId,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (timestamp != null) 'timestamp': timestamp,
      if (activityIds != null) 'activity_ids': activityIds,
      if (adHocActivities != null) 'ad_hoc_activities': adHocActivities,
      if (duration != null) 'duration': duration,
      if (notes != null) 'notes': notes,
      if (importSource != null) 'import_source': importSource,
      if (importExternalId != null) 'import_external_id': importExternalId,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActivityLogsCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<int>? timestamp,
    Value<String>? activityIds,
    Value<String>? adHocActivities,
    Value<int?>? duration,
    Value<String?>? notes,
    Value<String?>? importSource,
    Value<String?>? importExternalId,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return ActivityLogsCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      timestamp: timestamp ?? this.timestamp,
      activityIds: activityIds ?? this.activityIds,
      adHocActivities: adHocActivities ?? this.adHocActivities,
      duration: duration ?? this.duration,
      notes: notes ?? this.notes,
      importSource: importSource ?? this.importSource,
      importExternalId: importExternalId ?? this.importExternalId,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<int>(timestamp.value);
    }
    if (activityIds.present) {
      map['activity_ids'] = Variable<String>(activityIds.value);
    }
    if (adHocActivities.present) {
      map['ad_hoc_activities'] = Variable<String>(adHocActivities.value);
    }
    if (duration.present) {
      map['duration'] = Variable<int>(duration.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (importSource.present) {
      map['import_source'] = Variable<String>(importSource.value);
    }
    if (importExternalId.present) {
      map['import_external_id'] = Variable<String>(importExternalId.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActivityLogsCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('timestamp: $timestamp, ')
          ..write('activityIds: $activityIds, ')
          ..write('adHocActivities: $adHocActivities, ')
          ..write('duration: $duration, ')
          ..write('notes: $notes, ')
          ..write('importSource: $importSource, ')
          ..write('importExternalId: $importExternalId, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FoodItemsTable extends FoodItems
    with TableInfo<$FoodItemsTable, FoodItemRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FoodItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<int> type = GeneratedColumn<int>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _simpleItemIdsMeta = const VerificationMeta(
    'simpleItemIds',
  );
  @override
  late final GeneratedColumn<String> simpleItemIds = GeneratedColumn<String>(
    'simple_item_ids',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isUserCreatedMeta = const VerificationMeta(
    'isUserCreated',
  );
  @override
  late final GeneratedColumn<bool> isUserCreated = GeneratedColumn<bool>(
    'is_user_created',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_user_created" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _isArchivedMeta = const VerificationMeta(
    'isArchived',
  );
  @override
  late final GeneratedColumn<bool> isArchived = GeneratedColumn<bool>(
    'is_archived',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_archived" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _servingSizeMeta = const VerificationMeta(
    'servingSize',
  );
  @override
  late final GeneratedColumn<double> servingSize = GeneratedColumn<double>(
    'serving_size',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _servingUnitMeta = const VerificationMeta(
    'servingUnit',
  );
  @override
  late final GeneratedColumn<String> servingUnit = GeneratedColumn<String>(
    'serving_unit',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _caloriesMeta = const VerificationMeta(
    'calories',
  );
  @override
  late final GeneratedColumn<double> calories = GeneratedColumn<double>(
    'calories',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _carbsGramsMeta = const VerificationMeta(
    'carbsGrams',
  );
  @override
  late final GeneratedColumn<double> carbsGrams = GeneratedColumn<double>(
    'carbs_grams',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fatGramsMeta = const VerificationMeta(
    'fatGrams',
  );
  @override
  late final GeneratedColumn<double> fatGrams = GeneratedColumn<double>(
    'fat_grams',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _proteinGramsMeta = const VerificationMeta(
    'proteinGrams',
  );
  @override
  late final GeneratedColumn<double> proteinGrams = GeneratedColumn<double>(
    'protein_grams',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fiberGramsMeta = const VerificationMeta(
    'fiberGrams',
  );
  @override
  late final GeneratedColumn<double> fiberGrams = GeneratedColumn<double>(
    'fiber_grams',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sugarGramsMeta = const VerificationMeta(
    'sugarGrams',
  );
  @override
  late final GeneratedColumn<double> sugarGrams = GeneratedColumn<double>(
    'sugar_grams',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sodiumMgMeta = const VerificationMeta(
    'sodiumMg',
  );
  @override
  late final GeneratedColumn<double> sodiumMg = GeneratedColumn<double>(
    'sodium_mg',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _barcodeMeta = const VerificationMeta(
    'barcode',
  );
  @override
  late final GeneratedColumn<String> barcode = GeneratedColumn<String>(
    'barcode',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _brandMeta = const VerificationMeta('brand');
  @override
  late final GeneratedColumn<String> brand = GeneratedColumn<String>(
    'brand',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _ingredientsTextMeta = const VerificationMeta(
    'ingredientsText',
  );
  @override
  late final GeneratedColumn<String> ingredientsText = GeneratedColumn<String>(
    'ingredients_text',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _openFoodFactsIdMeta = const VerificationMeta(
    'openFoodFactsId',
  );
  @override
  late final GeneratedColumn<String> openFoodFactsId = GeneratedColumn<String>(
    'open_food_facts_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _importSourceMeta = const VerificationMeta(
    'importSource',
  );
  @override
  late final GeneratedColumn<String> importSource = GeneratedColumn<String>(
    'import_source',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _imageUrlMeta = const VerificationMeta(
    'imageUrl',
  );
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
    'image_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    name,
    type,
    simpleItemIds,
    isUserCreated,
    isArchived,
    servingSize,
    servingUnit,
    calories,
    carbsGrams,
    fatGrams,
    proteinGrams,
    fiberGrams,
    sugarGrams,
    sodiumMg,
    barcode,
    brand,
    ingredientsText,
    openFoodFactsId,
    importSource,
    imageUrl,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'food_items';
  @override
  VerificationContext validateIntegrity(
    Insertable<FoodItemRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    }
    if (data.containsKey('simple_item_ids')) {
      context.handle(
        _simpleItemIdsMeta,
        simpleItemIds.isAcceptableOrUnknown(
          data['simple_item_ids']!,
          _simpleItemIdsMeta,
        ),
      );
    }
    if (data.containsKey('is_user_created')) {
      context.handle(
        _isUserCreatedMeta,
        isUserCreated.isAcceptableOrUnknown(
          data['is_user_created']!,
          _isUserCreatedMeta,
        ),
      );
    }
    if (data.containsKey('is_archived')) {
      context.handle(
        _isArchivedMeta,
        isArchived.isAcceptableOrUnknown(data['is_archived']!, _isArchivedMeta),
      );
    }
    if (data.containsKey('serving_size')) {
      context.handle(
        _servingSizeMeta,
        servingSize.isAcceptableOrUnknown(
          data['serving_size']!,
          _servingSizeMeta,
        ),
      );
    }
    if (data.containsKey('serving_unit')) {
      context.handle(
        _servingUnitMeta,
        servingUnit.isAcceptableOrUnknown(
          data['serving_unit']!,
          _servingUnitMeta,
        ),
      );
    }
    if (data.containsKey('calories')) {
      context.handle(
        _caloriesMeta,
        calories.isAcceptableOrUnknown(data['calories']!, _caloriesMeta),
      );
    }
    if (data.containsKey('carbs_grams')) {
      context.handle(
        _carbsGramsMeta,
        carbsGrams.isAcceptableOrUnknown(data['carbs_grams']!, _carbsGramsMeta),
      );
    }
    if (data.containsKey('fat_grams')) {
      context.handle(
        _fatGramsMeta,
        fatGrams.isAcceptableOrUnknown(data['fat_grams']!, _fatGramsMeta),
      );
    }
    if (data.containsKey('protein_grams')) {
      context.handle(
        _proteinGramsMeta,
        proteinGrams.isAcceptableOrUnknown(
          data['protein_grams']!,
          _proteinGramsMeta,
        ),
      );
    }
    if (data.containsKey('fiber_grams')) {
      context.handle(
        _fiberGramsMeta,
        fiberGrams.isAcceptableOrUnknown(data['fiber_grams']!, _fiberGramsMeta),
      );
    }
    if (data.containsKey('sugar_grams')) {
      context.handle(
        _sugarGramsMeta,
        sugarGrams.isAcceptableOrUnknown(data['sugar_grams']!, _sugarGramsMeta),
      );
    }
    if (data.containsKey('sodium_mg')) {
      context.handle(
        _sodiumMgMeta,
        sodiumMg.isAcceptableOrUnknown(data['sodium_mg']!, _sodiumMgMeta),
      );
    }
    if (data.containsKey('barcode')) {
      context.handle(
        _barcodeMeta,
        barcode.isAcceptableOrUnknown(data['barcode']!, _barcodeMeta),
      );
    }
    if (data.containsKey('brand')) {
      context.handle(
        _brandMeta,
        brand.isAcceptableOrUnknown(data['brand']!, _brandMeta),
      );
    }
    if (data.containsKey('ingredients_text')) {
      context.handle(
        _ingredientsTextMeta,
        ingredientsText.isAcceptableOrUnknown(
          data['ingredients_text']!,
          _ingredientsTextMeta,
        ),
      );
    }
    if (data.containsKey('open_food_facts_id')) {
      context.handle(
        _openFoodFactsIdMeta,
        openFoodFactsId.isAcceptableOrUnknown(
          data['open_food_facts_id']!,
          _openFoodFactsIdMeta,
        ),
      );
    }
    if (data.containsKey('import_source')) {
      context.handle(
        _importSourceMeta,
        importSource.isAcceptableOrUnknown(
          data['import_source']!,
          _importSourceMeta,
        ),
      );
    }
    if (data.containsKey('image_url')) {
      context.handle(
        _imageUrlMeta,
        imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FoodItemRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FoodItemRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type'],
      )!,
      simpleItemIds: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}simple_item_ids'],
      ),
      isUserCreated: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_user_created'],
      )!,
      isArchived: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_archived'],
      )!,
      servingSize: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}serving_size'],
      ),
      servingUnit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}serving_unit'],
      ),
      calories: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}calories'],
      ),
      carbsGrams: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}carbs_grams'],
      ),
      fatGrams: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}fat_grams'],
      ),
      proteinGrams: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}protein_grams'],
      ),
      fiberGrams: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}fiber_grams'],
      ),
      sugarGrams: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}sugar_grams'],
      ),
      sodiumMg: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}sodium_mg'],
      ),
      barcode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}barcode'],
      ),
      brand: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}brand'],
      ),
      ingredientsText: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ingredients_text'],
      ),
      openFoodFactsId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}open_food_facts_id'],
      ),
      importSource: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}import_source'],
      ),
      imageUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_url'],
      ),
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $FoodItemsTable createAlias(String alias) {
    return $FoodItemsTable(attachedDatabase, alias);
  }
}

class FoodItemRow extends DataClass implements Insertable<FoodItemRow> {
  final String id;
  final String clientId;
  final String profileId;
  final String name;
  final int type;
  final String? simpleItemIds;
  final bool isUserCreated;
  final bool isArchived;
  final double? servingSize;
  final String? servingUnit;
  final double? calories;
  final double? carbsGrams;
  final double? fatGrams;
  final double? proteinGrams;
  final double? fiberGrams;
  final double? sugarGrams;
  final double? sodiumMg;
  final String? barcode;
  final String? brand;
  final String? ingredientsText;
  final String? openFoodFactsId;
  final String? importSource;
  final String? imageUrl;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const FoodItemRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.name,
    required this.type,
    this.simpleItemIds,
    required this.isUserCreated,
    required this.isArchived,
    this.servingSize,
    this.servingUnit,
    this.calories,
    this.carbsGrams,
    this.fatGrams,
    this.proteinGrams,
    this.fiberGrams,
    this.sugarGrams,
    this.sodiumMg,
    this.barcode,
    this.brand,
    this.ingredientsText,
    this.openFoodFactsId,
    this.importSource,
    this.imageUrl,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['name'] = Variable<String>(name);
    map['type'] = Variable<int>(type);
    if (!nullToAbsent || simpleItemIds != null) {
      map['simple_item_ids'] = Variable<String>(simpleItemIds);
    }
    map['is_user_created'] = Variable<bool>(isUserCreated);
    map['is_archived'] = Variable<bool>(isArchived);
    if (!nullToAbsent || servingSize != null) {
      map['serving_size'] = Variable<double>(servingSize);
    }
    if (!nullToAbsent || servingUnit != null) {
      map['serving_unit'] = Variable<String>(servingUnit);
    }
    if (!nullToAbsent || calories != null) {
      map['calories'] = Variable<double>(calories);
    }
    if (!nullToAbsent || carbsGrams != null) {
      map['carbs_grams'] = Variable<double>(carbsGrams);
    }
    if (!nullToAbsent || fatGrams != null) {
      map['fat_grams'] = Variable<double>(fatGrams);
    }
    if (!nullToAbsent || proteinGrams != null) {
      map['protein_grams'] = Variable<double>(proteinGrams);
    }
    if (!nullToAbsent || fiberGrams != null) {
      map['fiber_grams'] = Variable<double>(fiberGrams);
    }
    if (!nullToAbsent || sugarGrams != null) {
      map['sugar_grams'] = Variable<double>(sugarGrams);
    }
    if (!nullToAbsent || sodiumMg != null) {
      map['sodium_mg'] = Variable<double>(sodiumMg);
    }
    if (!nullToAbsent || barcode != null) {
      map['barcode'] = Variable<String>(barcode);
    }
    if (!nullToAbsent || brand != null) {
      map['brand'] = Variable<String>(brand);
    }
    if (!nullToAbsent || ingredientsText != null) {
      map['ingredients_text'] = Variable<String>(ingredientsText);
    }
    if (!nullToAbsent || openFoodFactsId != null) {
      map['open_food_facts_id'] = Variable<String>(openFoodFactsId);
    }
    if (!nullToAbsent || importSource != null) {
      map['import_source'] = Variable<String>(importSource);
    }
    if (!nullToAbsent || imageUrl != null) {
      map['image_url'] = Variable<String>(imageUrl);
    }
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  FoodItemsCompanion toCompanion(bool nullToAbsent) {
    return FoodItemsCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      name: Value(name),
      type: Value(type),
      simpleItemIds: simpleItemIds == null && nullToAbsent
          ? const Value.absent()
          : Value(simpleItemIds),
      isUserCreated: Value(isUserCreated),
      isArchived: Value(isArchived),
      servingSize: servingSize == null && nullToAbsent
          ? const Value.absent()
          : Value(servingSize),
      servingUnit: servingUnit == null && nullToAbsent
          ? const Value.absent()
          : Value(servingUnit),
      calories: calories == null && nullToAbsent
          ? const Value.absent()
          : Value(calories),
      carbsGrams: carbsGrams == null && nullToAbsent
          ? const Value.absent()
          : Value(carbsGrams),
      fatGrams: fatGrams == null && nullToAbsent
          ? const Value.absent()
          : Value(fatGrams),
      proteinGrams: proteinGrams == null && nullToAbsent
          ? const Value.absent()
          : Value(proteinGrams),
      fiberGrams: fiberGrams == null && nullToAbsent
          ? const Value.absent()
          : Value(fiberGrams),
      sugarGrams: sugarGrams == null && nullToAbsent
          ? const Value.absent()
          : Value(sugarGrams),
      sodiumMg: sodiumMg == null && nullToAbsent
          ? const Value.absent()
          : Value(sodiumMg),
      barcode: barcode == null && nullToAbsent
          ? const Value.absent()
          : Value(barcode),
      brand: brand == null && nullToAbsent
          ? const Value.absent()
          : Value(brand),
      ingredientsText: ingredientsText == null && nullToAbsent
          ? const Value.absent()
          : Value(ingredientsText),
      openFoodFactsId: openFoodFactsId == null && nullToAbsent
          ? const Value.absent()
          : Value(openFoodFactsId),
      importSource: importSource == null && nullToAbsent
          ? const Value.absent()
          : Value(importSource),
      imageUrl: imageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(imageUrl),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory FoodItemRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FoodItemRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      name: serializer.fromJson<String>(json['name']),
      type: serializer.fromJson<int>(json['type']),
      simpleItemIds: serializer.fromJson<String?>(json['simpleItemIds']),
      isUserCreated: serializer.fromJson<bool>(json['isUserCreated']),
      isArchived: serializer.fromJson<bool>(json['isArchived']),
      servingSize: serializer.fromJson<double?>(json['servingSize']),
      servingUnit: serializer.fromJson<String?>(json['servingUnit']),
      calories: serializer.fromJson<double?>(json['calories']),
      carbsGrams: serializer.fromJson<double?>(json['carbsGrams']),
      fatGrams: serializer.fromJson<double?>(json['fatGrams']),
      proteinGrams: serializer.fromJson<double?>(json['proteinGrams']),
      fiberGrams: serializer.fromJson<double?>(json['fiberGrams']),
      sugarGrams: serializer.fromJson<double?>(json['sugarGrams']),
      sodiumMg: serializer.fromJson<double?>(json['sodiumMg']),
      barcode: serializer.fromJson<String?>(json['barcode']),
      brand: serializer.fromJson<String?>(json['brand']),
      ingredientsText: serializer.fromJson<String?>(json['ingredientsText']),
      openFoodFactsId: serializer.fromJson<String?>(json['openFoodFactsId']),
      importSource: serializer.fromJson<String?>(json['importSource']),
      imageUrl: serializer.fromJson<String?>(json['imageUrl']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'name': serializer.toJson<String>(name),
      'type': serializer.toJson<int>(type),
      'simpleItemIds': serializer.toJson<String?>(simpleItemIds),
      'isUserCreated': serializer.toJson<bool>(isUserCreated),
      'isArchived': serializer.toJson<bool>(isArchived),
      'servingSize': serializer.toJson<double?>(servingSize),
      'servingUnit': serializer.toJson<String?>(servingUnit),
      'calories': serializer.toJson<double?>(calories),
      'carbsGrams': serializer.toJson<double?>(carbsGrams),
      'fatGrams': serializer.toJson<double?>(fatGrams),
      'proteinGrams': serializer.toJson<double?>(proteinGrams),
      'fiberGrams': serializer.toJson<double?>(fiberGrams),
      'sugarGrams': serializer.toJson<double?>(sugarGrams),
      'sodiumMg': serializer.toJson<double?>(sodiumMg),
      'barcode': serializer.toJson<String?>(barcode),
      'brand': serializer.toJson<String?>(brand),
      'ingredientsText': serializer.toJson<String?>(ingredientsText),
      'openFoodFactsId': serializer.toJson<String?>(openFoodFactsId),
      'importSource': serializer.toJson<String?>(importSource),
      'imageUrl': serializer.toJson<String?>(imageUrl),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  FoodItemRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    String? name,
    int? type,
    Value<String?> simpleItemIds = const Value.absent(),
    bool? isUserCreated,
    bool? isArchived,
    Value<double?> servingSize = const Value.absent(),
    Value<String?> servingUnit = const Value.absent(),
    Value<double?> calories = const Value.absent(),
    Value<double?> carbsGrams = const Value.absent(),
    Value<double?> fatGrams = const Value.absent(),
    Value<double?> proteinGrams = const Value.absent(),
    Value<double?> fiberGrams = const Value.absent(),
    Value<double?> sugarGrams = const Value.absent(),
    Value<double?> sodiumMg = const Value.absent(),
    Value<String?> barcode = const Value.absent(),
    Value<String?> brand = const Value.absent(),
    Value<String?> ingredientsText = const Value.absent(),
    Value<String?> openFoodFactsId = const Value.absent(),
    Value<String?> importSource = const Value.absent(),
    Value<String?> imageUrl = const Value.absent(),
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => FoodItemRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    name: name ?? this.name,
    type: type ?? this.type,
    simpleItemIds: simpleItemIds.present
        ? simpleItemIds.value
        : this.simpleItemIds,
    isUserCreated: isUserCreated ?? this.isUserCreated,
    isArchived: isArchived ?? this.isArchived,
    servingSize: servingSize.present ? servingSize.value : this.servingSize,
    servingUnit: servingUnit.present ? servingUnit.value : this.servingUnit,
    calories: calories.present ? calories.value : this.calories,
    carbsGrams: carbsGrams.present ? carbsGrams.value : this.carbsGrams,
    fatGrams: fatGrams.present ? fatGrams.value : this.fatGrams,
    proteinGrams: proteinGrams.present ? proteinGrams.value : this.proteinGrams,
    fiberGrams: fiberGrams.present ? fiberGrams.value : this.fiberGrams,
    sugarGrams: sugarGrams.present ? sugarGrams.value : this.sugarGrams,
    sodiumMg: sodiumMg.present ? sodiumMg.value : this.sodiumMg,
    barcode: barcode.present ? barcode.value : this.barcode,
    brand: brand.present ? brand.value : this.brand,
    ingredientsText: ingredientsText.present
        ? ingredientsText.value
        : this.ingredientsText,
    openFoodFactsId: openFoodFactsId.present
        ? openFoodFactsId.value
        : this.openFoodFactsId,
    importSource: importSource.present ? importSource.value : this.importSource,
    imageUrl: imageUrl.present ? imageUrl.value : this.imageUrl,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  FoodItemRow copyWithCompanion(FoodItemsCompanion data) {
    return FoodItemRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      name: data.name.present ? data.name.value : this.name,
      type: data.type.present ? data.type.value : this.type,
      simpleItemIds: data.simpleItemIds.present
          ? data.simpleItemIds.value
          : this.simpleItemIds,
      isUserCreated: data.isUserCreated.present
          ? data.isUserCreated.value
          : this.isUserCreated,
      isArchived: data.isArchived.present
          ? data.isArchived.value
          : this.isArchived,
      servingSize: data.servingSize.present
          ? data.servingSize.value
          : this.servingSize,
      servingUnit: data.servingUnit.present
          ? data.servingUnit.value
          : this.servingUnit,
      calories: data.calories.present ? data.calories.value : this.calories,
      carbsGrams: data.carbsGrams.present
          ? data.carbsGrams.value
          : this.carbsGrams,
      fatGrams: data.fatGrams.present ? data.fatGrams.value : this.fatGrams,
      proteinGrams: data.proteinGrams.present
          ? data.proteinGrams.value
          : this.proteinGrams,
      fiberGrams: data.fiberGrams.present
          ? data.fiberGrams.value
          : this.fiberGrams,
      sugarGrams: data.sugarGrams.present
          ? data.sugarGrams.value
          : this.sugarGrams,
      sodiumMg: data.sodiumMg.present ? data.sodiumMg.value : this.sodiumMg,
      barcode: data.barcode.present ? data.barcode.value : this.barcode,
      brand: data.brand.present ? data.brand.value : this.brand,
      ingredientsText: data.ingredientsText.present
          ? data.ingredientsText.value
          : this.ingredientsText,
      openFoodFactsId: data.openFoodFactsId.present
          ? data.openFoodFactsId.value
          : this.openFoodFactsId,
      importSource: data.importSource.present
          ? data.importSource.value
          : this.importSource,
      imageUrl: data.imageUrl.present ? data.imageUrl.value : this.imageUrl,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FoodItemRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('name: $name, ')
          ..write('type: $type, ')
          ..write('simpleItemIds: $simpleItemIds, ')
          ..write('isUserCreated: $isUserCreated, ')
          ..write('isArchived: $isArchived, ')
          ..write('servingSize: $servingSize, ')
          ..write('servingUnit: $servingUnit, ')
          ..write('calories: $calories, ')
          ..write('carbsGrams: $carbsGrams, ')
          ..write('fatGrams: $fatGrams, ')
          ..write('proteinGrams: $proteinGrams, ')
          ..write('fiberGrams: $fiberGrams, ')
          ..write('sugarGrams: $sugarGrams, ')
          ..write('sodiumMg: $sodiumMg, ')
          ..write('barcode: $barcode, ')
          ..write('brand: $brand, ')
          ..write('ingredientsText: $ingredientsText, ')
          ..write('openFoodFactsId: $openFoodFactsId, ')
          ..write('importSource: $importSource, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    clientId,
    profileId,
    name,
    type,
    simpleItemIds,
    isUserCreated,
    isArchived,
    servingSize,
    servingUnit,
    calories,
    carbsGrams,
    fatGrams,
    proteinGrams,
    fiberGrams,
    sugarGrams,
    sodiumMg,
    barcode,
    brand,
    ingredientsText,
    openFoodFactsId,
    importSource,
    imageUrl,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FoodItemRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.name == this.name &&
          other.type == this.type &&
          other.simpleItemIds == this.simpleItemIds &&
          other.isUserCreated == this.isUserCreated &&
          other.isArchived == this.isArchived &&
          other.servingSize == this.servingSize &&
          other.servingUnit == this.servingUnit &&
          other.calories == this.calories &&
          other.carbsGrams == this.carbsGrams &&
          other.fatGrams == this.fatGrams &&
          other.proteinGrams == this.proteinGrams &&
          other.fiberGrams == this.fiberGrams &&
          other.sugarGrams == this.sugarGrams &&
          other.sodiumMg == this.sodiumMg &&
          other.barcode == this.barcode &&
          other.brand == this.brand &&
          other.ingredientsText == this.ingredientsText &&
          other.openFoodFactsId == this.openFoodFactsId &&
          other.importSource == this.importSource &&
          other.imageUrl == this.imageUrl &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class FoodItemsCompanion extends UpdateCompanion<FoodItemRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<String> name;
  final Value<int> type;
  final Value<String?> simpleItemIds;
  final Value<bool> isUserCreated;
  final Value<bool> isArchived;
  final Value<double?> servingSize;
  final Value<String?> servingUnit;
  final Value<double?> calories;
  final Value<double?> carbsGrams;
  final Value<double?> fatGrams;
  final Value<double?> proteinGrams;
  final Value<double?> fiberGrams;
  final Value<double?> sugarGrams;
  final Value<double?> sodiumMg;
  final Value<String?> barcode;
  final Value<String?> brand;
  final Value<String?> ingredientsText;
  final Value<String?> openFoodFactsId;
  final Value<String?> importSource;
  final Value<String?> imageUrl;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const FoodItemsCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.name = const Value.absent(),
    this.type = const Value.absent(),
    this.simpleItemIds = const Value.absent(),
    this.isUserCreated = const Value.absent(),
    this.isArchived = const Value.absent(),
    this.servingSize = const Value.absent(),
    this.servingUnit = const Value.absent(),
    this.calories = const Value.absent(),
    this.carbsGrams = const Value.absent(),
    this.fatGrams = const Value.absent(),
    this.proteinGrams = const Value.absent(),
    this.fiberGrams = const Value.absent(),
    this.sugarGrams = const Value.absent(),
    this.sodiumMg = const Value.absent(),
    this.barcode = const Value.absent(),
    this.brand = const Value.absent(),
    this.ingredientsText = const Value.absent(),
    this.openFoodFactsId = const Value.absent(),
    this.importSource = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FoodItemsCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required String name,
    this.type = const Value.absent(),
    this.simpleItemIds = const Value.absent(),
    this.isUserCreated = const Value.absent(),
    this.isArchived = const Value.absent(),
    this.servingSize = const Value.absent(),
    this.servingUnit = const Value.absent(),
    this.calories = const Value.absent(),
    this.carbsGrams = const Value.absent(),
    this.fatGrams = const Value.absent(),
    this.proteinGrams = const Value.absent(),
    this.fiberGrams = const Value.absent(),
    this.sugarGrams = const Value.absent(),
    this.sodiumMg = const Value.absent(),
    this.barcode = const Value.absent(),
    this.brand = const Value.absent(),
    this.ingredientsText = const Value.absent(),
    this.openFoodFactsId = const Value.absent(),
    this.importSource = const Value.absent(),
    this.imageUrl = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       name = Value(name),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<FoodItemRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<String>? name,
    Expression<int>? type,
    Expression<String>? simpleItemIds,
    Expression<bool>? isUserCreated,
    Expression<bool>? isArchived,
    Expression<double>? servingSize,
    Expression<String>? servingUnit,
    Expression<double>? calories,
    Expression<double>? carbsGrams,
    Expression<double>? fatGrams,
    Expression<double>? proteinGrams,
    Expression<double>? fiberGrams,
    Expression<double>? sugarGrams,
    Expression<double>? sodiumMg,
    Expression<String>? barcode,
    Expression<String>? brand,
    Expression<String>? ingredientsText,
    Expression<String>? openFoodFactsId,
    Expression<String>? importSource,
    Expression<String>? imageUrl,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (name != null) 'name': name,
      if (type != null) 'type': type,
      if (simpleItemIds != null) 'simple_item_ids': simpleItemIds,
      if (isUserCreated != null) 'is_user_created': isUserCreated,
      if (isArchived != null) 'is_archived': isArchived,
      if (servingSize != null) 'serving_size': servingSize,
      if (servingUnit != null) 'serving_unit': servingUnit,
      if (calories != null) 'calories': calories,
      if (carbsGrams != null) 'carbs_grams': carbsGrams,
      if (fatGrams != null) 'fat_grams': fatGrams,
      if (proteinGrams != null) 'protein_grams': proteinGrams,
      if (fiberGrams != null) 'fiber_grams': fiberGrams,
      if (sugarGrams != null) 'sugar_grams': sugarGrams,
      if (sodiumMg != null) 'sodium_mg': sodiumMg,
      if (barcode != null) 'barcode': barcode,
      if (brand != null) 'brand': brand,
      if (ingredientsText != null) 'ingredients_text': ingredientsText,
      if (openFoodFactsId != null) 'open_food_facts_id': openFoodFactsId,
      if (importSource != null) 'import_source': importSource,
      if (imageUrl != null) 'image_url': imageUrl,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FoodItemsCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<String>? name,
    Value<int>? type,
    Value<String?>? simpleItemIds,
    Value<bool>? isUserCreated,
    Value<bool>? isArchived,
    Value<double?>? servingSize,
    Value<String?>? servingUnit,
    Value<double?>? calories,
    Value<double?>? carbsGrams,
    Value<double?>? fatGrams,
    Value<double?>? proteinGrams,
    Value<double?>? fiberGrams,
    Value<double?>? sugarGrams,
    Value<double?>? sodiumMg,
    Value<String?>? barcode,
    Value<String?>? brand,
    Value<String?>? ingredientsText,
    Value<String?>? openFoodFactsId,
    Value<String?>? importSource,
    Value<String?>? imageUrl,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return FoodItemsCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      name: name ?? this.name,
      type: type ?? this.type,
      simpleItemIds: simpleItemIds ?? this.simpleItemIds,
      isUserCreated: isUserCreated ?? this.isUserCreated,
      isArchived: isArchived ?? this.isArchived,
      servingSize: servingSize ?? this.servingSize,
      servingUnit: servingUnit ?? this.servingUnit,
      calories: calories ?? this.calories,
      carbsGrams: carbsGrams ?? this.carbsGrams,
      fatGrams: fatGrams ?? this.fatGrams,
      proteinGrams: proteinGrams ?? this.proteinGrams,
      fiberGrams: fiberGrams ?? this.fiberGrams,
      sugarGrams: sugarGrams ?? this.sugarGrams,
      sodiumMg: sodiumMg ?? this.sodiumMg,
      barcode: barcode ?? this.barcode,
      brand: brand ?? this.brand,
      ingredientsText: ingredientsText ?? this.ingredientsText,
      openFoodFactsId: openFoodFactsId ?? this.openFoodFactsId,
      importSource: importSource ?? this.importSource,
      imageUrl: imageUrl ?? this.imageUrl,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (type.present) {
      map['type'] = Variable<int>(type.value);
    }
    if (simpleItemIds.present) {
      map['simple_item_ids'] = Variable<String>(simpleItemIds.value);
    }
    if (isUserCreated.present) {
      map['is_user_created'] = Variable<bool>(isUserCreated.value);
    }
    if (isArchived.present) {
      map['is_archived'] = Variable<bool>(isArchived.value);
    }
    if (servingSize.present) {
      map['serving_size'] = Variable<double>(servingSize.value);
    }
    if (servingUnit.present) {
      map['serving_unit'] = Variable<String>(servingUnit.value);
    }
    if (calories.present) {
      map['calories'] = Variable<double>(calories.value);
    }
    if (carbsGrams.present) {
      map['carbs_grams'] = Variable<double>(carbsGrams.value);
    }
    if (fatGrams.present) {
      map['fat_grams'] = Variable<double>(fatGrams.value);
    }
    if (proteinGrams.present) {
      map['protein_grams'] = Variable<double>(proteinGrams.value);
    }
    if (fiberGrams.present) {
      map['fiber_grams'] = Variable<double>(fiberGrams.value);
    }
    if (sugarGrams.present) {
      map['sugar_grams'] = Variable<double>(sugarGrams.value);
    }
    if (sodiumMg.present) {
      map['sodium_mg'] = Variable<double>(sodiumMg.value);
    }
    if (barcode.present) {
      map['barcode'] = Variable<String>(barcode.value);
    }
    if (brand.present) {
      map['brand'] = Variable<String>(brand.value);
    }
    if (ingredientsText.present) {
      map['ingredients_text'] = Variable<String>(ingredientsText.value);
    }
    if (openFoodFactsId.present) {
      map['open_food_facts_id'] = Variable<String>(openFoodFactsId.value);
    }
    if (importSource.present) {
      map['import_source'] = Variable<String>(importSource.value);
    }
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FoodItemsCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('name: $name, ')
          ..write('type: $type, ')
          ..write('simpleItemIds: $simpleItemIds, ')
          ..write('isUserCreated: $isUserCreated, ')
          ..write('isArchived: $isArchived, ')
          ..write('servingSize: $servingSize, ')
          ..write('servingUnit: $servingUnit, ')
          ..write('calories: $calories, ')
          ..write('carbsGrams: $carbsGrams, ')
          ..write('fatGrams: $fatGrams, ')
          ..write('proteinGrams: $proteinGrams, ')
          ..write('fiberGrams: $fiberGrams, ')
          ..write('sugarGrams: $sugarGrams, ')
          ..write('sodiumMg: $sodiumMg, ')
          ..write('barcode: $barcode, ')
          ..write('brand: $brand, ')
          ..write('ingredientsText: $ingredientsText, ')
          ..write('openFoodFactsId: $openFoodFactsId, ')
          ..write('importSource: $importSource, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FoodItemComponentsTable extends FoodItemComponents
    with TableInfo<$FoodItemComponentsTable, FoodItemComponentRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FoodItemComponentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _composedFoodItemIdMeta =
      const VerificationMeta('composedFoodItemId');
  @override
  late final GeneratedColumn<String> composedFoodItemId =
      GeneratedColumn<String>(
        'composed_food_item_id',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _simpleFoodItemIdMeta = const VerificationMeta(
    'simpleFoodItemId',
  );
  @override
  late final GeneratedColumn<String> simpleFoodItemId = GeneratedColumn<String>(
    'simple_food_item_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    composedFoodItemId,
    simpleFoodItemId,
    quantity,
    sortOrder,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'food_item_components';
  @override
  VerificationContext validateIntegrity(
    Insertable<FoodItemComponentRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('composed_food_item_id')) {
      context.handle(
        _composedFoodItemIdMeta,
        composedFoodItemId.isAcceptableOrUnknown(
          data['composed_food_item_id']!,
          _composedFoodItemIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_composedFoodItemIdMeta);
    }
    if (data.containsKey('simple_food_item_id')) {
      context.handle(
        _simpleFoodItemIdMeta,
        simpleFoodItemId.isAcceptableOrUnknown(
          data['simple_food_item_id']!,
          _simpleFoodItemIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_simpleFoodItemIdMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FoodItemComponentRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FoodItemComponentRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      composedFoodItemId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}composed_food_item_id'],
      )!,
      simpleFoodItemId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}simple_food_item_id'],
      )!,
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}quantity'],
      )!,
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
    );
  }

  @override
  $FoodItemComponentsTable createAlias(String alias) {
    return $FoodItemComponentsTable(attachedDatabase, alias);
  }
}

class FoodItemComponentRow extends DataClass
    implements Insertable<FoodItemComponentRow> {
  final String id;
  final String composedFoodItemId;
  final String simpleFoodItemId;
  final double quantity;
  final int sortOrder;
  const FoodItemComponentRow({
    required this.id,
    required this.composedFoodItemId,
    required this.simpleFoodItemId,
    required this.quantity,
    required this.sortOrder,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['composed_food_item_id'] = Variable<String>(composedFoodItemId);
    map['simple_food_item_id'] = Variable<String>(simpleFoodItemId);
    map['quantity'] = Variable<double>(quantity);
    map['sort_order'] = Variable<int>(sortOrder);
    return map;
  }

  FoodItemComponentsCompanion toCompanion(bool nullToAbsent) {
    return FoodItemComponentsCompanion(
      id: Value(id),
      composedFoodItemId: Value(composedFoodItemId),
      simpleFoodItemId: Value(simpleFoodItemId),
      quantity: Value(quantity),
      sortOrder: Value(sortOrder),
    );
  }

  factory FoodItemComponentRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FoodItemComponentRow(
      id: serializer.fromJson<String>(json['id']),
      composedFoodItemId: serializer.fromJson<String>(
        json['composedFoodItemId'],
      ),
      simpleFoodItemId: serializer.fromJson<String>(json['simpleFoodItemId']),
      quantity: serializer.fromJson<double>(json['quantity']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'composedFoodItemId': serializer.toJson<String>(composedFoodItemId),
      'simpleFoodItemId': serializer.toJson<String>(simpleFoodItemId),
      'quantity': serializer.toJson<double>(quantity),
      'sortOrder': serializer.toJson<int>(sortOrder),
    };
  }

  FoodItemComponentRow copyWith({
    String? id,
    String? composedFoodItemId,
    String? simpleFoodItemId,
    double? quantity,
    int? sortOrder,
  }) => FoodItemComponentRow(
    id: id ?? this.id,
    composedFoodItemId: composedFoodItemId ?? this.composedFoodItemId,
    simpleFoodItemId: simpleFoodItemId ?? this.simpleFoodItemId,
    quantity: quantity ?? this.quantity,
    sortOrder: sortOrder ?? this.sortOrder,
  );
  FoodItemComponentRow copyWithCompanion(FoodItemComponentsCompanion data) {
    return FoodItemComponentRow(
      id: data.id.present ? data.id.value : this.id,
      composedFoodItemId: data.composedFoodItemId.present
          ? data.composedFoodItemId.value
          : this.composedFoodItemId,
      simpleFoodItemId: data.simpleFoodItemId.present
          ? data.simpleFoodItemId.value
          : this.simpleFoodItemId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FoodItemComponentRow(')
          ..write('id: $id, ')
          ..write('composedFoodItemId: $composedFoodItemId, ')
          ..write('simpleFoodItemId: $simpleFoodItemId, ')
          ..write('quantity: $quantity, ')
          ..write('sortOrder: $sortOrder')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    composedFoodItemId,
    simpleFoodItemId,
    quantity,
    sortOrder,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FoodItemComponentRow &&
          other.id == this.id &&
          other.composedFoodItemId == this.composedFoodItemId &&
          other.simpleFoodItemId == this.simpleFoodItemId &&
          other.quantity == this.quantity &&
          other.sortOrder == this.sortOrder);
}

class FoodItemComponentsCompanion
    extends UpdateCompanion<FoodItemComponentRow> {
  final Value<String> id;
  final Value<String> composedFoodItemId;
  final Value<String> simpleFoodItemId;
  final Value<double> quantity;
  final Value<int> sortOrder;
  final Value<int> rowid;
  const FoodItemComponentsCompanion({
    this.id = const Value.absent(),
    this.composedFoodItemId = const Value.absent(),
    this.simpleFoodItemId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FoodItemComponentsCompanion.insert({
    required String id,
    required String composedFoodItemId,
    required String simpleFoodItemId,
    this.quantity = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       composedFoodItemId = Value(composedFoodItemId),
       simpleFoodItemId = Value(simpleFoodItemId);
  static Insertable<FoodItemComponentRow> custom({
    Expression<String>? id,
    Expression<String>? composedFoodItemId,
    Expression<String>? simpleFoodItemId,
    Expression<double>? quantity,
    Expression<int>? sortOrder,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (composedFoodItemId != null)
        'composed_food_item_id': composedFoodItemId,
      if (simpleFoodItemId != null) 'simple_food_item_id': simpleFoodItemId,
      if (quantity != null) 'quantity': quantity,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FoodItemComponentsCompanion copyWith({
    Value<String>? id,
    Value<String>? composedFoodItemId,
    Value<String>? simpleFoodItemId,
    Value<double>? quantity,
    Value<int>? sortOrder,
    Value<int>? rowid,
  }) {
    return FoodItemComponentsCompanion(
      id: id ?? this.id,
      composedFoodItemId: composedFoodItemId ?? this.composedFoodItemId,
      simpleFoodItemId: simpleFoodItemId ?? this.simpleFoodItemId,
      quantity: quantity ?? this.quantity,
      sortOrder: sortOrder ?? this.sortOrder,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (composedFoodItemId.present) {
      map['composed_food_item_id'] = Variable<String>(composedFoodItemId.value);
    }
    if (simpleFoodItemId.present) {
      map['simple_food_item_id'] = Variable<String>(simpleFoodItemId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FoodItemComponentsCompanion(')
          ..write('id: $id, ')
          ..write('composedFoodItemId: $composedFoodItemId, ')
          ..write('simpleFoodItemId: $simpleFoodItemId, ')
          ..write('quantity: $quantity, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FoodBarcodeCacheTable extends FoodBarcodeCache
    with TableInfo<$FoodBarcodeCacheTable, FoodBarcodeCacheRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FoodBarcodeCacheTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _barcodeMeta = const VerificationMeta(
    'barcode',
  );
  @override
  late final GeneratedColumn<String> barcode = GeneratedColumn<String>(
    'barcode',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _productNameMeta = const VerificationMeta(
    'productName',
  );
  @override
  late final GeneratedColumn<String> productName = GeneratedColumn<String>(
    'product_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _brandMeta = const VerificationMeta('brand');
  @override
  late final GeneratedColumn<String> brand = GeneratedColumn<String>(
    'brand',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _ingredientsTextMeta = const VerificationMeta(
    'ingredientsText',
  );
  @override
  late final GeneratedColumn<String> ingredientsText = GeneratedColumn<String>(
    'ingredients_text',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _caloriesMeta = const VerificationMeta(
    'calories',
  );
  @override
  late final GeneratedColumn<double> calories = GeneratedColumn<double>(
    'calories',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _carbsMeta = const VerificationMeta('carbs');
  @override
  late final GeneratedColumn<double> carbs = GeneratedColumn<double>(
    'carbs',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fatMeta = const VerificationMeta('fat');
  @override
  late final GeneratedColumn<double> fat = GeneratedColumn<double>(
    'fat',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _proteinMeta = const VerificationMeta(
    'protein',
  );
  @override
  late final GeneratedColumn<double> protein = GeneratedColumn<double>(
    'protein',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fiberMeta = const VerificationMeta('fiber');
  @override
  late final GeneratedColumn<double> fiber = GeneratedColumn<double>(
    'fiber',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sugarMeta = const VerificationMeta('sugar');
  @override
  late final GeneratedColumn<double> sugar = GeneratedColumn<double>(
    'sugar',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sodiumMgMeta = const VerificationMeta(
    'sodiumMg',
  );
  @override
  late final GeneratedColumn<double> sodiumMg = GeneratedColumn<double>(
    'sodium_mg',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _openFoodFactsIdMeta = const VerificationMeta(
    'openFoodFactsId',
  );
  @override
  late final GeneratedColumn<String> openFoodFactsId = GeneratedColumn<String>(
    'open_food_facts_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _imageUrlMeta = const VerificationMeta(
    'imageUrl',
  );
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
    'image_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _rawResponseMeta = const VerificationMeta(
    'rawResponse',
  );
  @override
  late final GeneratedColumn<String> rawResponse = GeneratedColumn<String>(
    'raw_response',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fetchedAtMeta = const VerificationMeta(
    'fetchedAt',
  );
  @override
  late final GeneratedColumn<int> fetchedAt = GeneratedColumn<int>(
    'fetched_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<int> expiresAt = GeneratedColumn<int>(
    'expires_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    barcode,
    productName,
    brand,
    ingredientsText,
    calories,
    carbs,
    fat,
    protein,
    fiber,
    sugar,
    sodiumMg,
    openFoodFactsId,
    imageUrl,
    rawResponse,
    fetchedAt,
    expiresAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'food_barcode_cache';
  @override
  VerificationContext validateIntegrity(
    Insertable<FoodBarcodeCacheRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('barcode')) {
      context.handle(
        _barcodeMeta,
        barcode.isAcceptableOrUnknown(data['barcode']!, _barcodeMeta),
      );
    } else if (isInserting) {
      context.missing(_barcodeMeta);
    }
    if (data.containsKey('product_name')) {
      context.handle(
        _productNameMeta,
        productName.isAcceptableOrUnknown(
          data['product_name']!,
          _productNameMeta,
        ),
      );
    }
    if (data.containsKey('brand')) {
      context.handle(
        _brandMeta,
        brand.isAcceptableOrUnknown(data['brand']!, _brandMeta),
      );
    }
    if (data.containsKey('ingredients_text')) {
      context.handle(
        _ingredientsTextMeta,
        ingredientsText.isAcceptableOrUnknown(
          data['ingredients_text']!,
          _ingredientsTextMeta,
        ),
      );
    }
    if (data.containsKey('calories')) {
      context.handle(
        _caloriesMeta,
        calories.isAcceptableOrUnknown(data['calories']!, _caloriesMeta),
      );
    }
    if (data.containsKey('carbs')) {
      context.handle(
        _carbsMeta,
        carbs.isAcceptableOrUnknown(data['carbs']!, _carbsMeta),
      );
    }
    if (data.containsKey('fat')) {
      context.handle(
        _fatMeta,
        fat.isAcceptableOrUnknown(data['fat']!, _fatMeta),
      );
    }
    if (data.containsKey('protein')) {
      context.handle(
        _proteinMeta,
        protein.isAcceptableOrUnknown(data['protein']!, _proteinMeta),
      );
    }
    if (data.containsKey('fiber')) {
      context.handle(
        _fiberMeta,
        fiber.isAcceptableOrUnknown(data['fiber']!, _fiberMeta),
      );
    }
    if (data.containsKey('sugar')) {
      context.handle(
        _sugarMeta,
        sugar.isAcceptableOrUnknown(data['sugar']!, _sugarMeta),
      );
    }
    if (data.containsKey('sodium_mg')) {
      context.handle(
        _sodiumMgMeta,
        sodiumMg.isAcceptableOrUnknown(data['sodium_mg']!, _sodiumMgMeta),
      );
    }
    if (data.containsKey('open_food_facts_id')) {
      context.handle(
        _openFoodFactsIdMeta,
        openFoodFactsId.isAcceptableOrUnknown(
          data['open_food_facts_id']!,
          _openFoodFactsIdMeta,
        ),
      );
    }
    if (data.containsKey('image_url')) {
      context.handle(
        _imageUrlMeta,
        imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta),
      );
    }
    if (data.containsKey('raw_response')) {
      context.handle(
        _rawResponseMeta,
        rawResponse.isAcceptableOrUnknown(
          data['raw_response']!,
          _rawResponseMeta,
        ),
      );
    }
    if (data.containsKey('fetched_at')) {
      context.handle(
        _fetchedAtMeta,
        fetchedAt.isAcceptableOrUnknown(data['fetched_at']!, _fetchedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_fetchedAtMeta);
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    } else if (isInserting) {
      context.missing(_expiresAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FoodBarcodeCacheRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FoodBarcodeCacheRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      barcode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}barcode'],
      )!,
      productName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_name'],
      ),
      brand: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}brand'],
      ),
      ingredientsText: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ingredients_text'],
      ),
      calories: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}calories'],
      ),
      carbs: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}carbs'],
      ),
      fat: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}fat'],
      ),
      protein: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}protein'],
      ),
      fiber: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}fiber'],
      ),
      sugar: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}sugar'],
      ),
      sodiumMg: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}sodium_mg'],
      ),
      openFoodFactsId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}open_food_facts_id'],
      ),
      imageUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_url'],
      ),
      rawResponse: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}raw_response'],
      ),
      fetchedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}fetched_at'],
      )!,
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}expires_at'],
      )!,
    );
  }

  @override
  $FoodBarcodeCacheTable createAlias(String alias) {
    return $FoodBarcodeCacheTable(attachedDatabase, alias);
  }
}

class FoodBarcodeCacheRow extends DataClass
    implements Insertable<FoodBarcodeCacheRow> {
  final String id;
  final String barcode;
  final String? productName;
  final String? brand;
  final String? ingredientsText;
  final double? calories;
  final double? carbs;
  final double? fat;
  final double? protein;
  final double? fiber;
  final double? sugar;
  final double? sodiumMg;
  final String? openFoodFactsId;
  final String? imageUrl;
  final String? rawResponse;
  final int fetchedAt;
  final int expiresAt;
  const FoodBarcodeCacheRow({
    required this.id,
    required this.barcode,
    this.productName,
    this.brand,
    this.ingredientsText,
    this.calories,
    this.carbs,
    this.fat,
    this.protein,
    this.fiber,
    this.sugar,
    this.sodiumMg,
    this.openFoodFactsId,
    this.imageUrl,
    this.rawResponse,
    required this.fetchedAt,
    required this.expiresAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['barcode'] = Variable<String>(barcode);
    if (!nullToAbsent || productName != null) {
      map['product_name'] = Variable<String>(productName);
    }
    if (!nullToAbsent || brand != null) {
      map['brand'] = Variable<String>(brand);
    }
    if (!nullToAbsent || ingredientsText != null) {
      map['ingredients_text'] = Variable<String>(ingredientsText);
    }
    if (!nullToAbsent || calories != null) {
      map['calories'] = Variable<double>(calories);
    }
    if (!nullToAbsent || carbs != null) {
      map['carbs'] = Variable<double>(carbs);
    }
    if (!nullToAbsent || fat != null) {
      map['fat'] = Variable<double>(fat);
    }
    if (!nullToAbsent || protein != null) {
      map['protein'] = Variable<double>(protein);
    }
    if (!nullToAbsent || fiber != null) {
      map['fiber'] = Variable<double>(fiber);
    }
    if (!nullToAbsent || sugar != null) {
      map['sugar'] = Variable<double>(sugar);
    }
    if (!nullToAbsent || sodiumMg != null) {
      map['sodium_mg'] = Variable<double>(sodiumMg);
    }
    if (!nullToAbsent || openFoodFactsId != null) {
      map['open_food_facts_id'] = Variable<String>(openFoodFactsId);
    }
    if (!nullToAbsent || imageUrl != null) {
      map['image_url'] = Variable<String>(imageUrl);
    }
    if (!nullToAbsent || rawResponse != null) {
      map['raw_response'] = Variable<String>(rawResponse);
    }
    map['fetched_at'] = Variable<int>(fetchedAt);
    map['expires_at'] = Variable<int>(expiresAt);
    return map;
  }

  FoodBarcodeCacheCompanion toCompanion(bool nullToAbsent) {
    return FoodBarcodeCacheCompanion(
      id: Value(id),
      barcode: Value(barcode),
      productName: productName == null && nullToAbsent
          ? const Value.absent()
          : Value(productName),
      brand: brand == null && nullToAbsent
          ? const Value.absent()
          : Value(brand),
      ingredientsText: ingredientsText == null && nullToAbsent
          ? const Value.absent()
          : Value(ingredientsText),
      calories: calories == null && nullToAbsent
          ? const Value.absent()
          : Value(calories),
      carbs: carbs == null && nullToAbsent
          ? const Value.absent()
          : Value(carbs),
      fat: fat == null && nullToAbsent ? const Value.absent() : Value(fat),
      protein: protein == null && nullToAbsent
          ? const Value.absent()
          : Value(protein),
      fiber: fiber == null && nullToAbsent
          ? const Value.absent()
          : Value(fiber),
      sugar: sugar == null && nullToAbsent
          ? const Value.absent()
          : Value(sugar),
      sodiumMg: sodiumMg == null && nullToAbsent
          ? const Value.absent()
          : Value(sodiumMg),
      openFoodFactsId: openFoodFactsId == null && nullToAbsent
          ? const Value.absent()
          : Value(openFoodFactsId),
      imageUrl: imageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(imageUrl),
      rawResponse: rawResponse == null && nullToAbsent
          ? const Value.absent()
          : Value(rawResponse),
      fetchedAt: Value(fetchedAt),
      expiresAt: Value(expiresAt),
    );
  }

  factory FoodBarcodeCacheRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FoodBarcodeCacheRow(
      id: serializer.fromJson<String>(json['id']),
      barcode: serializer.fromJson<String>(json['barcode']),
      productName: serializer.fromJson<String?>(json['productName']),
      brand: serializer.fromJson<String?>(json['brand']),
      ingredientsText: serializer.fromJson<String?>(json['ingredientsText']),
      calories: serializer.fromJson<double?>(json['calories']),
      carbs: serializer.fromJson<double?>(json['carbs']),
      fat: serializer.fromJson<double?>(json['fat']),
      protein: serializer.fromJson<double?>(json['protein']),
      fiber: serializer.fromJson<double?>(json['fiber']),
      sugar: serializer.fromJson<double?>(json['sugar']),
      sodiumMg: serializer.fromJson<double?>(json['sodiumMg']),
      openFoodFactsId: serializer.fromJson<String?>(json['openFoodFactsId']),
      imageUrl: serializer.fromJson<String?>(json['imageUrl']),
      rawResponse: serializer.fromJson<String?>(json['rawResponse']),
      fetchedAt: serializer.fromJson<int>(json['fetchedAt']),
      expiresAt: serializer.fromJson<int>(json['expiresAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'barcode': serializer.toJson<String>(barcode),
      'productName': serializer.toJson<String?>(productName),
      'brand': serializer.toJson<String?>(brand),
      'ingredientsText': serializer.toJson<String?>(ingredientsText),
      'calories': serializer.toJson<double?>(calories),
      'carbs': serializer.toJson<double?>(carbs),
      'fat': serializer.toJson<double?>(fat),
      'protein': serializer.toJson<double?>(protein),
      'fiber': serializer.toJson<double?>(fiber),
      'sugar': serializer.toJson<double?>(sugar),
      'sodiumMg': serializer.toJson<double?>(sodiumMg),
      'openFoodFactsId': serializer.toJson<String?>(openFoodFactsId),
      'imageUrl': serializer.toJson<String?>(imageUrl),
      'rawResponse': serializer.toJson<String?>(rawResponse),
      'fetchedAt': serializer.toJson<int>(fetchedAt),
      'expiresAt': serializer.toJson<int>(expiresAt),
    };
  }

  FoodBarcodeCacheRow copyWith({
    String? id,
    String? barcode,
    Value<String?> productName = const Value.absent(),
    Value<String?> brand = const Value.absent(),
    Value<String?> ingredientsText = const Value.absent(),
    Value<double?> calories = const Value.absent(),
    Value<double?> carbs = const Value.absent(),
    Value<double?> fat = const Value.absent(),
    Value<double?> protein = const Value.absent(),
    Value<double?> fiber = const Value.absent(),
    Value<double?> sugar = const Value.absent(),
    Value<double?> sodiumMg = const Value.absent(),
    Value<String?> openFoodFactsId = const Value.absent(),
    Value<String?> imageUrl = const Value.absent(),
    Value<String?> rawResponse = const Value.absent(),
    int? fetchedAt,
    int? expiresAt,
  }) => FoodBarcodeCacheRow(
    id: id ?? this.id,
    barcode: barcode ?? this.barcode,
    productName: productName.present ? productName.value : this.productName,
    brand: brand.present ? brand.value : this.brand,
    ingredientsText: ingredientsText.present
        ? ingredientsText.value
        : this.ingredientsText,
    calories: calories.present ? calories.value : this.calories,
    carbs: carbs.present ? carbs.value : this.carbs,
    fat: fat.present ? fat.value : this.fat,
    protein: protein.present ? protein.value : this.protein,
    fiber: fiber.present ? fiber.value : this.fiber,
    sugar: sugar.present ? sugar.value : this.sugar,
    sodiumMg: sodiumMg.present ? sodiumMg.value : this.sodiumMg,
    openFoodFactsId: openFoodFactsId.present
        ? openFoodFactsId.value
        : this.openFoodFactsId,
    imageUrl: imageUrl.present ? imageUrl.value : this.imageUrl,
    rawResponse: rawResponse.present ? rawResponse.value : this.rawResponse,
    fetchedAt: fetchedAt ?? this.fetchedAt,
    expiresAt: expiresAt ?? this.expiresAt,
  );
  FoodBarcodeCacheRow copyWithCompanion(FoodBarcodeCacheCompanion data) {
    return FoodBarcodeCacheRow(
      id: data.id.present ? data.id.value : this.id,
      barcode: data.barcode.present ? data.barcode.value : this.barcode,
      productName: data.productName.present
          ? data.productName.value
          : this.productName,
      brand: data.brand.present ? data.brand.value : this.brand,
      ingredientsText: data.ingredientsText.present
          ? data.ingredientsText.value
          : this.ingredientsText,
      calories: data.calories.present ? data.calories.value : this.calories,
      carbs: data.carbs.present ? data.carbs.value : this.carbs,
      fat: data.fat.present ? data.fat.value : this.fat,
      protein: data.protein.present ? data.protein.value : this.protein,
      fiber: data.fiber.present ? data.fiber.value : this.fiber,
      sugar: data.sugar.present ? data.sugar.value : this.sugar,
      sodiumMg: data.sodiumMg.present ? data.sodiumMg.value : this.sodiumMg,
      openFoodFactsId: data.openFoodFactsId.present
          ? data.openFoodFactsId.value
          : this.openFoodFactsId,
      imageUrl: data.imageUrl.present ? data.imageUrl.value : this.imageUrl,
      rawResponse: data.rawResponse.present
          ? data.rawResponse.value
          : this.rawResponse,
      fetchedAt: data.fetchedAt.present ? data.fetchedAt.value : this.fetchedAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FoodBarcodeCacheRow(')
          ..write('id: $id, ')
          ..write('barcode: $barcode, ')
          ..write('productName: $productName, ')
          ..write('brand: $brand, ')
          ..write('ingredientsText: $ingredientsText, ')
          ..write('calories: $calories, ')
          ..write('carbs: $carbs, ')
          ..write('fat: $fat, ')
          ..write('protein: $protein, ')
          ..write('fiber: $fiber, ')
          ..write('sugar: $sugar, ')
          ..write('sodiumMg: $sodiumMg, ')
          ..write('openFoodFactsId: $openFoodFactsId, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('rawResponse: $rawResponse, ')
          ..write('fetchedAt: $fetchedAt, ')
          ..write('expiresAt: $expiresAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    barcode,
    productName,
    brand,
    ingredientsText,
    calories,
    carbs,
    fat,
    protein,
    fiber,
    sugar,
    sodiumMg,
    openFoodFactsId,
    imageUrl,
    rawResponse,
    fetchedAt,
    expiresAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FoodBarcodeCacheRow &&
          other.id == this.id &&
          other.barcode == this.barcode &&
          other.productName == this.productName &&
          other.brand == this.brand &&
          other.ingredientsText == this.ingredientsText &&
          other.calories == this.calories &&
          other.carbs == this.carbs &&
          other.fat == this.fat &&
          other.protein == this.protein &&
          other.fiber == this.fiber &&
          other.sugar == this.sugar &&
          other.sodiumMg == this.sodiumMg &&
          other.openFoodFactsId == this.openFoodFactsId &&
          other.imageUrl == this.imageUrl &&
          other.rawResponse == this.rawResponse &&
          other.fetchedAt == this.fetchedAt &&
          other.expiresAt == this.expiresAt);
}

class FoodBarcodeCacheCompanion extends UpdateCompanion<FoodBarcodeCacheRow> {
  final Value<String> id;
  final Value<String> barcode;
  final Value<String?> productName;
  final Value<String?> brand;
  final Value<String?> ingredientsText;
  final Value<double?> calories;
  final Value<double?> carbs;
  final Value<double?> fat;
  final Value<double?> protein;
  final Value<double?> fiber;
  final Value<double?> sugar;
  final Value<double?> sodiumMg;
  final Value<String?> openFoodFactsId;
  final Value<String?> imageUrl;
  final Value<String?> rawResponse;
  final Value<int> fetchedAt;
  final Value<int> expiresAt;
  final Value<int> rowid;
  const FoodBarcodeCacheCompanion({
    this.id = const Value.absent(),
    this.barcode = const Value.absent(),
    this.productName = const Value.absent(),
    this.brand = const Value.absent(),
    this.ingredientsText = const Value.absent(),
    this.calories = const Value.absent(),
    this.carbs = const Value.absent(),
    this.fat = const Value.absent(),
    this.protein = const Value.absent(),
    this.fiber = const Value.absent(),
    this.sugar = const Value.absent(),
    this.sodiumMg = const Value.absent(),
    this.openFoodFactsId = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.rawResponse = const Value.absent(),
    this.fetchedAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FoodBarcodeCacheCompanion.insert({
    required String id,
    required String barcode,
    this.productName = const Value.absent(),
    this.brand = const Value.absent(),
    this.ingredientsText = const Value.absent(),
    this.calories = const Value.absent(),
    this.carbs = const Value.absent(),
    this.fat = const Value.absent(),
    this.protein = const Value.absent(),
    this.fiber = const Value.absent(),
    this.sugar = const Value.absent(),
    this.sodiumMg = const Value.absent(),
    this.openFoodFactsId = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.rawResponse = const Value.absent(),
    required int fetchedAt,
    required int expiresAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       barcode = Value(barcode),
       fetchedAt = Value(fetchedAt),
       expiresAt = Value(expiresAt);
  static Insertable<FoodBarcodeCacheRow> custom({
    Expression<String>? id,
    Expression<String>? barcode,
    Expression<String>? productName,
    Expression<String>? brand,
    Expression<String>? ingredientsText,
    Expression<double>? calories,
    Expression<double>? carbs,
    Expression<double>? fat,
    Expression<double>? protein,
    Expression<double>? fiber,
    Expression<double>? sugar,
    Expression<double>? sodiumMg,
    Expression<String>? openFoodFactsId,
    Expression<String>? imageUrl,
    Expression<String>? rawResponse,
    Expression<int>? fetchedAt,
    Expression<int>? expiresAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (barcode != null) 'barcode': barcode,
      if (productName != null) 'product_name': productName,
      if (brand != null) 'brand': brand,
      if (ingredientsText != null) 'ingredients_text': ingredientsText,
      if (calories != null) 'calories': calories,
      if (carbs != null) 'carbs': carbs,
      if (fat != null) 'fat': fat,
      if (protein != null) 'protein': protein,
      if (fiber != null) 'fiber': fiber,
      if (sugar != null) 'sugar': sugar,
      if (sodiumMg != null) 'sodium_mg': sodiumMg,
      if (openFoodFactsId != null) 'open_food_facts_id': openFoodFactsId,
      if (imageUrl != null) 'image_url': imageUrl,
      if (rawResponse != null) 'raw_response': rawResponse,
      if (fetchedAt != null) 'fetched_at': fetchedAt,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FoodBarcodeCacheCompanion copyWith({
    Value<String>? id,
    Value<String>? barcode,
    Value<String?>? productName,
    Value<String?>? brand,
    Value<String?>? ingredientsText,
    Value<double?>? calories,
    Value<double?>? carbs,
    Value<double?>? fat,
    Value<double?>? protein,
    Value<double?>? fiber,
    Value<double?>? sugar,
    Value<double?>? sodiumMg,
    Value<String?>? openFoodFactsId,
    Value<String?>? imageUrl,
    Value<String?>? rawResponse,
    Value<int>? fetchedAt,
    Value<int>? expiresAt,
    Value<int>? rowid,
  }) {
    return FoodBarcodeCacheCompanion(
      id: id ?? this.id,
      barcode: barcode ?? this.barcode,
      productName: productName ?? this.productName,
      brand: brand ?? this.brand,
      ingredientsText: ingredientsText ?? this.ingredientsText,
      calories: calories ?? this.calories,
      carbs: carbs ?? this.carbs,
      fat: fat ?? this.fat,
      protein: protein ?? this.protein,
      fiber: fiber ?? this.fiber,
      sugar: sugar ?? this.sugar,
      sodiumMg: sodiumMg ?? this.sodiumMg,
      openFoodFactsId: openFoodFactsId ?? this.openFoodFactsId,
      imageUrl: imageUrl ?? this.imageUrl,
      rawResponse: rawResponse ?? this.rawResponse,
      fetchedAt: fetchedAt ?? this.fetchedAt,
      expiresAt: expiresAt ?? this.expiresAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (barcode.present) {
      map['barcode'] = Variable<String>(barcode.value);
    }
    if (productName.present) {
      map['product_name'] = Variable<String>(productName.value);
    }
    if (brand.present) {
      map['brand'] = Variable<String>(brand.value);
    }
    if (ingredientsText.present) {
      map['ingredients_text'] = Variable<String>(ingredientsText.value);
    }
    if (calories.present) {
      map['calories'] = Variable<double>(calories.value);
    }
    if (carbs.present) {
      map['carbs'] = Variable<double>(carbs.value);
    }
    if (fat.present) {
      map['fat'] = Variable<double>(fat.value);
    }
    if (protein.present) {
      map['protein'] = Variable<double>(protein.value);
    }
    if (fiber.present) {
      map['fiber'] = Variable<double>(fiber.value);
    }
    if (sugar.present) {
      map['sugar'] = Variable<double>(sugar.value);
    }
    if (sodiumMg.present) {
      map['sodium_mg'] = Variable<double>(sodiumMg.value);
    }
    if (openFoodFactsId.present) {
      map['open_food_facts_id'] = Variable<String>(openFoodFactsId.value);
    }
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (rawResponse.present) {
      map['raw_response'] = Variable<String>(rawResponse.value);
    }
    if (fetchedAt.present) {
      map['fetched_at'] = Variable<int>(fetchedAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<int>(expiresAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FoodBarcodeCacheCompanion(')
          ..write('id: $id, ')
          ..write('barcode: $barcode, ')
          ..write('productName: $productName, ')
          ..write('brand: $brand, ')
          ..write('ingredientsText: $ingredientsText, ')
          ..write('calories: $calories, ')
          ..write('carbs: $carbs, ')
          ..write('fat: $fat, ')
          ..write('protein: $protein, ')
          ..write('fiber: $fiber, ')
          ..write('sugar: $sugar, ')
          ..write('sodiumMg: $sodiumMg, ')
          ..write('openFoodFactsId: $openFoodFactsId, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('rawResponse: $rawResponse, ')
          ..write('fetchedAt: $fetchedAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FoodLogsTable extends FoodLogs
    with TableInfo<$FoodLogsTable, FoodLogRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FoodLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<int> timestamp = GeneratedColumn<int>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _mealTypeMeta = const VerificationMeta(
    'mealType',
  );
  @override
  late final GeneratedColumn<int> mealType = GeneratedColumn<int>(
    'meal_type',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _foodItemIdsMeta = const VerificationMeta(
    'foodItemIds',
  );
  @override
  late final GeneratedColumn<String> foodItemIds = GeneratedColumn<String>(
    'food_item_ids',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _adHocItemsMeta = const VerificationMeta(
    'adHocItems',
  );
  @override
  late final GeneratedColumn<String> adHocItems = GeneratedColumn<String>(
    'ad_hoc_items',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    timestamp,
    mealType,
    foodItemIds,
    adHocItems,
    notes,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'food_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<FoodLogRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('meal_type')) {
      context.handle(
        _mealTypeMeta,
        mealType.isAcceptableOrUnknown(data['meal_type']!, _mealTypeMeta),
      );
    }
    if (data.containsKey('food_item_ids')) {
      context.handle(
        _foodItemIdsMeta,
        foodItemIds.isAcceptableOrUnknown(
          data['food_item_ids']!,
          _foodItemIdsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_foodItemIdsMeta);
    }
    if (data.containsKey('ad_hoc_items')) {
      context.handle(
        _adHocItemsMeta,
        adHocItems.isAcceptableOrUnknown(
          data['ad_hoc_items']!,
          _adHocItemsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_adHocItemsMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FoodLogRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FoodLogRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}timestamp'],
      )!,
      mealType: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}meal_type'],
      ),
      foodItemIds: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}food_item_ids'],
      )!,
      adHocItems: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ad_hoc_items'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $FoodLogsTable createAlias(String alias) {
    return $FoodLogsTable(attachedDatabase, alias);
  }
}

class FoodLogRow extends DataClass implements Insertable<FoodLogRow> {
  final String id;
  final String clientId;
  final String profileId;
  final int timestamp;
  final int? mealType;
  final String foodItemIds;
  final String adHocItems;
  final String? notes;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const FoodLogRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.timestamp,
    this.mealType,
    required this.foodItemIds,
    required this.adHocItems,
    this.notes,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['timestamp'] = Variable<int>(timestamp);
    if (!nullToAbsent || mealType != null) {
      map['meal_type'] = Variable<int>(mealType);
    }
    map['food_item_ids'] = Variable<String>(foodItemIds);
    map['ad_hoc_items'] = Variable<String>(adHocItems);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  FoodLogsCompanion toCompanion(bool nullToAbsent) {
    return FoodLogsCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      timestamp: Value(timestamp),
      mealType: mealType == null && nullToAbsent
          ? const Value.absent()
          : Value(mealType),
      foodItemIds: Value(foodItemIds),
      adHocItems: Value(adHocItems),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory FoodLogRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FoodLogRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      timestamp: serializer.fromJson<int>(json['timestamp']),
      mealType: serializer.fromJson<int?>(json['mealType']),
      foodItemIds: serializer.fromJson<String>(json['foodItemIds']),
      adHocItems: serializer.fromJson<String>(json['adHocItems']),
      notes: serializer.fromJson<String?>(json['notes']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'timestamp': serializer.toJson<int>(timestamp),
      'mealType': serializer.toJson<int?>(mealType),
      'foodItemIds': serializer.toJson<String>(foodItemIds),
      'adHocItems': serializer.toJson<String>(adHocItems),
      'notes': serializer.toJson<String?>(notes),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  FoodLogRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    int? timestamp,
    Value<int?> mealType = const Value.absent(),
    String? foodItemIds,
    String? adHocItems,
    Value<String?> notes = const Value.absent(),
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => FoodLogRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    timestamp: timestamp ?? this.timestamp,
    mealType: mealType.present ? mealType.value : this.mealType,
    foodItemIds: foodItemIds ?? this.foodItemIds,
    adHocItems: adHocItems ?? this.adHocItems,
    notes: notes.present ? notes.value : this.notes,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  FoodLogRow copyWithCompanion(FoodLogsCompanion data) {
    return FoodLogRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      mealType: data.mealType.present ? data.mealType.value : this.mealType,
      foodItemIds: data.foodItemIds.present
          ? data.foodItemIds.value
          : this.foodItemIds,
      adHocItems: data.adHocItems.present
          ? data.adHocItems.value
          : this.adHocItems,
      notes: data.notes.present ? data.notes.value : this.notes,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FoodLogRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('timestamp: $timestamp, ')
          ..write('mealType: $mealType, ')
          ..write('foodItemIds: $foodItemIds, ')
          ..write('adHocItems: $adHocItems, ')
          ..write('notes: $notes, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    clientId,
    profileId,
    timestamp,
    mealType,
    foodItemIds,
    adHocItems,
    notes,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FoodLogRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.timestamp == this.timestamp &&
          other.mealType == this.mealType &&
          other.foodItemIds == this.foodItemIds &&
          other.adHocItems == this.adHocItems &&
          other.notes == this.notes &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class FoodLogsCompanion extends UpdateCompanion<FoodLogRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<int> timestamp;
  final Value<int?> mealType;
  final Value<String> foodItemIds;
  final Value<String> adHocItems;
  final Value<String?> notes;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const FoodLogsCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.mealType = const Value.absent(),
    this.foodItemIds = const Value.absent(),
    this.adHocItems = const Value.absent(),
    this.notes = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FoodLogsCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required int timestamp,
    this.mealType = const Value.absent(),
    required String foodItemIds,
    required String adHocItems,
    this.notes = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       timestamp = Value(timestamp),
       foodItemIds = Value(foodItemIds),
       adHocItems = Value(adHocItems),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<FoodLogRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<int>? timestamp,
    Expression<int>? mealType,
    Expression<String>? foodItemIds,
    Expression<String>? adHocItems,
    Expression<String>? notes,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (timestamp != null) 'timestamp': timestamp,
      if (mealType != null) 'meal_type': mealType,
      if (foodItemIds != null) 'food_item_ids': foodItemIds,
      if (adHocItems != null) 'ad_hoc_items': adHocItems,
      if (notes != null) 'notes': notes,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FoodLogsCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<int>? timestamp,
    Value<int?>? mealType,
    Value<String>? foodItemIds,
    Value<String>? adHocItems,
    Value<String?>? notes,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return FoodLogsCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      timestamp: timestamp ?? this.timestamp,
      mealType: mealType ?? this.mealType,
      foodItemIds: foodItemIds ?? this.foodItemIds,
      adHocItems: adHocItems ?? this.adHocItems,
      notes: notes ?? this.notes,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<int>(timestamp.value);
    }
    if (mealType.present) {
      map['meal_type'] = Variable<int>(mealType.value);
    }
    if (foodItemIds.present) {
      map['food_item_ids'] = Variable<String>(foodItemIds.value);
    }
    if (adHocItems.present) {
      map['ad_hoc_items'] = Variable<String>(adHocItems.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FoodLogsCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('timestamp: $timestamp, ')
          ..write('mealType: $mealType, ')
          ..write('foodItemIds: $foodItemIds, ')
          ..write('adHocItems: $adHocItems, ')
          ..write('notes: $notes, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $JournalEntriesTable extends JournalEntries
    with TableInfo<$JournalEntriesTable, JournalEntryRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $JournalEntriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<int> timestamp = GeneratedColumn<int>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contentMeta = const VerificationMeta(
    'content',
  );
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
    'content',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _moodMeta = const VerificationMeta('mood');
  @override
  late final GeneratedColumn<int> mood = GeneratedColumn<int>(
    'mood',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _tagsMeta = const VerificationMeta('tags');
  @override
  late final GeneratedColumn<String> tags = GeneratedColumn<String>(
    'tags',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _audioUrlMeta = const VerificationMeta(
    'audioUrl',
  );
  @override
  late final GeneratedColumn<String> audioUrl = GeneratedColumn<String>(
    'audio_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    timestamp,
    content,
    title,
    mood,
    tags,
    audioUrl,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'journal_entries';
  @override
  VerificationContext validateIntegrity(
    Insertable<JournalEntryRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('content')) {
      context.handle(
        _contentMeta,
        content.isAcceptableOrUnknown(data['content']!, _contentMeta),
      );
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    }
    if (data.containsKey('mood')) {
      context.handle(
        _moodMeta,
        mood.isAcceptableOrUnknown(data['mood']!, _moodMeta),
      );
    }
    if (data.containsKey('tags')) {
      context.handle(
        _tagsMeta,
        tags.isAcceptableOrUnknown(data['tags']!, _tagsMeta),
      );
    }
    if (data.containsKey('audio_url')) {
      context.handle(
        _audioUrlMeta,
        audioUrl.isAcceptableOrUnknown(data['audio_url']!, _audioUrlMeta),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  JournalEntryRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return JournalEntryRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}timestamp'],
      )!,
      content: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}content'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      ),
      mood: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}mood'],
      ),
      tags: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tags'],
      ),
      audioUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}audio_url'],
      ),
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $JournalEntriesTable createAlias(String alias) {
    return $JournalEntriesTable(attachedDatabase, alias);
  }
}

class JournalEntryRow extends DataClass implements Insertable<JournalEntryRow> {
  final String id;
  final String clientId;
  final String profileId;
  final int timestamp;
  final String content;
  final String? title;
  final int? mood;
  final String? tags;
  final String? audioUrl;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const JournalEntryRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.timestamp,
    required this.content,
    this.title,
    this.mood,
    this.tags,
    this.audioUrl,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['timestamp'] = Variable<int>(timestamp);
    map['content'] = Variable<String>(content);
    if (!nullToAbsent || title != null) {
      map['title'] = Variable<String>(title);
    }
    if (!nullToAbsent || mood != null) {
      map['mood'] = Variable<int>(mood);
    }
    if (!nullToAbsent || tags != null) {
      map['tags'] = Variable<String>(tags);
    }
    if (!nullToAbsent || audioUrl != null) {
      map['audio_url'] = Variable<String>(audioUrl);
    }
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  JournalEntriesCompanion toCompanion(bool nullToAbsent) {
    return JournalEntriesCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      timestamp: Value(timestamp),
      content: Value(content),
      title: title == null && nullToAbsent
          ? const Value.absent()
          : Value(title),
      mood: mood == null && nullToAbsent ? const Value.absent() : Value(mood),
      tags: tags == null && nullToAbsent ? const Value.absent() : Value(tags),
      audioUrl: audioUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(audioUrl),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory JournalEntryRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return JournalEntryRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      timestamp: serializer.fromJson<int>(json['timestamp']),
      content: serializer.fromJson<String>(json['content']),
      title: serializer.fromJson<String?>(json['title']),
      mood: serializer.fromJson<int?>(json['mood']),
      tags: serializer.fromJson<String?>(json['tags']),
      audioUrl: serializer.fromJson<String?>(json['audioUrl']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'timestamp': serializer.toJson<int>(timestamp),
      'content': serializer.toJson<String>(content),
      'title': serializer.toJson<String?>(title),
      'mood': serializer.toJson<int?>(mood),
      'tags': serializer.toJson<String?>(tags),
      'audioUrl': serializer.toJson<String?>(audioUrl),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  JournalEntryRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    int? timestamp,
    String? content,
    Value<String?> title = const Value.absent(),
    Value<int?> mood = const Value.absent(),
    Value<String?> tags = const Value.absent(),
    Value<String?> audioUrl = const Value.absent(),
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => JournalEntryRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    timestamp: timestamp ?? this.timestamp,
    content: content ?? this.content,
    title: title.present ? title.value : this.title,
    mood: mood.present ? mood.value : this.mood,
    tags: tags.present ? tags.value : this.tags,
    audioUrl: audioUrl.present ? audioUrl.value : this.audioUrl,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  JournalEntryRow copyWithCompanion(JournalEntriesCompanion data) {
    return JournalEntryRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      content: data.content.present ? data.content.value : this.content,
      title: data.title.present ? data.title.value : this.title,
      mood: data.mood.present ? data.mood.value : this.mood,
      tags: data.tags.present ? data.tags.value : this.tags,
      audioUrl: data.audioUrl.present ? data.audioUrl.value : this.audioUrl,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('JournalEntryRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('timestamp: $timestamp, ')
          ..write('content: $content, ')
          ..write('title: $title, ')
          ..write('mood: $mood, ')
          ..write('tags: $tags, ')
          ..write('audioUrl: $audioUrl, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    clientId,
    profileId,
    timestamp,
    content,
    title,
    mood,
    tags,
    audioUrl,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is JournalEntryRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.timestamp == this.timestamp &&
          other.content == this.content &&
          other.title == this.title &&
          other.mood == this.mood &&
          other.tags == this.tags &&
          other.audioUrl == this.audioUrl &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class JournalEntriesCompanion extends UpdateCompanion<JournalEntryRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<int> timestamp;
  final Value<String> content;
  final Value<String?> title;
  final Value<int?> mood;
  final Value<String?> tags;
  final Value<String?> audioUrl;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const JournalEntriesCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.content = const Value.absent(),
    this.title = const Value.absent(),
    this.mood = const Value.absent(),
    this.tags = const Value.absent(),
    this.audioUrl = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  JournalEntriesCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required int timestamp,
    required String content,
    this.title = const Value.absent(),
    this.mood = const Value.absent(),
    this.tags = const Value.absent(),
    this.audioUrl = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       timestamp = Value(timestamp),
       content = Value(content),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<JournalEntryRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<int>? timestamp,
    Expression<String>? content,
    Expression<String>? title,
    Expression<int>? mood,
    Expression<String>? tags,
    Expression<String>? audioUrl,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (timestamp != null) 'timestamp': timestamp,
      if (content != null) 'content': content,
      if (title != null) 'title': title,
      if (mood != null) 'mood': mood,
      if (tags != null) 'tags': tags,
      if (audioUrl != null) 'audio_url': audioUrl,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  JournalEntriesCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<int>? timestamp,
    Value<String>? content,
    Value<String?>? title,
    Value<int?>? mood,
    Value<String?>? tags,
    Value<String?>? audioUrl,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return JournalEntriesCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      timestamp: timestamp ?? this.timestamp,
      content: content ?? this.content,
      title: title ?? this.title,
      mood: mood ?? this.mood,
      tags: tags ?? this.tags,
      audioUrl: audioUrl ?? this.audioUrl,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<int>(timestamp.value);
    }
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (mood.present) {
      map['mood'] = Variable<int>(mood.value);
    }
    if (tags.present) {
      map['tags'] = Variable<String>(tags.value);
    }
    if (audioUrl.present) {
      map['audio_url'] = Variable<String>(audioUrl.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('JournalEntriesCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('timestamp: $timestamp, ')
          ..write('content: $content, ')
          ..write('title: $title, ')
          ..write('mood: $mood, ')
          ..write('tags: $tags, ')
          ..write('audioUrl: $audioUrl, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PhotoAreasTable extends PhotoAreas
    with TableInfo<$PhotoAreasTable, PhotoAreaRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PhotoAreasTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _consistencyNotesMeta = const VerificationMeta(
    'consistencyNotes',
  );
  @override
  late final GeneratedColumn<String> consistencyNotes = GeneratedColumn<String>(
    'consistency_notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isArchivedMeta = const VerificationMeta(
    'isArchived',
  );
  @override
  late final GeneratedColumn<bool> isArchived = GeneratedColumn<bool>(
    'is_archived',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_archived" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    name,
    description,
    consistencyNotes,
    sortOrder,
    isArchived,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'photo_areas';
  @override
  VerificationContext validateIntegrity(
    Insertable<PhotoAreaRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('consistency_notes')) {
      context.handle(
        _consistencyNotesMeta,
        consistencyNotes.isAcceptableOrUnknown(
          data['consistency_notes']!,
          _consistencyNotesMeta,
        ),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('is_archived')) {
      context.handle(
        _isArchivedMeta,
        isArchived.isAcceptableOrUnknown(data['is_archived']!, _isArchivedMeta),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PhotoAreaRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PhotoAreaRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      consistencyNotes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}consistency_notes'],
      ),
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      isArchived: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_archived'],
      )!,
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $PhotoAreasTable createAlias(String alias) {
    return $PhotoAreasTable(attachedDatabase, alias);
  }
}

class PhotoAreaRow extends DataClass implements Insertable<PhotoAreaRow> {
  final String id;
  final String clientId;
  final String profileId;
  final String name;
  final String? description;
  final String? consistencyNotes;
  final int sortOrder;
  final bool isArchived;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const PhotoAreaRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.name,
    this.description,
    this.consistencyNotes,
    required this.sortOrder,
    required this.isArchived,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || consistencyNotes != null) {
      map['consistency_notes'] = Variable<String>(consistencyNotes);
    }
    map['sort_order'] = Variable<int>(sortOrder);
    map['is_archived'] = Variable<bool>(isArchived);
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  PhotoAreasCompanion toCompanion(bool nullToAbsent) {
    return PhotoAreasCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      consistencyNotes: consistencyNotes == null && nullToAbsent
          ? const Value.absent()
          : Value(consistencyNotes),
      sortOrder: Value(sortOrder),
      isArchived: Value(isArchived),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory PhotoAreaRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PhotoAreaRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      consistencyNotes: serializer.fromJson<String?>(json['consistencyNotes']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      isArchived: serializer.fromJson<bool>(json['isArchived']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'consistencyNotes': serializer.toJson<String?>(consistencyNotes),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'isArchived': serializer.toJson<bool>(isArchived),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  PhotoAreaRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    String? name,
    Value<String?> description = const Value.absent(),
    Value<String?> consistencyNotes = const Value.absent(),
    int? sortOrder,
    bool? isArchived,
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => PhotoAreaRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    consistencyNotes: consistencyNotes.present
        ? consistencyNotes.value
        : this.consistencyNotes,
    sortOrder: sortOrder ?? this.sortOrder,
    isArchived: isArchived ?? this.isArchived,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  PhotoAreaRow copyWithCompanion(PhotoAreasCompanion data) {
    return PhotoAreaRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      consistencyNotes: data.consistencyNotes.present
          ? data.consistencyNotes.value
          : this.consistencyNotes,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      isArchived: data.isArchived.present
          ? data.isArchived.value
          : this.isArchived,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PhotoAreaRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('consistencyNotes: $consistencyNotes, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isArchived: $isArchived, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    clientId,
    profileId,
    name,
    description,
    consistencyNotes,
    sortOrder,
    isArchived,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PhotoAreaRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.name == this.name &&
          other.description == this.description &&
          other.consistencyNotes == this.consistencyNotes &&
          other.sortOrder == this.sortOrder &&
          other.isArchived == this.isArchived &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class PhotoAreasCompanion extends UpdateCompanion<PhotoAreaRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<String> name;
  final Value<String?> description;
  final Value<String?> consistencyNotes;
  final Value<int> sortOrder;
  final Value<bool> isArchived;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const PhotoAreasCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.consistencyNotes = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isArchived = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PhotoAreasCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required String name,
    this.description = const Value.absent(),
    this.consistencyNotes = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isArchived = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       name = Value(name),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<PhotoAreaRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<String>? name,
    Expression<String>? description,
    Expression<String>? consistencyNotes,
    Expression<int>? sortOrder,
    Expression<bool>? isArchived,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (consistencyNotes != null) 'consistency_notes': consistencyNotes,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (isArchived != null) 'is_archived': isArchived,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PhotoAreasCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<String>? name,
    Value<String?>? description,
    Value<String?>? consistencyNotes,
    Value<int>? sortOrder,
    Value<bool>? isArchived,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return PhotoAreasCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      name: name ?? this.name,
      description: description ?? this.description,
      consistencyNotes: consistencyNotes ?? this.consistencyNotes,
      sortOrder: sortOrder ?? this.sortOrder,
      isArchived: isArchived ?? this.isArchived,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (consistencyNotes.present) {
      map['consistency_notes'] = Variable<String>(consistencyNotes.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (isArchived.present) {
      map['is_archived'] = Variable<bool>(isArchived.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PhotoAreasCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('consistencyNotes: $consistencyNotes, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isArchived: $isArchived, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PhotoEntriesTable extends PhotoEntries
    with TableInfo<$PhotoEntriesTable, PhotoEntryRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PhotoEntriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _photoAreaIdMeta = const VerificationMeta(
    'photoAreaId',
  );
  @override
  late final GeneratedColumn<String> photoAreaId = GeneratedColumn<String>(
    'photo_area_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<int> timestamp = GeneratedColumn<int>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _filePathMeta = const VerificationMeta(
    'filePath',
  );
  @override
  late final GeneratedColumn<String> filePath = GeneratedColumn<String>(
    'file_path',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cloudStorageUrlMeta = const VerificationMeta(
    'cloudStorageUrl',
  );
  @override
  late final GeneratedColumn<String> cloudStorageUrl = GeneratedColumn<String>(
    'cloud_storage_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fileHashMeta = const VerificationMeta(
    'fileHash',
  );
  @override
  late final GeneratedColumn<String> fileHash = GeneratedColumn<String>(
    'file_hash',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fileSizeBytesMeta = const VerificationMeta(
    'fileSizeBytes',
  );
  @override
  late final GeneratedColumn<int> fileSizeBytes = GeneratedColumn<int>(
    'file_size_bytes',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isFileUploadedMeta = const VerificationMeta(
    'isFileUploaded',
  );
  @override
  late final GeneratedColumn<bool> isFileUploaded = GeneratedColumn<bool>(
    'is_file_uploaded',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_file_uploaded" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    profileId,
    photoAreaId,
    timestamp,
    filePath,
    notes,
    cloudStorageUrl,
    fileHash,
    fileSizeBytes,
    isFileUploaded,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'photo_entries';
  @override
  VerificationContext validateIntegrity(
    Insertable<PhotoEntryRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('photo_area_id')) {
      context.handle(
        _photoAreaIdMeta,
        photoAreaId.isAcceptableOrUnknown(
          data['photo_area_id']!,
          _photoAreaIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_photoAreaIdMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('file_path')) {
      context.handle(
        _filePathMeta,
        filePath.isAcceptableOrUnknown(data['file_path']!, _filePathMeta),
      );
    } else if (isInserting) {
      context.missing(_filePathMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('cloud_storage_url')) {
      context.handle(
        _cloudStorageUrlMeta,
        cloudStorageUrl.isAcceptableOrUnknown(
          data['cloud_storage_url']!,
          _cloudStorageUrlMeta,
        ),
      );
    }
    if (data.containsKey('file_hash')) {
      context.handle(
        _fileHashMeta,
        fileHash.isAcceptableOrUnknown(data['file_hash']!, _fileHashMeta),
      );
    }
    if (data.containsKey('file_size_bytes')) {
      context.handle(
        _fileSizeBytesMeta,
        fileSizeBytes.isAcceptableOrUnknown(
          data['file_size_bytes']!,
          _fileSizeBytesMeta,
        ),
      );
    }
    if (data.containsKey('is_file_uploaded')) {
      context.handle(
        _isFileUploadedMeta,
        isFileUploaded.isAcceptableOrUnknown(
          data['is_file_uploaded']!,
          _isFileUploadedMeta,
        ),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PhotoEntryRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PhotoEntryRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      photoAreaId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}photo_area_id'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}timestamp'],
      )!,
      filePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}file_path'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      cloudStorageUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cloud_storage_url'],
      ),
      fileHash: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}file_hash'],
      ),
      fileSizeBytes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}file_size_bytes'],
      ),
      isFileUploaded: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_file_uploaded'],
      )!,
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $PhotoEntriesTable createAlias(String alias) {
    return $PhotoEntriesTable(attachedDatabase, alias);
  }
}

class PhotoEntryRow extends DataClass implements Insertable<PhotoEntryRow> {
  final String id;
  final String clientId;
  final String profileId;
  final String photoAreaId;
  final int timestamp;
  final String filePath;
  final String? notes;
  final String? cloudStorageUrl;
  final String? fileHash;
  final int? fileSizeBytes;
  final bool isFileUploaded;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const PhotoEntryRow({
    required this.id,
    required this.clientId,
    required this.profileId,
    required this.photoAreaId,
    required this.timestamp,
    required this.filePath,
    this.notes,
    this.cloudStorageUrl,
    this.fileHash,
    this.fileSizeBytes,
    required this.isFileUploaded,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['profile_id'] = Variable<String>(profileId);
    map['photo_area_id'] = Variable<String>(photoAreaId);
    map['timestamp'] = Variable<int>(timestamp);
    map['file_path'] = Variable<String>(filePath);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    if (!nullToAbsent || cloudStorageUrl != null) {
      map['cloud_storage_url'] = Variable<String>(cloudStorageUrl);
    }
    if (!nullToAbsent || fileHash != null) {
      map['file_hash'] = Variable<String>(fileHash);
    }
    if (!nullToAbsent || fileSizeBytes != null) {
      map['file_size_bytes'] = Variable<int>(fileSizeBytes);
    }
    map['is_file_uploaded'] = Variable<bool>(isFileUploaded);
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  PhotoEntriesCompanion toCompanion(bool nullToAbsent) {
    return PhotoEntriesCompanion(
      id: Value(id),
      clientId: Value(clientId),
      profileId: Value(profileId),
      photoAreaId: Value(photoAreaId),
      timestamp: Value(timestamp),
      filePath: Value(filePath),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      cloudStorageUrl: cloudStorageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(cloudStorageUrl),
      fileHash: fileHash == null && nullToAbsent
          ? const Value.absent()
          : Value(fileHash),
      fileSizeBytes: fileSizeBytes == null && nullToAbsent
          ? const Value.absent()
          : Value(fileSizeBytes),
      isFileUploaded: Value(isFileUploaded),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory PhotoEntryRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PhotoEntryRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      photoAreaId: serializer.fromJson<String>(json['photoAreaId']),
      timestamp: serializer.fromJson<int>(json['timestamp']),
      filePath: serializer.fromJson<String>(json['filePath']),
      notes: serializer.fromJson<String?>(json['notes']),
      cloudStorageUrl: serializer.fromJson<String?>(json['cloudStorageUrl']),
      fileHash: serializer.fromJson<String?>(json['fileHash']),
      fileSizeBytes: serializer.fromJson<int?>(json['fileSizeBytes']),
      isFileUploaded: serializer.fromJson<bool>(json['isFileUploaded']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'profileId': serializer.toJson<String>(profileId),
      'photoAreaId': serializer.toJson<String>(photoAreaId),
      'timestamp': serializer.toJson<int>(timestamp),
      'filePath': serializer.toJson<String>(filePath),
      'notes': serializer.toJson<String?>(notes),
      'cloudStorageUrl': serializer.toJson<String?>(cloudStorageUrl),
      'fileHash': serializer.toJson<String?>(fileHash),
      'fileSizeBytes': serializer.toJson<int?>(fileSizeBytes),
      'isFileUploaded': serializer.toJson<bool>(isFileUploaded),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  PhotoEntryRow copyWith({
    String? id,
    String? clientId,
    String? profileId,
    String? photoAreaId,
    int? timestamp,
    String? filePath,
    Value<String?> notes = const Value.absent(),
    Value<String?> cloudStorageUrl = const Value.absent(),
    Value<String?> fileHash = const Value.absent(),
    Value<int?> fileSizeBytes = const Value.absent(),
    bool? isFileUploaded,
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => PhotoEntryRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    profileId: profileId ?? this.profileId,
    photoAreaId: photoAreaId ?? this.photoAreaId,
    timestamp: timestamp ?? this.timestamp,
    filePath: filePath ?? this.filePath,
    notes: notes.present ? notes.value : this.notes,
    cloudStorageUrl: cloudStorageUrl.present
        ? cloudStorageUrl.value
        : this.cloudStorageUrl,
    fileHash: fileHash.present ? fileHash.value : this.fileHash,
    fileSizeBytes: fileSizeBytes.present
        ? fileSizeBytes.value
        : this.fileSizeBytes,
    isFileUploaded: isFileUploaded ?? this.isFileUploaded,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  PhotoEntryRow copyWithCompanion(PhotoEntriesCompanion data) {
    return PhotoEntryRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      photoAreaId: data.photoAreaId.present
          ? data.photoAreaId.value
          : this.photoAreaId,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      filePath: data.filePath.present ? data.filePath.value : this.filePath,
      notes: data.notes.present ? data.notes.value : this.notes,
      cloudStorageUrl: data.cloudStorageUrl.present
          ? data.cloudStorageUrl.value
          : this.cloudStorageUrl,
      fileHash: data.fileHash.present ? data.fileHash.value : this.fileHash,
      fileSizeBytes: data.fileSizeBytes.present
          ? data.fileSizeBytes.value
          : this.fileSizeBytes,
      isFileUploaded: data.isFileUploaded.present
          ? data.isFileUploaded.value
          : this.isFileUploaded,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PhotoEntryRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('photoAreaId: $photoAreaId, ')
          ..write('timestamp: $timestamp, ')
          ..write('filePath: $filePath, ')
          ..write('notes: $notes, ')
          ..write('cloudStorageUrl: $cloudStorageUrl, ')
          ..write('fileHash: $fileHash, ')
          ..write('fileSizeBytes: $fileSizeBytes, ')
          ..write('isFileUploaded: $isFileUploaded, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    clientId,
    profileId,
    photoAreaId,
    timestamp,
    filePath,
    notes,
    cloudStorageUrl,
    fileHash,
    fileSizeBytes,
    isFileUploaded,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PhotoEntryRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.profileId == this.profileId &&
          other.photoAreaId == this.photoAreaId &&
          other.timestamp == this.timestamp &&
          other.filePath == this.filePath &&
          other.notes == this.notes &&
          other.cloudStorageUrl == this.cloudStorageUrl &&
          other.fileHash == this.fileHash &&
          other.fileSizeBytes == this.fileSizeBytes &&
          other.isFileUploaded == this.isFileUploaded &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class PhotoEntriesCompanion extends UpdateCompanion<PhotoEntryRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> profileId;
  final Value<String> photoAreaId;
  final Value<int> timestamp;
  final Value<String> filePath;
  final Value<String?> notes;
  final Value<String?> cloudStorageUrl;
  final Value<String?> fileHash;
  final Value<int?> fileSizeBytes;
  final Value<bool> isFileUploaded;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const PhotoEntriesCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.photoAreaId = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.filePath = const Value.absent(),
    this.notes = const Value.absent(),
    this.cloudStorageUrl = const Value.absent(),
    this.fileHash = const Value.absent(),
    this.fileSizeBytes = const Value.absent(),
    this.isFileUploaded = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PhotoEntriesCompanion.insert({
    required String id,
    required String clientId,
    required String profileId,
    required String photoAreaId,
    required int timestamp,
    required String filePath,
    this.notes = const Value.absent(),
    this.cloudStorageUrl = const Value.absent(),
    this.fileHash = const Value.absent(),
    this.fileSizeBytes = const Value.absent(),
    this.isFileUploaded = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       profileId = Value(profileId),
       photoAreaId = Value(photoAreaId),
       timestamp = Value(timestamp),
       filePath = Value(filePath),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<PhotoEntryRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? profileId,
    Expression<String>? photoAreaId,
    Expression<int>? timestamp,
    Expression<String>? filePath,
    Expression<String>? notes,
    Expression<String>? cloudStorageUrl,
    Expression<String>? fileHash,
    Expression<int>? fileSizeBytes,
    Expression<bool>? isFileUploaded,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (profileId != null) 'profile_id': profileId,
      if (photoAreaId != null) 'photo_area_id': photoAreaId,
      if (timestamp != null) 'timestamp': timestamp,
      if (filePath != null) 'file_path': filePath,
      if (notes != null) 'notes': notes,
      if (cloudStorageUrl != null) 'cloud_storage_url': cloudStorageUrl,
      if (fileHash != null) 'file_hash': fileHash,
      if (fileSizeBytes != null) 'file_size_bytes': fileSizeBytes,
      if (isFileUploaded != null) 'is_file_uploaded': isFileUploaded,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PhotoEntriesCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? profileId,
    Value<String>? photoAreaId,
    Value<int>? timestamp,
    Value<String>? filePath,
    Value<String?>? notes,
    Value<String?>? cloudStorageUrl,
    Value<String?>? fileHash,
    Value<int?>? fileSizeBytes,
    Value<bool>? isFileUploaded,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return PhotoEntriesCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      profileId: profileId ?? this.profileId,
      photoAreaId: photoAreaId ?? this.photoAreaId,
      timestamp: timestamp ?? this.timestamp,
      filePath: filePath ?? this.filePath,
      notes: notes ?? this.notes,
      cloudStorageUrl: cloudStorageUrl ?? this.cloudStorageUrl,
      fileHash: fileHash ?? this.fileHash,
      fileSizeBytes: fileSizeBytes ?? this.fileSizeBytes,
      isFileUploaded: isFileUploaded ?? this.isFileUploaded,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (photoAreaId.present) {
      map['photo_area_id'] = Variable<String>(photoAreaId.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<int>(timestamp.value);
    }
    if (filePath.present) {
      map['file_path'] = Variable<String>(filePath.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (cloudStorageUrl.present) {
      map['cloud_storage_url'] = Variable<String>(cloudStorageUrl.value);
    }
    if (fileHash.present) {
      map['file_hash'] = Variable<String>(fileHash.value);
    }
    if (fileSizeBytes.present) {
      map['file_size_bytes'] = Variable<int>(fileSizeBytes.value);
    }
    if (isFileUploaded.present) {
      map['is_file_uploaded'] = Variable<bool>(isFileUploaded.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PhotoEntriesCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('profileId: $profileId, ')
          ..write('photoAreaId: $photoAreaId, ')
          ..write('timestamp: $timestamp, ')
          ..write('filePath: $filePath, ')
          ..write('notes: $notes, ')
          ..write('cloudStorageUrl: $cloudStorageUrl, ')
          ..write('fileHash: $fileHash, ')
          ..write('fileSizeBytes: $fileSizeBytes, ')
          ..write('isFileUploaded: $isFileUploaded, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProfilesTable extends Profiles
    with TableInfo<$ProfilesTable, ProfileRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProfilesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _clientIdMeta = const VerificationMeta(
    'clientId',
  );
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
    'client_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _birthDateMeta = const VerificationMeta(
    'birthDate',
  );
  @override
  late final GeneratedColumn<int> birthDate = GeneratedColumn<int>(
    'birth_date',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _biologicalSexMeta = const VerificationMeta(
    'biologicalSex',
  );
  @override
  late final GeneratedColumn<int> biologicalSex = GeneratedColumn<int>(
    'biological_sex',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _ethnicityMeta = const VerificationMeta(
    'ethnicity',
  );
  @override
  late final GeneratedColumn<String> ethnicity = GeneratedColumn<String>(
    'ethnicity',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _dietTypeMeta = const VerificationMeta(
    'dietType',
  );
  @override
  late final GeneratedColumn<int> dietType = GeneratedColumn<int>(
    'diet_type',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _dietDescriptionMeta = const VerificationMeta(
    'dietDescription',
  );
  @override
  late final GeneratedColumn<String> dietDescription = GeneratedColumn<String>(
    'diet_description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncCreatedAtMeta = const VerificationMeta(
    'syncCreatedAt',
  );
  @override
  late final GeneratedColumn<int> syncCreatedAt = GeneratedColumn<int>(
    'sync_created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncUpdatedAtMeta = const VerificationMeta(
    'syncUpdatedAt',
  );
  @override
  late final GeneratedColumn<int> syncUpdatedAt = GeneratedColumn<int>(
    'sync_updated_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncDeletedAtMeta = const VerificationMeta(
    'syncDeletedAt',
  );
  @override
  late final GeneratedColumn<int> syncDeletedAt = GeneratedColumn<int>(
    'sync_deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncLastSyncedAtMeta = const VerificationMeta(
    'syncLastSyncedAt',
  );
  @override
  late final GeneratedColumn<int> syncLastSyncedAt = GeneratedColumn<int>(
    'sync_last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<int> syncStatus = GeneratedColumn<int>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncVersionMeta = const VerificationMeta(
    'syncVersion',
  );
  @override
  late final GeneratedColumn<int> syncVersion = GeneratedColumn<int>(
    'sync_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _syncDeviceIdMeta = const VerificationMeta(
    'syncDeviceId',
  );
  @override
  late final GeneratedColumn<String> syncDeviceId = GeneratedColumn<String>(
    'sync_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncIsDirtyMeta = const VerificationMeta(
    'syncIsDirty',
  );
  @override
  late final GeneratedColumn<bool> syncIsDirty = GeneratedColumn<bool>(
    'sync_is_dirty',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("sync_is_dirty" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _conflictDataMeta = const VerificationMeta(
    'conflictData',
  );
  @override
  late final GeneratedColumn<String> conflictData = GeneratedColumn<String>(
    'conflict_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    clientId,
    name,
    birthDate,
    biologicalSex,
    ethnicity,
    notes,
    ownerId,
    dietType,
    dietDescription,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'profiles';
  @override
  VerificationContext validateIntegrity(
    Insertable<ProfileRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_id')) {
      context.handle(
        _clientIdMeta,
        clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta),
      );
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('birth_date')) {
      context.handle(
        _birthDateMeta,
        birthDate.isAcceptableOrUnknown(data['birth_date']!, _birthDateMeta),
      );
    }
    if (data.containsKey('biological_sex')) {
      context.handle(
        _biologicalSexMeta,
        biologicalSex.isAcceptableOrUnknown(
          data['biological_sex']!,
          _biologicalSexMeta,
        ),
      );
    }
    if (data.containsKey('ethnicity')) {
      context.handle(
        _ethnicityMeta,
        ethnicity.isAcceptableOrUnknown(data['ethnicity']!, _ethnicityMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    }
    if (data.containsKey('diet_type')) {
      context.handle(
        _dietTypeMeta,
        dietType.isAcceptableOrUnknown(data['diet_type']!, _dietTypeMeta),
      );
    }
    if (data.containsKey('diet_description')) {
      context.handle(
        _dietDescriptionMeta,
        dietDescription.isAcceptableOrUnknown(
          data['diet_description']!,
          _dietDescriptionMeta,
        ),
      );
    }
    if (data.containsKey('sync_created_at')) {
      context.handle(
        _syncCreatedAtMeta,
        syncCreatedAt.isAcceptableOrUnknown(
          data['sync_created_at']!,
          _syncCreatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncCreatedAtMeta);
    }
    if (data.containsKey('sync_updated_at')) {
      context.handle(
        _syncUpdatedAtMeta,
        syncUpdatedAt.isAcceptableOrUnknown(
          data['sync_updated_at']!,
          _syncUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_deleted_at')) {
      context.handle(
        _syncDeletedAtMeta,
        syncDeletedAt.isAcceptableOrUnknown(
          data['sync_deleted_at']!,
          _syncDeletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_last_synced_at')) {
      context.handle(
        _syncLastSyncedAtMeta,
        syncLastSyncedAt.isAcceptableOrUnknown(
          data['sync_last_synced_at']!,
          _syncLastSyncedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('sync_version')) {
      context.handle(
        _syncVersionMeta,
        syncVersion.isAcceptableOrUnknown(
          data['sync_version']!,
          _syncVersionMeta,
        ),
      );
    }
    if (data.containsKey('sync_device_id')) {
      context.handle(
        _syncDeviceIdMeta,
        syncDeviceId.isAcceptableOrUnknown(
          data['sync_device_id']!,
          _syncDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_is_dirty')) {
      context.handle(
        _syncIsDirtyMeta,
        syncIsDirty.isAcceptableOrUnknown(
          data['sync_is_dirty']!,
          _syncIsDirtyMeta,
        ),
      );
    }
    if (data.containsKey('conflict_data')) {
      context.handle(
        _conflictDataMeta,
        conflictData.isAcceptableOrUnknown(
          data['conflict_data']!,
          _conflictDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ProfileRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProfileRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      clientId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}client_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      birthDate: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}birth_date'],
      ),
      biologicalSex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}biological_sex'],
      ),
      ethnicity: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ethnicity'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      ),
      dietType: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}diet_type'],
      )!,
      dietDescription: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}diet_description'],
      ),
      syncCreatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_created_at'],
      )!,
      syncUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_updated_at'],
      ),
      syncDeletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_deleted_at'],
      ),
      syncLastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_last_synced_at'],
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_status'],
      )!,
      syncVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_version'],
      )!,
      syncDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_device_id'],
      ),
      syncIsDirty: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}sync_is_dirty'],
      )!,
      conflictData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}conflict_data'],
      ),
    );
  }

  @override
  $ProfilesTable createAlias(String alias) {
    return $ProfilesTable(attachedDatabase, alias);
  }
}

class ProfileRow extends DataClass implements Insertable<ProfileRow> {
  final String id;
  final String clientId;
  final String name;
  final int? birthDate;
  final int? biologicalSex;
  final String? ethnicity;
  final String? notes;
  final String? ownerId;
  final int dietType;
  final String? dietDescription;
  final int syncCreatedAt;
  final int? syncUpdatedAt;
  final int? syncDeletedAt;
  final int? syncLastSyncedAt;
  final int syncStatus;
  final int syncVersion;
  final String? syncDeviceId;
  final bool syncIsDirty;
  final String? conflictData;
  const ProfileRow({
    required this.id,
    required this.clientId,
    required this.name,
    this.birthDate,
    this.biologicalSex,
    this.ethnicity,
    this.notes,
    this.ownerId,
    required this.dietType,
    this.dietDescription,
    required this.syncCreatedAt,
    this.syncUpdatedAt,
    this.syncDeletedAt,
    this.syncLastSyncedAt,
    required this.syncStatus,
    required this.syncVersion,
    this.syncDeviceId,
    required this.syncIsDirty,
    this.conflictData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['client_id'] = Variable<String>(clientId);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || birthDate != null) {
      map['birth_date'] = Variable<int>(birthDate);
    }
    if (!nullToAbsent || biologicalSex != null) {
      map['biological_sex'] = Variable<int>(biologicalSex);
    }
    if (!nullToAbsent || ethnicity != null) {
      map['ethnicity'] = Variable<String>(ethnicity);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    if (!nullToAbsent || ownerId != null) {
      map['owner_id'] = Variable<String>(ownerId);
    }
    map['diet_type'] = Variable<int>(dietType);
    if (!nullToAbsent || dietDescription != null) {
      map['diet_description'] = Variable<String>(dietDescription);
    }
    map['sync_created_at'] = Variable<int>(syncCreatedAt);
    if (!nullToAbsent || syncUpdatedAt != null) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt);
    }
    if (!nullToAbsent || syncDeletedAt != null) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt);
    }
    if (!nullToAbsent || syncLastSyncedAt != null) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt);
    }
    map['sync_status'] = Variable<int>(syncStatus);
    map['sync_version'] = Variable<int>(syncVersion);
    if (!nullToAbsent || syncDeviceId != null) {
      map['sync_device_id'] = Variable<String>(syncDeviceId);
    }
    map['sync_is_dirty'] = Variable<bool>(syncIsDirty);
    if (!nullToAbsent || conflictData != null) {
      map['conflict_data'] = Variable<String>(conflictData);
    }
    return map;
  }

  ProfilesCompanion toCompanion(bool nullToAbsent) {
    return ProfilesCompanion(
      id: Value(id),
      clientId: Value(clientId),
      name: Value(name),
      birthDate: birthDate == null && nullToAbsent
          ? const Value.absent()
          : Value(birthDate),
      biologicalSex: biologicalSex == null && nullToAbsent
          ? const Value.absent()
          : Value(biologicalSex),
      ethnicity: ethnicity == null && nullToAbsent
          ? const Value.absent()
          : Value(ethnicity),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      ownerId: ownerId == null && nullToAbsent
          ? const Value.absent()
          : Value(ownerId),
      dietType: Value(dietType),
      dietDescription: dietDescription == null && nullToAbsent
          ? const Value.absent()
          : Value(dietDescription),
      syncCreatedAt: Value(syncCreatedAt),
      syncUpdatedAt: syncUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncUpdatedAt),
      syncDeletedAt: syncDeletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeletedAt),
      syncLastSyncedAt: syncLastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncLastSyncedAt),
      syncStatus: Value(syncStatus),
      syncVersion: Value(syncVersion),
      syncDeviceId: syncDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(syncDeviceId),
      syncIsDirty: Value(syncIsDirty),
      conflictData: conflictData == null && nullToAbsent
          ? const Value.absent()
          : Value(conflictData),
    );
  }

  factory ProfileRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProfileRow(
      id: serializer.fromJson<String>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      name: serializer.fromJson<String>(json['name']),
      birthDate: serializer.fromJson<int?>(json['birthDate']),
      biologicalSex: serializer.fromJson<int?>(json['biologicalSex']),
      ethnicity: serializer.fromJson<String?>(json['ethnicity']),
      notes: serializer.fromJson<String?>(json['notes']),
      ownerId: serializer.fromJson<String?>(json['ownerId']),
      dietType: serializer.fromJson<int>(json['dietType']),
      dietDescription: serializer.fromJson<String?>(json['dietDescription']),
      syncCreatedAt: serializer.fromJson<int>(json['syncCreatedAt']),
      syncUpdatedAt: serializer.fromJson<int?>(json['syncUpdatedAt']),
      syncDeletedAt: serializer.fromJson<int?>(json['syncDeletedAt']),
      syncLastSyncedAt: serializer.fromJson<int?>(json['syncLastSyncedAt']),
      syncStatus: serializer.fromJson<int>(json['syncStatus']),
      syncVersion: serializer.fromJson<int>(json['syncVersion']),
      syncDeviceId: serializer.fromJson<String?>(json['syncDeviceId']),
      syncIsDirty: serializer.fromJson<bool>(json['syncIsDirty']),
      conflictData: serializer.fromJson<String?>(json['conflictData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientId': serializer.toJson<String>(clientId),
      'name': serializer.toJson<String>(name),
      'birthDate': serializer.toJson<int?>(birthDate),
      'biologicalSex': serializer.toJson<int?>(biologicalSex),
      'ethnicity': serializer.toJson<String?>(ethnicity),
      'notes': serializer.toJson<String?>(notes),
      'ownerId': serializer.toJson<String?>(ownerId),
      'dietType': serializer.toJson<int>(dietType),
      'dietDescription': serializer.toJson<String?>(dietDescription),
      'syncCreatedAt': serializer.toJson<int>(syncCreatedAt),
      'syncUpdatedAt': serializer.toJson<int?>(syncUpdatedAt),
      'syncDeletedAt': serializer.toJson<int?>(syncDeletedAt),
      'syncLastSyncedAt': serializer.toJson<int?>(syncLastSyncedAt),
      'syncStatus': serializer.toJson<int>(syncStatus),
      'syncVersion': serializer.toJson<int>(syncVersion),
      'syncDeviceId': serializer.toJson<String?>(syncDeviceId),
      'syncIsDirty': serializer.toJson<bool>(syncIsDirty),
      'conflictData': serializer.toJson<String?>(conflictData),
    };
  }

  ProfileRow copyWith({
    String? id,
    String? clientId,
    String? name,
    Value<int?> birthDate = const Value.absent(),
    Value<int?> biologicalSex = const Value.absent(),
    Value<String?> ethnicity = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    Value<String?> ownerId = const Value.absent(),
    int? dietType,
    Value<String?> dietDescription = const Value.absent(),
    int? syncCreatedAt,
    Value<int?> syncUpdatedAt = const Value.absent(),
    Value<int?> syncDeletedAt = const Value.absent(),
    Value<int?> syncLastSyncedAt = const Value.absent(),
    int? syncStatus,
    int? syncVersion,
    Value<String?> syncDeviceId = const Value.absent(),
    bool? syncIsDirty,
    Value<String?> conflictData = const Value.absent(),
  }) => ProfileRow(
    id: id ?? this.id,
    clientId: clientId ?? this.clientId,
    name: name ?? this.name,
    birthDate: birthDate.present ? birthDate.value : this.birthDate,
    biologicalSex: biologicalSex.present
        ? biologicalSex.value
        : this.biologicalSex,
    ethnicity: ethnicity.present ? ethnicity.value : this.ethnicity,
    notes: notes.present ? notes.value : this.notes,
    ownerId: ownerId.present ? ownerId.value : this.ownerId,
    dietType: dietType ?? this.dietType,
    dietDescription: dietDescription.present
        ? dietDescription.value
        : this.dietDescription,
    syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
    syncUpdatedAt: syncUpdatedAt.present
        ? syncUpdatedAt.value
        : this.syncUpdatedAt,
    syncDeletedAt: syncDeletedAt.present
        ? syncDeletedAt.value
        : this.syncDeletedAt,
    syncLastSyncedAt: syncLastSyncedAt.present
        ? syncLastSyncedAt.value
        : this.syncLastSyncedAt,
    syncStatus: syncStatus ?? this.syncStatus,
    syncVersion: syncVersion ?? this.syncVersion,
    syncDeviceId: syncDeviceId.present ? syncDeviceId.value : this.syncDeviceId,
    syncIsDirty: syncIsDirty ?? this.syncIsDirty,
    conflictData: conflictData.present ? conflictData.value : this.conflictData,
  );
  ProfileRow copyWithCompanion(ProfilesCompanion data) {
    return ProfileRow(
      id: data.id.present ? data.id.value : this.id,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      name: data.name.present ? data.name.value : this.name,
      birthDate: data.birthDate.present ? data.birthDate.value : this.birthDate,
      biologicalSex: data.biologicalSex.present
          ? data.biologicalSex.value
          : this.biologicalSex,
      ethnicity: data.ethnicity.present ? data.ethnicity.value : this.ethnicity,
      notes: data.notes.present ? data.notes.value : this.notes,
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      dietType: data.dietType.present ? data.dietType.value : this.dietType,
      dietDescription: data.dietDescription.present
          ? data.dietDescription.value
          : this.dietDescription,
      syncCreatedAt: data.syncCreatedAt.present
          ? data.syncCreatedAt.value
          : this.syncCreatedAt,
      syncUpdatedAt: data.syncUpdatedAt.present
          ? data.syncUpdatedAt.value
          : this.syncUpdatedAt,
      syncDeletedAt: data.syncDeletedAt.present
          ? data.syncDeletedAt.value
          : this.syncDeletedAt,
      syncLastSyncedAt: data.syncLastSyncedAt.present
          ? data.syncLastSyncedAt.value
          : this.syncLastSyncedAt,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      syncVersion: data.syncVersion.present
          ? data.syncVersion.value
          : this.syncVersion,
      syncDeviceId: data.syncDeviceId.present
          ? data.syncDeviceId.value
          : this.syncDeviceId,
      syncIsDirty: data.syncIsDirty.present
          ? data.syncIsDirty.value
          : this.syncIsDirty,
      conflictData: data.conflictData.present
          ? data.conflictData.value
          : this.conflictData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ProfileRow(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('name: $name, ')
          ..write('birthDate: $birthDate, ')
          ..write('biologicalSex: $biologicalSex, ')
          ..write('ethnicity: $ethnicity, ')
          ..write('notes: $notes, ')
          ..write('ownerId: $ownerId, ')
          ..write('dietType: $dietType, ')
          ..write('dietDescription: $dietDescription, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    clientId,
    name,
    birthDate,
    biologicalSex,
    ethnicity,
    notes,
    ownerId,
    dietType,
    dietDescription,
    syncCreatedAt,
    syncUpdatedAt,
    syncDeletedAt,
    syncLastSyncedAt,
    syncStatus,
    syncVersion,
    syncDeviceId,
    syncIsDirty,
    conflictData,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProfileRow &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.name == this.name &&
          other.birthDate == this.birthDate &&
          other.biologicalSex == this.biologicalSex &&
          other.ethnicity == this.ethnicity &&
          other.notes == this.notes &&
          other.ownerId == this.ownerId &&
          other.dietType == this.dietType &&
          other.dietDescription == this.dietDescription &&
          other.syncCreatedAt == this.syncCreatedAt &&
          other.syncUpdatedAt == this.syncUpdatedAt &&
          other.syncDeletedAt == this.syncDeletedAt &&
          other.syncLastSyncedAt == this.syncLastSyncedAt &&
          other.syncStatus == this.syncStatus &&
          other.syncVersion == this.syncVersion &&
          other.syncDeviceId == this.syncDeviceId &&
          other.syncIsDirty == this.syncIsDirty &&
          other.conflictData == this.conflictData);
}

class ProfilesCompanion extends UpdateCompanion<ProfileRow> {
  final Value<String> id;
  final Value<String> clientId;
  final Value<String> name;
  final Value<int?> birthDate;
  final Value<int?> biologicalSex;
  final Value<String?> ethnicity;
  final Value<String?> notes;
  final Value<String?> ownerId;
  final Value<int> dietType;
  final Value<String?> dietDescription;
  final Value<int> syncCreatedAt;
  final Value<int?> syncUpdatedAt;
  final Value<int?> syncDeletedAt;
  final Value<int?> syncLastSyncedAt;
  final Value<int> syncStatus;
  final Value<int> syncVersion;
  final Value<String?> syncDeviceId;
  final Value<bool> syncIsDirty;
  final Value<String?> conflictData;
  final Value<int> rowid;
  const ProfilesCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.name = const Value.absent(),
    this.birthDate = const Value.absent(),
    this.biologicalSex = const Value.absent(),
    this.ethnicity = const Value.absent(),
    this.notes = const Value.absent(),
    this.ownerId = const Value.absent(),
    this.dietType = const Value.absent(),
    this.dietDescription = const Value.absent(),
    this.syncCreatedAt = const Value.absent(),
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProfilesCompanion.insert({
    required String id,
    required String clientId,
    required String name,
    this.birthDate = const Value.absent(),
    this.biologicalSex = const Value.absent(),
    this.ethnicity = const Value.absent(),
    this.notes = const Value.absent(),
    this.ownerId = const Value.absent(),
    this.dietType = const Value.absent(),
    this.dietDescription = const Value.absent(),
    required int syncCreatedAt,
    this.syncUpdatedAt = const Value.absent(),
    this.syncDeletedAt = const Value.absent(),
    this.syncLastSyncedAt = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.syncVersion = const Value.absent(),
    this.syncDeviceId = const Value.absent(),
    this.syncIsDirty = const Value.absent(),
    this.conflictData = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       clientId = Value(clientId),
       name = Value(name),
       syncCreatedAt = Value(syncCreatedAt);
  static Insertable<ProfileRow> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? name,
    Expression<int>? birthDate,
    Expression<int>? biologicalSex,
    Expression<String>? ethnicity,
    Expression<String>? notes,
    Expression<String>? ownerId,
    Expression<int>? dietType,
    Expression<String>? dietDescription,
    Expression<int>? syncCreatedAt,
    Expression<int>? syncUpdatedAt,
    Expression<int>? syncDeletedAt,
    Expression<int>? syncLastSyncedAt,
    Expression<int>? syncStatus,
    Expression<int>? syncVersion,
    Expression<String>? syncDeviceId,
    Expression<bool>? syncIsDirty,
    Expression<String>? conflictData,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (name != null) 'name': name,
      if (birthDate != null) 'birth_date': birthDate,
      if (biologicalSex != null) 'biological_sex': biologicalSex,
      if (ethnicity != null) 'ethnicity': ethnicity,
      if (notes != null) 'notes': notes,
      if (ownerId != null) 'owner_id': ownerId,
      if (dietType != null) 'diet_type': dietType,
      if (dietDescription != null) 'diet_description': dietDescription,
      if (syncCreatedAt != null) 'sync_created_at': syncCreatedAt,
      if (syncUpdatedAt != null) 'sync_updated_at': syncUpdatedAt,
      if (syncDeletedAt != null) 'sync_deleted_at': syncDeletedAt,
      if (syncLastSyncedAt != null) 'sync_last_synced_at': syncLastSyncedAt,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (syncVersion != null) 'sync_version': syncVersion,
      if (syncDeviceId != null) 'sync_device_id': syncDeviceId,
      if (syncIsDirty != null) 'sync_is_dirty': syncIsDirty,
      if (conflictData != null) 'conflict_data': conflictData,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProfilesCompanion copyWith({
    Value<String>? id,
    Value<String>? clientId,
    Value<String>? name,
    Value<int?>? birthDate,
    Value<int?>? biologicalSex,
    Value<String?>? ethnicity,
    Value<String?>? notes,
    Value<String?>? ownerId,
    Value<int>? dietType,
    Value<String?>? dietDescription,
    Value<int>? syncCreatedAt,
    Value<int?>? syncUpdatedAt,
    Value<int?>? syncDeletedAt,
    Value<int?>? syncLastSyncedAt,
    Value<int>? syncStatus,
    Value<int>? syncVersion,
    Value<String?>? syncDeviceId,
    Value<bool>? syncIsDirty,
    Value<String?>? conflictData,
    Value<int>? rowid,
  }) {
    return ProfilesCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      name: name ?? this.name,
      birthDate: birthDate ?? this.birthDate,
      biologicalSex: biologicalSex ?? this.biologicalSex,
      ethnicity: ethnicity ?? this.ethnicity,
      notes: notes ?? this.notes,
      ownerId: ownerId ?? this.ownerId,
      dietType: dietType ?? this.dietType,
      dietDescription: dietDescription ?? this.dietDescription,
      syncCreatedAt: syncCreatedAt ?? this.syncCreatedAt,
      syncUpdatedAt: syncUpdatedAt ?? this.syncUpdatedAt,
      syncDeletedAt: syncDeletedAt ?? this.syncDeletedAt,
      syncLastSyncedAt: syncLastSyncedAt ?? this.syncLastSyncedAt,
      syncStatus: syncStatus ?? this.syncStatus,
      syncVersion: syncVersion ?? this.syncVersion,
      syncDeviceId: syncDeviceId ?? this.syncDeviceId,
      syncIsDirty: syncIsDirty ?? this.syncIsDirty,
      conflictData: conflictData ?? this.conflictData,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (birthDate.present) {
      map['birth_date'] = Variable<int>(birthDate.value);
    }
    if (biologicalSex.present) {
      map['biological_sex'] = Variable<int>(biologicalSex.value);
    }
    if (ethnicity.present) {
      map['ethnicity'] = Variable<String>(ethnicity.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (dietType.present) {
      map['diet_type'] = Variable<int>(dietType.value);
    }
    if (dietDescription.present) {
      map['diet_description'] = Variable<String>(dietDescription.value);
    }
    if (syncCreatedAt.present) {
      map['sync_created_at'] = Variable<int>(syncCreatedAt.value);
    }
    if (syncUpdatedAt.present) {
      map['sync_updated_at'] = Variable<int>(syncUpdatedAt.value);
    }
    if (syncDeletedAt.present) {
      map['sync_deleted_at'] = Variable<int>(syncDeletedAt.value);
    }
    if (syncLastSyncedAt.present) {
      map['sync_last_synced_at'] = Variable<int>(syncLastSyncedAt.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<int>(syncStatus.value);
    }
    if (syncVersion.present) {
      map['sync_version'] = Variable<int>(syncVersion.value);
    }
    if (syncDeviceId.present) {
      map['sync_device_id'] = Variable<String>(syncDeviceId.value);
    }
    if (syncIsDirty.present) {
      map['sync_is_dirty'] = Variable<bool>(syncIsDirty.value);
    }
    if (conflictData.present) {
      map['conflict_data'] = Variable<String>(conflictData.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProfilesCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('name: $name, ')
          ..write('birthDate: $birthDate, ')
          ..write('biologicalSex: $biologicalSex, ')
          ..write('ethnicity: $ethnicity, ')
          ..write('notes: $notes, ')
          ..write('ownerId: $ownerId, ')
          ..write('dietType: $dietType, ')
          ..write('dietDescription: $dietDescription, ')
          ..write('syncCreatedAt: $syncCreatedAt, ')
          ..write('syncUpdatedAt: $syncUpdatedAt, ')
          ..write('syncDeletedAt: $syncDeletedAt, ')
          ..write('syncLastSyncedAt: $syncLastSyncedAt, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('syncVersion: $syncVersion, ')
          ..write('syncDeviceId: $syncDeviceId, ')
          ..write('syncIsDirty: $syncIsDirty, ')
          ..write('conflictData: $conflictData, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GuestInvitesTable extends GuestInvites
    with TableInfo<$GuestInvitesTable, GuestInviteRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GuestInvitesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _tokenMeta = const VerificationMeta('token');
  @override
  late final GeneratedColumn<String> token = GeneratedColumn<String>(
    'token',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _labelMeta = const VerificationMeta('label');
  @override
  late final GeneratedColumn<String> label = GeneratedColumn<String>(
    'label',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant(''),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<int> expiresAt = GeneratedColumn<int>(
    'expires_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isRevokedMeta = const VerificationMeta(
    'isRevoked',
  );
  @override
  late final GeneratedColumn<bool> isRevoked = GeneratedColumn<bool>(
    'is_revoked',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_revoked" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lastSeenAtMeta = const VerificationMeta(
    'lastSeenAt',
  );
  @override
  late final GeneratedColumn<int> lastSeenAt = GeneratedColumn<int>(
    'last_seen_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _activeDeviceIdMeta = const VerificationMeta(
    'activeDeviceId',
  );
  @override
  late final GeneratedColumn<String> activeDeviceId = GeneratedColumn<String>(
    'active_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    profileId,
    token,
    label,
    createdAt,
    expiresAt,
    isRevoked,
    lastSeenAt,
    activeDeviceId,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'guest_invites';
  @override
  VerificationContext validateIntegrity(
    Insertable<GuestInviteRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('token')) {
      context.handle(
        _tokenMeta,
        token.isAcceptableOrUnknown(data['token']!, _tokenMeta),
      );
    } else if (isInserting) {
      context.missing(_tokenMeta);
    }
    if (data.containsKey('label')) {
      context.handle(
        _labelMeta,
        label.isAcceptableOrUnknown(data['label']!, _labelMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    }
    if (data.containsKey('is_revoked')) {
      context.handle(
        _isRevokedMeta,
        isRevoked.isAcceptableOrUnknown(data['is_revoked']!, _isRevokedMeta),
      );
    }
    if (data.containsKey('last_seen_at')) {
      context.handle(
        _lastSeenAtMeta,
        lastSeenAt.isAcceptableOrUnknown(
          data['last_seen_at']!,
          _lastSeenAtMeta,
        ),
      );
    }
    if (data.containsKey('active_device_id')) {
      context.handle(
        _activeDeviceIdMeta,
        activeDeviceId.isAcceptableOrUnknown(
          data['active_device_id']!,
          _activeDeviceIdMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  GuestInviteRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GuestInviteRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      token: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}token'],
      )!,
      label: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}label'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}expires_at'],
      ),
      isRevoked: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_revoked'],
      )!,
      lastSeenAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}last_seen_at'],
      ),
      activeDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}active_device_id'],
      ),
    );
  }

  @override
  $GuestInvitesTable createAlias(String alias) {
    return $GuestInvitesTable(attachedDatabase, alias);
  }
}

class GuestInviteRow extends DataClass implements Insertable<GuestInviteRow> {
  final String id;
  final String profileId;
  final String token;
  final String label;
  final int createdAt;
  final int? expiresAt;
  final bool isRevoked;
  final int? lastSeenAt;
  final String? activeDeviceId;
  const GuestInviteRow({
    required this.id,
    required this.profileId,
    required this.token,
    required this.label,
    required this.createdAt,
    this.expiresAt,
    required this.isRevoked,
    this.lastSeenAt,
    this.activeDeviceId,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['profile_id'] = Variable<String>(profileId);
    map['token'] = Variable<String>(token);
    map['label'] = Variable<String>(label);
    map['created_at'] = Variable<int>(createdAt);
    if (!nullToAbsent || expiresAt != null) {
      map['expires_at'] = Variable<int>(expiresAt);
    }
    map['is_revoked'] = Variable<bool>(isRevoked);
    if (!nullToAbsent || lastSeenAt != null) {
      map['last_seen_at'] = Variable<int>(lastSeenAt);
    }
    if (!nullToAbsent || activeDeviceId != null) {
      map['active_device_id'] = Variable<String>(activeDeviceId);
    }
    return map;
  }

  GuestInvitesCompanion toCompanion(bool nullToAbsent) {
    return GuestInvitesCompanion(
      id: Value(id),
      profileId: Value(profileId),
      token: Value(token),
      label: Value(label),
      createdAt: Value(createdAt),
      expiresAt: expiresAt == null && nullToAbsent
          ? const Value.absent()
          : Value(expiresAt),
      isRevoked: Value(isRevoked),
      lastSeenAt: lastSeenAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSeenAt),
      activeDeviceId: activeDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(activeDeviceId),
    );
  }

  factory GuestInviteRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GuestInviteRow(
      id: serializer.fromJson<String>(json['id']),
      profileId: serializer.fromJson<String>(json['profileId']),
      token: serializer.fromJson<String>(json['token']),
      label: serializer.fromJson<String>(json['label']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      expiresAt: serializer.fromJson<int?>(json['expiresAt']),
      isRevoked: serializer.fromJson<bool>(json['isRevoked']),
      lastSeenAt: serializer.fromJson<int?>(json['lastSeenAt']),
      activeDeviceId: serializer.fromJson<String?>(json['activeDeviceId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'profileId': serializer.toJson<String>(profileId),
      'token': serializer.toJson<String>(token),
      'label': serializer.toJson<String>(label),
      'createdAt': serializer.toJson<int>(createdAt),
      'expiresAt': serializer.toJson<int?>(expiresAt),
      'isRevoked': serializer.toJson<bool>(isRevoked),
      'lastSeenAt': serializer.toJson<int?>(lastSeenAt),
      'activeDeviceId': serializer.toJson<String?>(activeDeviceId),
    };
  }

  GuestInviteRow copyWith({
    String? id,
    String? profileId,
    String? token,
    String? label,
    int? createdAt,
    Value<int?> expiresAt = const Value.absent(),
    bool? isRevoked,
    Value<int?> lastSeenAt = const Value.absent(),
    Value<String?> activeDeviceId = const Value.absent(),
  }) => GuestInviteRow(
    id: id ?? this.id,
    profileId: profileId ?? this.profileId,
    token: token ?? this.token,
    label: label ?? this.label,
    createdAt: createdAt ?? this.createdAt,
    expiresAt: expiresAt.present ? expiresAt.value : this.expiresAt,
    isRevoked: isRevoked ?? this.isRevoked,
    lastSeenAt: lastSeenAt.present ? lastSeenAt.value : this.lastSeenAt,
    activeDeviceId: activeDeviceId.present
        ? activeDeviceId.value
        : this.activeDeviceId,
  );
  GuestInviteRow copyWithCompanion(GuestInvitesCompanion data) {
    return GuestInviteRow(
      id: data.id.present ? data.id.value : this.id,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      token: data.token.present ? data.token.value : this.token,
      label: data.label.present ? data.label.value : this.label,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
      isRevoked: data.isRevoked.present ? data.isRevoked.value : this.isRevoked,
      lastSeenAt: data.lastSeenAt.present
          ? data.lastSeenAt.value
          : this.lastSeenAt,
      activeDeviceId: data.activeDeviceId.present
          ? data.activeDeviceId.value
          : this.activeDeviceId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GuestInviteRow(')
          ..write('id: $id, ')
          ..write('profileId: $profileId, ')
          ..write('token: $token, ')
          ..write('label: $label, ')
          ..write('createdAt: $createdAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('isRevoked: $isRevoked, ')
          ..write('lastSeenAt: $lastSeenAt, ')
          ..write('activeDeviceId: $activeDeviceId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    profileId,
    token,
    label,
    createdAt,
    expiresAt,
    isRevoked,
    lastSeenAt,
    activeDeviceId,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GuestInviteRow &&
          other.id == this.id &&
          other.profileId == this.profileId &&
          other.token == this.token &&
          other.label == this.label &&
          other.createdAt == this.createdAt &&
          other.expiresAt == this.expiresAt &&
          other.isRevoked == this.isRevoked &&
          other.lastSeenAt == this.lastSeenAt &&
          other.activeDeviceId == this.activeDeviceId);
}

class GuestInvitesCompanion extends UpdateCompanion<GuestInviteRow> {
  final Value<String> id;
  final Value<String> profileId;
  final Value<String> token;
  final Value<String> label;
  final Value<int> createdAt;
  final Value<int?> expiresAt;
  final Value<bool> isRevoked;
  final Value<int?> lastSeenAt;
  final Value<String?> activeDeviceId;
  final Value<int> rowid;
  const GuestInvitesCompanion({
    this.id = const Value.absent(),
    this.profileId = const Value.absent(),
    this.token = const Value.absent(),
    this.label = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.isRevoked = const Value.absent(),
    this.lastSeenAt = const Value.absent(),
    this.activeDeviceId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GuestInvitesCompanion.insert({
    required String id,
    required String profileId,
    required String token,
    this.label = const Value.absent(),
    required int createdAt,
    this.expiresAt = const Value.absent(),
    this.isRevoked = const Value.absent(),
    this.lastSeenAt = const Value.absent(),
    this.activeDeviceId = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       profileId = Value(profileId),
       token = Value(token),
       createdAt = Value(createdAt);
  static Insertable<GuestInviteRow> custom({
    Expression<String>? id,
    Expression<String>? profileId,
    Expression<String>? token,
    Expression<String>? label,
    Expression<int>? createdAt,
    Expression<int>? expiresAt,
    Expression<bool>? isRevoked,
    Expression<int>? lastSeenAt,
    Expression<String>? activeDeviceId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (profileId != null) 'profile_id': profileId,
      if (token != null) 'token': token,
      if (label != null) 'label': label,
      if (createdAt != null) 'created_at': createdAt,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (isRevoked != null) 'is_revoked': isRevoked,
      if (lastSeenAt != null) 'last_seen_at': lastSeenAt,
      if (activeDeviceId != null) 'active_device_id': activeDeviceId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GuestInvitesCompanion copyWith({
    Value<String>? id,
    Value<String>? profileId,
    Value<String>? token,
    Value<String>? label,
    Value<int>? createdAt,
    Value<int?>? expiresAt,
    Value<bool>? isRevoked,
    Value<int?>? lastSeenAt,
    Value<String?>? activeDeviceId,
    Value<int>? rowid,
  }) {
    return GuestInvitesCompanion(
      id: id ?? this.id,
      profileId: profileId ?? this.profileId,
      token: token ?? this.token,
      label: label ?? this.label,
      createdAt: createdAt ?? this.createdAt,
      expiresAt: expiresAt ?? this.expiresAt,
      isRevoked: isRevoked ?? this.isRevoked,
      lastSeenAt: lastSeenAt ?? this.lastSeenAt,
      activeDeviceId: activeDeviceId ?? this.activeDeviceId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (token.present) {
      map['token'] = Variable<String>(token.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(label.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<int>(expiresAt.value);
    }
    if (isRevoked.present) {
      map['is_revoked'] = Variable<bool>(isRevoked.value);
    }
    if (lastSeenAt.present) {
      map['last_seen_at'] = Variable<int>(lastSeenAt.value);
    }
    if (activeDeviceId.present) {
      map['active_device_id'] = Variable<String>(activeDeviceId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GuestInvitesCompanion(')
          ..write('id: $id, ')
          ..write('profileId: $profileId, ')
          ..write('token: $token, ')
          ..write('label: $label, ')
          ..write('createdAt: $createdAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('isRevoked: $isRevoked, ')
          ..write('lastSeenAt: $lastSeenAt, ')
          ..write('activeDeviceId: $activeDeviceId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SupplementLabelPhotosTable extends SupplementLabelPhotos
    with TableInfo<$SupplementLabelPhotosTable, SupplementLabelPhotoRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SupplementLabelPhotosTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _supplementIdMeta = const VerificationMeta(
    'supplementId',
  );
  @override
  late final GeneratedColumn<String> supplementId = GeneratedColumn<String>(
    'supplement_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _filePathMeta = const VerificationMeta(
    'filePath',
  );
  @override
  late final GeneratedColumn<String> filePath = GeneratedColumn<String>(
    'file_path',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _capturedAtMeta = const VerificationMeta(
    'capturedAt',
  );
  @override
  late final GeneratedColumn<int> capturedAt = GeneratedColumn<int>(
    'captured_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    supplementId,
    filePath,
    capturedAt,
    sortOrder,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'supplement_label_photos';
  @override
  VerificationContext validateIntegrity(
    Insertable<SupplementLabelPhotoRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('supplement_id')) {
      context.handle(
        _supplementIdMeta,
        supplementId.isAcceptableOrUnknown(
          data['supplement_id']!,
          _supplementIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_supplementIdMeta);
    }
    if (data.containsKey('file_path')) {
      context.handle(
        _filePathMeta,
        filePath.isAcceptableOrUnknown(data['file_path']!, _filePathMeta),
      );
    } else if (isInserting) {
      context.missing(_filePathMeta);
    }
    if (data.containsKey('captured_at')) {
      context.handle(
        _capturedAtMeta,
        capturedAt.isAcceptableOrUnknown(data['captured_at']!, _capturedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_capturedAtMeta);
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SupplementLabelPhotoRow map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SupplementLabelPhotoRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      supplementId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}supplement_id'],
      )!,
      filePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}file_path'],
      )!,
      capturedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}captured_at'],
      )!,
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
    );
  }

  @override
  $SupplementLabelPhotosTable createAlias(String alias) {
    return $SupplementLabelPhotosTable(attachedDatabase, alias);
  }
}

class SupplementLabelPhotoRow extends DataClass
    implements Insertable<SupplementLabelPhotoRow> {
  final String id;
  final String supplementId;
  final String filePath;
  final int capturedAt;
  final int sortOrder;
  const SupplementLabelPhotoRow({
    required this.id,
    required this.supplementId,
    required this.filePath,
    required this.capturedAt,
    required this.sortOrder,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['supplement_id'] = Variable<String>(supplementId);
    map['file_path'] = Variable<String>(filePath);
    map['captured_at'] = Variable<int>(capturedAt);
    map['sort_order'] = Variable<int>(sortOrder);
    return map;
  }

  SupplementLabelPhotosCompanion toCompanion(bool nullToAbsent) {
    return SupplementLabelPhotosCompanion(
      id: Value(id),
      supplementId: Value(supplementId),
      filePath: Value(filePath),
      capturedAt: Value(capturedAt),
      sortOrder: Value(sortOrder),
    );
  }

  factory SupplementLabelPhotoRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SupplementLabelPhotoRow(
      id: serializer.fromJson<String>(json['id']),
      supplementId: serializer.fromJson<String>(json['supplementId']),
      filePath: serializer.fromJson<String>(json['filePath']),
      capturedAt: serializer.fromJson<int>(json['capturedAt']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'supplementId': serializer.toJson<String>(supplementId),
      'filePath': serializer.toJson<String>(filePath),
      'capturedAt': serializer.toJson<int>(capturedAt),
      'sortOrder': serializer.toJson<int>(sortOrder),
    };
  }

  SupplementLabelPhotoRow copyWith({
    String? id,
    String? supplementId,
    String? filePath,
    int? capturedAt,
    int? sortOrder,
  }) => SupplementLabelPhotoRow(
    id: id ?? this.id,
    supplementId: supplementId ?? this.supplementId,
    filePath: filePath ?? this.filePath,
    capturedAt: capturedAt ?? this.capturedAt,
    sortOrder: sortOrder ?? this.sortOrder,
  );
  SupplementLabelPhotoRow copyWithCompanion(
    SupplementLabelPhotosCompanion data,
  ) {
    return SupplementLabelPhotoRow(
      id: data.id.present ? data.id.value : this.id,
      supplementId: data.supplementId.present
          ? data.supplementId.value
          : this.supplementId,
      filePath: data.filePath.present ? data.filePath.value : this.filePath,
      capturedAt: data.capturedAt.present
          ? data.capturedAt.value
          : this.capturedAt,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SupplementLabelPhotoRow(')
          ..write('id: $id, ')
          ..write('supplementId: $supplementId, ')
          ..write('filePath: $filePath, ')
          ..write('capturedAt: $capturedAt, ')
          ..write('sortOrder: $sortOrder')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, supplementId, filePath, capturedAt, sortOrder);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SupplementLabelPhotoRow &&
          other.id == this.id &&
          other.supplementId == this.supplementId &&
          other.filePath == this.filePath &&
          other.capturedAt == this.capturedAt &&
          other.sortOrder == this.sortOrder);
}

class SupplementLabelPhotosCompanion
    extends UpdateCompanion<SupplementLabelPhotoRow> {
  final Value<String> id;
  final Value<String> supplementId;
  final Value<String> filePath;
  final Value<int> capturedAt;
  final Value<int> sortOrder;
  final Value<int> rowid;
  const SupplementLabelPhotosCompanion({
    this.id = const Value.absent(),
    this.supplementId = const Value.absent(),
    this.filePath = const Value.absent(),
    this.capturedAt = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SupplementLabelPhotosCompanion.insert({
    required String id,
    required String supplementId,
    required String filePath,
    required int capturedAt,
    this.sortOrder = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       supplementId = Value(supplementId),
       filePath = Value(filePath),
       capturedAt = Value(capturedAt);
  static Insertable<SupplementLabelPhotoRow> custom({
    Expression<String>? id,
    Expression<String>? supplementId,
    Expression<String>? filePath,
    Expression<int>? capturedAt,
    Expression<int>? sortOrder,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (supplementId != null) 'supplement_id': supplementId,
      if (filePath != null) 'file_path': filePath,
      if (capturedAt != null) 'captured_at': capturedAt,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SupplementLabelPhotosCompanion copyWith({
    Value<String>? id,
    Value<String>? supplementId,
    Value<String>? filePath,
    Value<int>? capturedAt,
    Value<int>? sortOrder,
    Value<int>? rowid,
  }) {
    return SupplementLabelPhotosCompanion(
      id: id ?? this.id,
      supplementId: supplementId ?? this.supplementId,
      filePath: filePath ?? this.filePath,
      capturedAt: capturedAt ?? this.capturedAt,
      sortOrder: sortOrder ?? this.sortOrder,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (supplementId.present) {
      map['supplement_id'] = Variable<String>(supplementId.value);
    }
    if (filePath.present) {
      map['file_path'] = Variable<String>(filePath.value);
    }
    if (capturedAt.present) {
      map['captured_at'] = Variable<int>(capturedAt.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SupplementLabelPhotosCompanion(')
          ..write('id: $id, ')
          ..write('supplementId: $supplementId, ')
          ..write('filePath: $filePath, ')
          ..write('capturedAt: $capturedAt, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SupplementBarcodeCacheTable extends SupplementBarcodeCache
    with TableInfo<$SupplementBarcodeCacheTable, SupplementBarcodeCacheRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SupplementBarcodeCacheTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _barcodeMeta = const VerificationMeta(
    'barcode',
  );
  @override
  late final GeneratedColumn<String> barcode = GeneratedColumn<String>(
    'barcode',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _productNameMeta = const VerificationMeta(
    'productName',
  );
  @override
  late final GeneratedColumn<String> productName = GeneratedColumn<String>(
    'product_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _brandMeta = const VerificationMeta('brand');
  @override
  late final GeneratedColumn<String> brand = GeneratedColumn<String>(
    'brand',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _servingSizeMeta = const VerificationMeta(
    'servingSize',
  );
  @override
  late final GeneratedColumn<String> servingSize = GeneratedColumn<String>(
    'serving_size',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _servingsPerContainerMeta =
      const VerificationMeta('servingsPerContainer');
  @override
  late final GeneratedColumn<double> servingsPerContainer =
      GeneratedColumn<double>(
        'servings_per_container',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _ingredientsJsonMeta = const VerificationMeta(
    'ingredientsJson',
  );
  @override
  late final GeneratedColumn<String> ingredientsJson = GeneratedColumn<String>(
    'ingredients_json',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _dsldIdMeta = const VerificationMeta('dsldId');
  @override
  late final GeneratedColumn<String> dsldId = GeneratedColumn<String>(
    'dsld_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _rawResponseMeta = const VerificationMeta(
    'rawResponse',
  );
  @override
  late final GeneratedColumn<String> rawResponse = GeneratedColumn<String>(
    'raw_response',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fetchedAtMeta = const VerificationMeta(
    'fetchedAt',
  );
  @override
  late final GeneratedColumn<int> fetchedAt = GeneratedColumn<int>(
    'fetched_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<int> expiresAt = GeneratedColumn<int>(
    'expires_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    barcode,
    productName,
    brand,
    servingSize,
    servingsPerContainer,
    ingredientsJson,
    dsldId,
    rawResponse,
    fetchedAt,
    expiresAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'supplement_barcode_cache';
  @override
  VerificationContext validateIntegrity(
    Insertable<SupplementBarcodeCacheRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('barcode')) {
      context.handle(
        _barcodeMeta,
        barcode.isAcceptableOrUnknown(data['barcode']!, _barcodeMeta),
      );
    } else if (isInserting) {
      context.missing(_barcodeMeta);
    }
    if (data.containsKey('product_name')) {
      context.handle(
        _productNameMeta,
        productName.isAcceptableOrUnknown(
          data['product_name']!,
          _productNameMeta,
        ),
      );
    }
    if (data.containsKey('brand')) {
      context.handle(
        _brandMeta,
        brand.isAcceptableOrUnknown(data['brand']!, _brandMeta),
      );
    }
    if (data.containsKey('serving_size')) {
      context.handle(
        _servingSizeMeta,
        servingSize.isAcceptableOrUnknown(
          data['serving_size']!,
          _servingSizeMeta,
        ),
      );
    }
    if (data.containsKey('servings_per_container')) {
      context.handle(
        _servingsPerContainerMeta,
        servingsPerContainer.isAcceptableOrUnknown(
          data['servings_per_container']!,
          _servingsPerContainerMeta,
        ),
      );
    }
    if (data.containsKey('ingredients_json')) {
      context.handle(
        _ingredientsJsonMeta,
        ingredientsJson.isAcceptableOrUnknown(
          data['ingredients_json']!,
          _ingredientsJsonMeta,
        ),
      );
    }
    if (data.containsKey('dsld_id')) {
      context.handle(
        _dsldIdMeta,
        dsldId.isAcceptableOrUnknown(data['dsld_id']!, _dsldIdMeta),
      );
    }
    if (data.containsKey('raw_response')) {
      context.handle(
        _rawResponseMeta,
        rawResponse.isAcceptableOrUnknown(
          data['raw_response']!,
          _rawResponseMeta,
        ),
      );
    }
    if (data.containsKey('fetched_at')) {
      context.handle(
        _fetchedAtMeta,
        fetchedAt.isAcceptableOrUnknown(data['fetched_at']!, _fetchedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_fetchedAtMeta);
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    } else if (isInserting) {
      context.missing(_expiresAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SupplementBarcodeCacheRow map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SupplementBarcodeCacheRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      barcode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}barcode'],
      )!,
      productName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_name'],
      ),
      brand: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}brand'],
      ),
      servingSize: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}serving_size'],
      ),
      servingsPerContainer: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}servings_per_container'],
      ),
      ingredientsJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ingredients_json'],
      ),
      dsldId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}dsld_id'],
      ),
      rawResponse: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}raw_response'],
      ),
      fetchedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}fetched_at'],
      )!,
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}expires_at'],
      )!,
    );
  }

  @override
  $SupplementBarcodeCacheTable createAlias(String alias) {
    return $SupplementBarcodeCacheTable(attachedDatabase, alias);
  }
}

class SupplementBarcodeCacheRow extends DataClass
    implements Insertable<SupplementBarcodeCacheRow> {
  final String id;
  final String barcode;
  final String? productName;
  final String? brand;
  final String? servingSize;
  final double? servingsPerContainer;
  final String? ingredientsJson;
  final String? dsldId;
  final String? rawResponse;
  final int fetchedAt;
  final int expiresAt;
  const SupplementBarcodeCacheRow({
    required this.id,
    required this.barcode,
    this.productName,
    this.brand,
    this.servingSize,
    this.servingsPerContainer,
    this.ingredientsJson,
    this.dsldId,
    this.rawResponse,
    required this.fetchedAt,
    required this.expiresAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['barcode'] = Variable<String>(barcode);
    if (!nullToAbsent || productName != null) {
      map['product_name'] = Variable<String>(productName);
    }
    if (!nullToAbsent || brand != null) {
      map['brand'] = Variable<String>(brand);
    }
    if (!nullToAbsent || servingSize != null) {
      map['serving_size'] = Variable<String>(servingSize);
    }
    if (!nullToAbsent || servingsPerContainer != null) {
      map['servings_per_container'] = Variable<double>(servingsPerContainer);
    }
    if (!nullToAbsent || ingredientsJson != null) {
      map['ingredients_json'] = Variable<String>(ingredientsJson);
    }
    if (!nullToAbsent || dsldId != null) {
      map['dsld_id'] = Variable<String>(dsldId);
    }
    if (!nullToAbsent || rawResponse != null) {
      map['raw_response'] = Variable<String>(rawResponse);
    }
    map['fetched_at'] = Variable<int>(fetchedAt);
    map['expires_at'] = Variable<int>(expiresAt);
    return map;
  }

  SupplementBarcodeCacheCompanion toCompanion(bool nullToAbsent) {
    return SupplementBarcodeCacheCompanion(
      id: Value(id),
      barcode: Value(barcode),
      productName: productName == null && nullToAbsent
          ? const Value.absent()
          : Value(productName),
      brand: brand == null && nullToAbsent
          ? const Value.absent()
          : Value(brand),
      servingSize: servingSize == null && nullToAbsent
          ? const Value.absent()
          : Value(servingSize),
      servingsPerContainer: servingsPerContainer == null && nullToAbsent
          ? const Value.absent()
          : Value(servingsPerContainer),
      ingredientsJson: ingredientsJson == null && nullToAbsent
          ? const Value.absent()
          : Value(ingredientsJson),
      dsldId: dsldId == null && nullToAbsent
          ? const Value.absent()
          : Value(dsldId),
      rawResponse: rawResponse == null && nullToAbsent
          ? const Value.absent()
          : Value(rawResponse),
      fetchedAt: Value(fetchedAt),
      expiresAt: Value(expiresAt),
    );
  }

  factory SupplementBarcodeCacheRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SupplementBarcodeCacheRow(
      id: serializer.fromJson<String>(json['id']),
      barcode: serializer.fromJson<String>(json['barcode']),
      productName: serializer.fromJson<String?>(json['productName']),
      brand: serializer.fromJson<String?>(json['brand']),
      servingSize: serializer.fromJson<String?>(json['servingSize']),
      servingsPerContainer: serializer.fromJson<double?>(
        json['servingsPerContainer'],
      ),
      ingredientsJson: serializer.fromJson<String?>(json['ingredientsJson']),
      dsldId: serializer.fromJson<String?>(json['dsldId']),
      rawResponse: serializer.fromJson<String?>(json['rawResponse']),
      fetchedAt: serializer.fromJson<int>(json['fetchedAt']),
      expiresAt: serializer.fromJson<int>(json['expiresAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'barcode': serializer.toJson<String>(barcode),
      'productName': serializer.toJson<String?>(productName),
      'brand': serializer.toJson<String?>(brand),
      'servingSize': serializer.toJson<String?>(servingSize),
      'servingsPerContainer': serializer.toJson<double?>(servingsPerContainer),
      'ingredientsJson': serializer.toJson<String?>(ingredientsJson),
      'dsldId': serializer.toJson<String?>(dsldId),
      'rawResponse': serializer.toJson<String?>(rawResponse),
      'fetchedAt': serializer.toJson<int>(fetchedAt),
      'expiresAt': serializer.toJson<int>(expiresAt),
    };
  }

  SupplementBarcodeCacheRow copyWith({
    String? id,
    String? barcode,
    Value<String?> productName = const Value.absent(),
    Value<String?> brand = const Value.absent(),
    Value<String?> servingSize = const Value.absent(),
    Value<double?> servingsPerContainer = const Value.absent(),
    Value<String?> ingredientsJson = const Value.absent(),
    Value<String?> dsldId = const Value.absent(),
    Value<String?> rawResponse = const Value.absent(),
    int? fetchedAt,
    int? expiresAt,
  }) => SupplementBarcodeCacheRow(
    id: id ?? this.id,
    barcode: barcode ?? this.barcode,
    productName: productName.present ? productName.value : this.productName,
    brand: brand.present ? brand.value : this.brand,
    servingSize: servingSize.present ? servingSize.value : this.servingSize,
    servingsPerContainer: servingsPerContainer.present
        ? servingsPerContainer.value
        : this.servingsPerContainer,
    ingredientsJson: ingredientsJson.present
        ? ingredientsJson.value
        : this.ingredientsJson,
    dsldId: dsldId.present ? dsldId.value : this.dsldId,
    rawResponse: rawResponse.present ? rawResponse.value : this.rawResponse,
    fetchedAt: fetchedAt ?? this.fetchedAt,
    expiresAt: expiresAt ?? this.expiresAt,
  );
  SupplementBarcodeCacheRow copyWithCompanion(
    SupplementBarcodeCacheCompanion data,
  ) {
    return SupplementBarcodeCacheRow(
      id: data.id.present ? data.id.value : this.id,
      barcode: data.barcode.present ? data.barcode.value : this.barcode,
      productName: data.productName.present
          ? data.productName.value
          : this.productName,
      brand: data.brand.present ? data.brand.value : this.brand,
      servingSize: data.servingSize.present
          ? data.servingSize.value
          : this.servingSize,
      servingsPerContainer: data.servingsPerContainer.present
          ? data.servingsPerContainer.value
          : this.servingsPerContainer,
      ingredientsJson: data.ingredientsJson.present
          ? data.ingredientsJson.value
          : this.ingredientsJson,
      dsldId: data.dsldId.present ? data.dsldId.value : this.dsldId,
      rawResponse: data.rawResponse.present
          ? data.rawResponse.value
          : this.rawResponse,
      fetchedAt: data.fetchedAt.present ? data.fetchedAt.value : this.fetchedAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SupplementBarcodeCacheRow(')
          ..write('id: $id, ')
          ..write('barcode: $barcode, ')
          ..write('productName: $productName, ')
          ..write('brand: $brand, ')
          ..write('servingSize: $servingSize, ')
          ..write('servingsPerContainer: $servingsPerContainer, ')
          ..write('ingredientsJson: $ingredientsJson, ')
          ..write('dsldId: $dsldId, ')
          ..write('rawResponse: $rawResponse, ')
          ..write('fetchedAt: $fetchedAt, ')
          ..write('expiresAt: $expiresAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    barcode,
    productName,
    brand,
    servingSize,
    servingsPerContainer,
    ingredientsJson,
    dsldId,
    rawResponse,
    fetchedAt,
    expiresAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SupplementBarcodeCacheRow &&
          other.id == this.id &&
          other.barcode == this.barcode &&
          other.productName == this.productName &&
          other.brand == this.brand &&
          other.servingSize == this.servingSize &&
          other.servingsPerContainer == this.servingsPerContainer &&
          other.ingredientsJson == this.ingredientsJson &&
          other.dsldId == this.dsldId &&
          other.rawResponse == this.rawResponse &&
          other.fetchedAt == this.fetchedAt &&
          other.expiresAt == this.expiresAt);
}

class SupplementBarcodeCacheCompanion
    extends UpdateCompanion<SupplementBarcodeCacheRow> {
  final Value<String> id;
  final Value<String> barcode;
  final Value<String?> productName;
  final Value<String?> brand;
  final Value<String?> servingSize;
  final Value<double?> servingsPerContainer;
  final Value<String?> ingredientsJson;
  final Value<String?> dsldId;
  final Value<String?> rawResponse;
  final Value<int> fetchedAt;
  final Value<int> expiresAt;
  final Value<int> rowid;
  const SupplementBarcodeCacheCompanion({
    this.id = const Value.absent(),
    this.barcode = const Value.absent(),
    this.productName = const Value.absent(),
    this.brand = const Value.absent(),
    this.servingSize = const Value.absent(),
    this.servingsPerContainer = const Value.absent(),
    this.ingredientsJson = const Value.absent(),
    this.dsldId = const Value.absent(),
    this.rawResponse = const Value.absent(),
    this.fetchedAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SupplementBarcodeCacheCompanion.insert({
    required String id,
    required String barcode,
    this.productName = const Value.absent(),
    this.brand = const Value.absent(),
    this.servingSize = const Value.absent(),
    this.servingsPerContainer = const Value.absent(),
    this.ingredientsJson = const Value.absent(),
    this.dsldId = const Value.absent(),
    this.rawResponse = const Value.absent(),
    required int fetchedAt,
    required int expiresAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       barcode = Value(barcode),
       fetchedAt = Value(fetchedAt),
       expiresAt = Value(expiresAt);
  static Insertable<SupplementBarcodeCacheRow> custom({
    Expression<String>? id,
    Expression<String>? barcode,
    Expression<String>? productName,
    Expression<String>? brand,
    Expression<String>? servingSize,
    Expression<double>? servingsPerContainer,
    Expression<String>? ingredientsJson,
    Expression<String>? dsldId,
    Expression<String>? rawResponse,
    Expression<int>? fetchedAt,
    Expression<int>? expiresAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (barcode != null) 'barcode': barcode,
      if (productName != null) 'product_name': productName,
      if (brand != null) 'brand': brand,
      if (servingSize != null) 'serving_size': servingSize,
      if (servingsPerContainer != null)
        'servings_per_container': servingsPerContainer,
      if (ingredientsJson != null) 'ingredients_json': ingredientsJson,
      if (dsldId != null) 'dsld_id': dsldId,
      if (rawResponse != null) 'raw_response': rawResponse,
      if (fetchedAt != null) 'fetched_at': fetchedAt,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SupplementBarcodeCacheCompanion copyWith({
    Value<String>? id,
    Value<String>? barcode,
    Value<String?>? productName,
    Value<String?>? brand,
    Value<String?>? servingSize,
    Value<double?>? servingsPerContainer,
    Value<String?>? ingredientsJson,
    Value<String?>? dsldId,
    Value<String?>? rawResponse,
    Value<int>? fetchedAt,
    Value<int>? expiresAt,
    Value<int>? rowid,
  }) {
    return SupplementBarcodeCacheCompanion(
      id: id ?? this.id,
      barcode: barcode ?? this.barcode,
      productName: productName ?? this.productName,
      brand: brand ?? this.brand,
      servingSize: servingSize ?? this.servingSize,
      servingsPerContainer: servingsPerContainer ?? this.servingsPerContainer,
      ingredientsJson: ingredientsJson ?? this.ingredientsJson,
      dsldId: dsldId ?? this.dsldId,
      rawResponse: rawResponse ?? this.rawResponse,
      fetchedAt: fetchedAt ?? this.fetchedAt,
      expiresAt: expiresAt ?? this.expiresAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (barcode.present) {
      map['barcode'] = Variable<String>(barcode.value);
    }
    if (productName.present) {
      map['product_name'] = Variable<String>(productName.value);
    }
    if (brand.present) {
      map['brand'] = Variable<String>(brand.value);
    }
    if (servingSize.present) {
      map['serving_size'] = Variable<String>(servingSize.value);
    }
    if (servingsPerContainer.present) {
      map['servings_per_container'] = Variable<double>(
        servingsPerContainer.value,
      );
    }
    if (ingredientsJson.present) {
      map['ingredients_json'] = Variable<String>(ingredientsJson.value);
    }
    if (dsldId.present) {
      map['dsld_id'] = Variable<String>(dsldId.value);
    }
    if (rawResponse.present) {
      map['raw_response'] = Variable<String>(rawResponse.value);
    }
    if (fetchedAt.present) {
      map['fetched_at'] = Variable<int>(fetchedAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<int>(expiresAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SupplementBarcodeCacheCompanion(')
          ..write('id: $id, ')
          ..write('barcode: $barcode, ')
          ..write('productName: $productName, ')
          ..write('brand: $brand, ')
          ..write('servingSize: $servingSize, ')
          ..write('servingsPerContainer: $servingsPerContainer, ')
          ..write('ingredientsJson: $ingredientsJson, ')
          ..write('dsldId: $dsldId, ')
          ..write('rawResponse: $rawResponse, ')
          ..write('fetchedAt: $fetchedAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SyncConflictsTable extends SyncConflicts
    with TableInfo<$SyncConflictsTable, SyncConflictRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncConflictsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityIdMeta = const VerificationMeta(
    'entityId',
  );
  @override
  late final GeneratedColumn<String> entityId = GeneratedColumn<String>(
    'entity_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _localVersionMeta = const VerificationMeta(
    'localVersion',
  );
  @override
  late final GeneratedColumn<int> localVersion = GeneratedColumn<int>(
    'local_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _remoteVersionMeta = const VerificationMeta(
    'remoteVersion',
  );
  @override
  late final GeneratedColumn<int> remoteVersion = GeneratedColumn<int>(
    'remote_version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _localDataMeta = const VerificationMeta(
    'localData',
  );
  @override
  late final GeneratedColumn<String> localData = GeneratedColumn<String>(
    'local_data',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _remoteDataMeta = const VerificationMeta(
    'remoteData',
  );
  @override
  late final GeneratedColumn<String> remoteData = GeneratedColumn<String>(
    'remote_data',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _detectedAtMeta = const VerificationMeta(
    'detectedAt',
  );
  @override
  late final GeneratedColumn<int> detectedAt = GeneratedColumn<int>(
    'detected_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isResolvedMeta = const VerificationMeta(
    'isResolved',
  );
  @override
  late final GeneratedColumn<bool> isResolved = GeneratedColumn<bool>(
    'is_resolved',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_resolved" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _resolutionMeta = const VerificationMeta(
    'resolution',
  );
  @override
  late final GeneratedColumn<int> resolution = GeneratedColumn<int>(
    'resolution',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _resolvedAtMeta = const VerificationMeta(
    'resolvedAt',
  );
  @override
  late final GeneratedColumn<int> resolvedAt = GeneratedColumn<int>(
    'resolved_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    entityType,
    entityId,
    profileId,
    localVersion,
    remoteVersion,
    localData,
    remoteData,
    detectedAt,
    isResolved,
    resolution,
    resolvedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sync_conflicts';
  @override
  VerificationContext validateIntegrity(
    Insertable<SyncConflictRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_id')) {
      context.handle(
        _entityIdMeta,
        entityId.isAcceptableOrUnknown(data['entity_id']!, _entityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_entityIdMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('local_version')) {
      context.handle(
        _localVersionMeta,
        localVersion.isAcceptableOrUnknown(
          data['local_version']!,
          _localVersionMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_localVersionMeta);
    }
    if (data.containsKey('remote_version')) {
      context.handle(
        _remoteVersionMeta,
        remoteVersion.isAcceptableOrUnknown(
          data['remote_version']!,
          _remoteVersionMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_remoteVersionMeta);
    }
    if (data.containsKey('local_data')) {
      context.handle(
        _localDataMeta,
        localData.isAcceptableOrUnknown(data['local_data']!, _localDataMeta),
      );
    } else if (isInserting) {
      context.missing(_localDataMeta);
    }
    if (data.containsKey('remote_data')) {
      context.handle(
        _remoteDataMeta,
        remoteData.isAcceptableOrUnknown(data['remote_data']!, _remoteDataMeta),
      );
    } else if (isInserting) {
      context.missing(_remoteDataMeta);
    }
    if (data.containsKey('detected_at')) {
      context.handle(
        _detectedAtMeta,
        detectedAt.isAcceptableOrUnknown(data['detected_at']!, _detectedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_detectedAtMeta);
    }
    if (data.containsKey('is_resolved')) {
      context.handle(
        _isResolvedMeta,
        isResolved.isAcceptableOrUnknown(data['is_resolved']!, _isResolvedMeta),
      );
    }
    if (data.containsKey('resolution')) {
      context.handle(
        _resolutionMeta,
        resolution.isAcceptableOrUnknown(data['resolution']!, _resolutionMeta),
      );
    }
    if (data.containsKey('resolved_at')) {
      context.handle(
        _resolvedAtMeta,
        resolvedAt.isAcceptableOrUnknown(data['resolved_at']!, _resolvedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SyncConflictRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SyncConflictRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      localVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}local_version'],
      )!,
      remoteVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}remote_version'],
      )!,
      localData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}local_data'],
      )!,
      remoteData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}remote_data'],
      )!,
      detectedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}detected_at'],
      )!,
      isResolved: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_resolved'],
      )!,
      resolution: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}resolution'],
      ),
      resolvedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}resolved_at'],
      ),
    );
  }

  @override
  $SyncConflictsTable createAlias(String alias) {
    return $SyncConflictsTable(attachedDatabase, alias);
  }
}

class SyncConflictRow extends DataClass implements Insertable<SyncConflictRow> {
  final String id;
  final String entityType;
  final String entityId;
  final String profileId;
  final int localVersion;
  final int remoteVersion;
  final String localData;
  final String remoteData;
  final int detectedAt;
  final bool isResolved;
  final int? resolution;
  final int? resolvedAt;
  const SyncConflictRow({
    required this.id,
    required this.entityType,
    required this.entityId,
    required this.profileId,
    required this.localVersion,
    required this.remoteVersion,
    required this.localData,
    required this.remoteData,
    required this.detectedAt,
    required this.isResolved,
    this.resolution,
    this.resolvedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['entity_type'] = Variable<String>(entityType);
    map['entity_id'] = Variable<String>(entityId);
    map['profile_id'] = Variable<String>(profileId);
    map['local_version'] = Variable<int>(localVersion);
    map['remote_version'] = Variable<int>(remoteVersion);
    map['local_data'] = Variable<String>(localData);
    map['remote_data'] = Variable<String>(remoteData);
    map['detected_at'] = Variable<int>(detectedAt);
    map['is_resolved'] = Variable<bool>(isResolved);
    if (!nullToAbsent || resolution != null) {
      map['resolution'] = Variable<int>(resolution);
    }
    if (!nullToAbsent || resolvedAt != null) {
      map['resolved_at'] = Variable<int>(resolvedAt);
    }
    return map;
  }

  SyncConflictsCompanion toCompanion(bool nullToAbsent) {
    return SyncConflictsCompanion(
      id: Value(id),
      entityType: Value(entityType),
      entityId: Value(entityId),
      profileId: Value(profileId),
      localVersion: Value(localVersion),
      remoteVersion: Value(remoteVersion),
      localData: Value(localData),
      remoteData: Value(remoteData),
      detectedAt: Value(detectedAt),
      isResolved: Value(isResolved),
      resolution: resolution == null && nullToAbsent
          ? const Value.absent()
          : Value(resolution),
      resolvedAt: resolvedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(resolvedAt),
    );
  }

  factory SyncConflictRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SyncConflictRow(
      id: serializer.fromJson<String>(json['id']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityId: serializer.fromJson<String>(json['entityId']),
      profileId: serializer.fromJson<String>(json['profileId']),
      localVersion: serializer.fromJson<int>(json['localVersion']),
      remoteVersion: serializer.fromJson<int>(json['remoteVersion']),
      localData: serializer.fromJson<String>(json['localData']),
      remoteData: serializer.fromJson<String>(json['remoteData']),
      detectedAt: serializer.fromJson<int>(json['detectedAt']),
      isResolved: serializer.fromJson<bool>(json['isResolved']),
      resolution: serializer.fromJson<int?>(json['resolution']),
      resolvedAt: serializer.fromJson<int?>(json['resolvedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'entityType': serializer.toJson<String>(entityType),
      'entityId': serializer.toJson<String>(entityId),
      'profileId': serializer.toJson<String>(profileId),
      'localVersion': serializer.toJson<int>(localVersion),
      'remoteVersion': serializer.toJson<int>(remoteVersion),
      'localData': serializer.toJson<String>(localData),
      'remoteData': serializer.toJson<String>(remoteData),
      'detectedAt': serializer.toJson<int>(detectedAt),
      'isResolved': serializer.toJson<bool>(isResolved),
      'resolution': serializer.toJson<int?>(resolution),
      'resolvedAt': serializer.toJson<int?>(resolvedAt),
    };
  }

  SyncConflictRow copyWith({
    String? id,
    String? entityType,
    String? entityId,
    String? profileId,
    int? localVersion,
    int? remoteVersion,
    String? localData,
    String? remoteData,
    int? detectedAt,
    bool? isResolved,
    Value<int?> resolution = const Value.absent(),
    Value<int?> resolvedAt = const Value.absent(),
  }) => SyncConflictRow(
    id: id ?? this.id,
    entityType: entityType ?? this.entityType,
    entityId: entityId ?? this.entityId,
    profileId: profileId ?? this.profileId,
    localVersion: localVersion ?? this.localVersion,
    remoteVersion: remoteVersion ?? this.remoteVersion,
    localData: localData ?? this.localData,
    remoteData: remoteData ?? this.remoteData,
    detectedAt: detectedAt ?? this.detectedAt,
    isResolved: isResolved ?? this.isResolved,
    resolution: resolution.present ? resolution.value : this.resolution,
    resolvedAt: resolvedAt.present ? resolvedAt.value : this.resolvedAt,
  );
  SyncConflictRow copyWithCompanion(SyncConflictsCompanion data) {
    return SyncConflictRow(
      id: data.id.present ? data.id.value : this.id,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityId: data.entityId.present ? data.entityId.value : this.entityId,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      localVersion: data.localVersion.present
          ? data.localVersion.value
          : this.localVersion,
      remoteVersion: data.remoteVersion.present
          ? data.remoteVersion.value
          : this.remoteVersion,
      localData: data.localData.present ? data.localData.value : this.localData,
      remoteData: data.remoteData.present
          ? data.remoteData.value
          : this.remoteData,
      detectedAt: data.detectedAt.present
          ? data.detectedAt.value
          : this.detectedAt,
      isResolved: data.isResolved.present
          ? data.isResolved.value
          : this.isResolved,
      resolution: data.resolution.present
          ? data.resolution.value
          : this.resolution,
      resolvedAt: data.resolvedAt.present
          ? data.resolvedAt.value
          : this.resolvedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SyncConflictRow(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('profileId: $profileId, ')
          ..write('localVersion: $localVersion, ')
          ..write('remoteVersion: $remoteVersion, ')
          ..write('localData: $localData, ')
          ..write('remoteData: $remoteData, ')
          ..write('detectedAt: $detectedAt, ')
          ..write('isResolved: $isResolved, ')
          ..write('resolution: $resolution, ')
          ..write('resolvedAt: $resolvedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    entityType,
    entityId,
    profileId,
    localVersion,
    remoteVersion,
    localData,
    remoteData,
    detectedAt,
    isResolved,
    resolution,
    resolvedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SyncConflictRow &&
          other.id == this.id &&
          other.entityType == this.entityType &&
          other.entityId == this.entityId &&
          other.profileId == this.profileId &&
          other.localVersion == this.localVersion &&
          other.remoteVersion == this.remoteVersion &&
          other.localData == this.localData &&
          other.remoteData == this.remoteData &&
          other.detectedAt == this.detectedAt &&
          other.isResolved == this.isResolved &&
          other.resolution == this.resolution &&
          other.resolvedAt == this.resolvedAt);
}

class SyncConflictsCompanion extends UpdateCompanion<SyncConflictRow> {
  final Value<String> id;
  final Value<String> entityType;
  final Value<String> entityId;
  final Value<String> profileId;
  final Value<int> localVersion;
  final Value<int> remoteVersion;
  final Value<String> localData;
  final Value<String> remoteData;
  final Value<int> detectedAt;
  final Value<bool> isResolved;
  final Value<int?> resolution;
  final Value<int?> resolvedAt;
  final Value<int> rowid;
  const SyncConflictsCompanion({
    this.id = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityId = const Value.absent(),
    this.profileId = const Value.absent(),
    this.localVersion = const Value.absent(),
    this.remoteVersion = const Value.absent(),
    this.localData = const Value.absent(),
    this.remoteData = const Value.absent(),
    this.detectedAt = const Value.absent(),
    this.isResolved = const Value.absent(),
    this.resolution = const Value.absent(),
    this.resolvedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SyncConflictsCompanion.insert({
    required String id,
    required String entityType,
    required String entityId,
    required String profileId,
    required int localVersion,
    required int remoteVersion,
    required String localData,
    required String remoteData,
    required int detectedAt,
    this.isResolved = const Value.absent(),
    this.resolution = const Value.absent(),
    this.resolvedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       entityType = Value(entityType),
       entityId = Value(entityId),
       profileId = Value(profileId),
       localVersion = Value(localVersion),
       remoteVersion = Value(remoteVersion),
       localData = Value(localData),
       remoteData = Value(remoteData),
       detectedAt = Value(detectedAt);
  static Insertable<SyncConflictRow> custom({
    Expression<String>? id,
    Expression<String>? entityType,
    Expression<String>? entityId,
    Expression<String>? profileId,
    Expression<int>? localVersion,
    Expression<int>? remoteVersion,
    Expression<String>? localData,
    Expression<String>? remoteData,
    Expression<int>? detectedAt,
    Expression<bool>? isResolved,
    Expression<int>? resolution,
    Expression<int>? resolvedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (entityType != null) 'entity_type': entityType,
      if (entityId != null) 'entity_id': entityId,
      if (profileId != null) 'profile_id': profileId,
      if (localVersion != null) 'local_version': localVersion,
      if (remoteVersion != null) 'remote_version': remoteVersion,
      if (localData != null) 'local_data': localData,
      if (remoteData != null) 'remote_data': remoteData,
      if (detectedAt != null) 'detected_at': detectedAt,
      if (isResolved != null) 'is_resolved': isResolved,
      if (resolution != null) 'resolution': resolution,
      if (resolvedAt != null) 'resolved_at': resolvedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SyncConflictsCompanion copyWith({
    Value<String>? id,
    Value<String>? entityType,
    Value<String>? entityId,
    Value<String>? profileId,
    Value<int>? localVersion,
    Value<int>? remoteVersion,
    Value<String>? localData,
    Value<String>? remoteData,
    Value<int>? detectedAt,
    Value<bool>? isResolved,
    Value<int?>? resolution,
    Value<int?>? resolvedAt,
    Value<int>? rowid,
  }) {
    return SyncConflictsCompanion(
      id: id ?? this.id,
      entityType: entityType ?? this.entityType,
      entityId: entityId ?? this.entityId,
      profileId: profileId ?? this.profileId,
      localVersion: localVersion ?? this.localVersion,
      remoteVersion: remoteVersion ?? this.remoteVersion,
      localData: localData ?? this.localData,
      remoteData: remoteData ?? this.remoteData,
      detectedAt: detectedAt ?? this.detectedAt,
      isResolved: isResolved ?? this.isResolved,
      resolution: resolution ?? this.resolution,
      resolvedAt: resolvedAt ?? this.resolvedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityId.present) {
      map['entity_id'] = Variable<String>(entityId.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (localVersion.present) {
      map['local_version'] = Variable<int>(localVersion.value);
    }
    if (remoteVersion.present) {
      map['remote_version'] = Variable<int>(remoteVersion.value);
    }
    if (localData.present) {
      map['local_data'] = Variable<String>(localData.value);
    }
    if (remoteData.present) {
      map['remote_data'] = Variable<String>(remoteData.value);
    }
    if (detectedAt.present) {
      map['detected_at'] = Variable<int>(detectedAt.value);
    }
    if (isResolved.present) {
      map['is_resolved'] = Variable<bool>(isResolved.value);
    }
    if (resolution.present) {
      map['resolution'] = Variable<int>(resolution.value);
    }
    if (resolvedAt.present) {
      map['resolved_at'] = Variable<int>(resolvedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncConflictsCompanion(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('profileId: $profileId, ')
          ..write('localVersion: $localVersion, ')
          ..write('remoteVersion: $remoteVersion, ')
          ..write('localData: $localData, ')
          ..write('remoteData: $remoteData, ')
          ..write('detectedAt: $detectedAt, ')
          ..write('isResolved: $isResolved, ')
          ..write('resolution: $resolution, ')
          ..write('resolvedAt: $resolvedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AnchorEventTimesTable extends AnchorEventTimes
    with TableInfo<$AnchorEventTimesTable, AnchorEventTimeRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AnchorEventTimesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<int> name = GeneratedColumn<int>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timeOfDayMeta = const VerificationMeta(
    'timeOfDay',
  );
  @override
  late final GeneratedColumn<String> timeOfDay = GeneratedColumn<String>(
    'time_of_day',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isEnabledMeta = const VerificationMeta(
    'isEnabled',
  );
  @override
  late final GeneratedColumn<bool> isEnabled = GeneratedColumn<bool>(
    'is_enabled',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_enabled" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [id, name, timeOfDay, isEnabled];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'anchor_event_times';
  @override
  VerificationContext validateIntegrity(
    Insertable<AnchorEventTimeRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('time_of_day')) {
      context.handle(
        _timeOfDayMeta,
        timeOfDay.isAcceptableOrUnknown(data['time_of_day']!, _timeOfDayMeta),
      );
    } else if (isInserting) {
      context.missing(_timeOfDayMeta);
    }
    if (data.containsKey('is_enabled')) {
      context.handle(
        _isEnabledMeta,
        isEnabled.isAcceptableOrUnknown(data['is_enabled']!, _isEnabledMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AnchorEventTimeRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AnchorEventTimeRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}name'],
      )!,
      timeOfDay: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}time_of_day'],
      )!,
      isEnabled: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_enabled'],
      )!,
    );
  }

  @override
  $AnchorEventTimesTable createAlias(String alias) {
    return $AnchorEventTimesTable(attachedDatabase, alias);
  }
}

class AnchorEventTimeRow extends DataClass
    implements Insertable<AnchorEventTimeRow> {
  final String id;
  final int name;
  final String timeOfDay;
  final bool isEnabled;
  const AnchorEventTimeRow({
    required this.id,
    required this.name,
    required this.timeOfDay,
    required this.isEnabled,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<int>(name);
    map['time_of_day'] = Variable<String>(timeOfDay);
    map['is_enabled'] = Variable<bool>(isEnabled);
    return map;
  }

  AnchorEventTimesCompanion toCompanion(bool nullToAbsent) {
    return AnchorEventTimesCompanion(
      id: Value(id),
      name: Value(name),
      timeOfDay: Value(timeOfDay),
      isEnabled: Value(isEnabled),
    );
  }

  factory AnchorEventTimeRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AnchorEventTimeRow(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<int>(json['name']),
      timeOfDay: serializer.fromJson<String>(json['timeOfDay']),
      isEnabled: serializer.fromJson<bool>(json['isEnabled']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<int>(name),
      'timeOfDay': serializer.toJson<String>(timeOfDay),
      'isEnabled': serializer.toJson<bool>(isEnabled),
    };
  }

  AnchorEventTimeRow copyWith({
    String? id,
    int? name,
    String? timeOfDay,
    bool? isEnabled,
  }) => AnchorEventTimeRow(
    id: id ?? this.id,
    name: name ?? this.name,
    timeOfDay: timeOfDay ?? this.timeOfDay,
    isEnabled: isEnabled ?? this.isEnabled,
  );
  AnchorEventTimeRow copyWithCompanion(AnchorEventTimesCompanion data) {
    return AnchorEventTimeRow(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      timeOfDay: data.timeOfDay.present ? data.timeOfDay.value : this.timeOfDay,
      isEnabled: data.isEnabled.present ? data.isEnabled.value : this.isEnabled,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AnchorEventTimeRow(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('timeOfDay: $timeOfDay, ')
          ..write('isEnabled: $isEnabled')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, timeOfDay, isEnabled);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AnchorEventTimeRow &&
          other.id == this.id &&
          other.name == this.name &&
          other.timeOfDay == this.timeOfDay &&
          other.isEnabled == this.isEnabled);
}

class AnchorEventTimesCompanion extends UpdateCompanion<AnchorEventTimeRow> {
  final Value<String> id;
  final Value<int> name;
  final Value<String> timeOfDay;
  final Value<bool> isEnabled;
  final Value<int> rowid;
  const AnchorEventTimesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.timeOfDay = const Value.absent(),
    this.isEnabled = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AnchorEventTimesCompanion.insert({
    required String id,
    required int name,
    required String timeOfDay,
    this.isEnabled = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       timeOfDay = Value(timeOfDay);
  static Insertable<AnchorEventTimeRow> custom({
    Expression<String>? id,
    Expression<int>? name,
    Expression<String>? timeOfDay,
    Expression<bool>? isEnabled,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (timeOfDay != null) 'time_of_day': timeOfDay,
      if (isEnabled != null) 'is_enabled': isEnabled,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AnchorEventTimesCompanion copyWith({
    Value<String>? id,
    Value<int>? name,
    Value<String>? timeOfDay,
    Value<bool>? isEnabled,
    Value<int>? rowid,
  }) {
    return AnchorEventTimesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      timeOfDay: timeOfDay ?? this.timeOfDay,
      isEnabled: isEnabled ?? this.isEnabled,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<int>(name.value);
    }
    if (timeOfDay.present) {
      map['time_of_day'] = Variable<String>(timeOfDay.value);
    }
    if (isEnabled.present) {
      map['is_enabled'] = Variable<bool>(isEnabled.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AnchorEventTimesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('timeOfDay: $timeOfDay, ')
          ..write('isEnabled: $isEnabled, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $NotificationCategorySettingsTable extends NotificationCategorySettings
    with
        TableInfo<
          $NotificationCategorySettingsTable,
          NotificationCategorySettingsRow
        > {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $NotificationCategorySettingsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _categoryMeta = const VerificationMeta(
    'category',
  );
  @override
  late final GeneratedColumn<int> category = GeneratedColumn<int>(
    'category',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isEnabledMeta = const VerificationMeta(
    'isEnabled',
  );
  @override
  late final GeneratedColumn<bool> isEnabled = GeneratedColumn<bool>(
    'is_enabled',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_enabled" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _schedulingModeMeta = const VerificationMeta(
    'schedulingMode',
  );
  @override
  late final GeneratedColumn<int> schedulingMode = GeneratedColumn<int>(
    'scheduling_mode',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _anchorEventValuesMeta = const VerificationMeta(
    'anchorEventValues',
  );
  @override
  late final GeneratedColumn<String> anchorEventValues =
      GeneratedColumn<String>(
        'anchor_event_values',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
        defaultValue: const Constant('[]'),
      );
  static const VerificationMeta _intervalHoursMeta = const VerificationMeta(
    'intervalHours',
  );
  @override
  late final GeneratedColumn<int> intervalHours = GeneratedColumn<int>(
    'interval_hours',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _intervalStartTimeMeta = const VerificationMeta(
    'intervalStartTime',
  );
  @override
  late final GeneratedColumn<String> intervalStartTime =
      GeneratedColumn<String>(
        'interval_start_time',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _intervalEndTimeMeta = const VerificationMeta(
    'intervalEndTime',
  );
  @override
  late final GeneratedColumn<String> intervalEndTime = GeneratedColumn<String>(
    'interval_end_time',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _specificTimesMeta = const VerificationMeta(
    'specificTimes',
  );
  @override
  late final GeneratedColumn<String> specificTimes = GeneratedColumn<String>(
    'specific_times',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('[]'),
  );
  static const VerificationMeta _expiresAfterMinutesMeta =
      const VerificationMeta('expiresAfterMinutes');
  @override
  late final GeneratedColumn<int> expiresAfterMinutes = GeneratedColumn<int>(
    'expires_after_minutes',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(60),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    category,
    isEnabled,
    schedulingMode,
    anchorEventValues,
    intervalHours,
    intervalStartTime,
    intervalEndTime,
    specificTimes,
    expiresAfterMinutes,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'notification_category_settings';
  @override
  VerificationContext validateIntegrity(
    Insertable<NotificationCategorySettingsRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('category')) {
      context.handle(
        _categoryMeta,
        category.isAcceptableOrUnknown(data['category']!, _categoryMeta),
      );
    } else if (isInserting) {
      context.missing(_categoryMeta);
    }
    if (data.containsKey('is_enabled')) {
      context.handle(
        _isEnabledMeta,
        isEnabled.isAcceptableOrUnknown(data['is_enabled']!, _isEnabledMeta),
      );
    }
    if (data.containsKey('scheduling_mode')) {
      context.handle(
        _schedulingModeMeta,
        schedulingMode.isAcceptableOrUnknown(
          data['scheduling_mode']!,
          _schedulingModeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_schedulingModeMeta);
    }
    if (data.containsKey('anchor_event_values')) {
      context.handle(
        _anchorEventValuesMeta,
        anchorEventValues.isAcceptableOrUnknown(
          data['anchor_event_values']!,
          _anchorEventValuesMeta,
        ),
      );
    }
    if (data.containsKey('interval_hours')) {
      context.handle(
        _intervalHoursMeta,
        intervalHours.isAcceptableOrUnknown(
          data['interval_hours']!,
          _intervalHoursMeta,
        ),
      );
    }
    if (data.containsKey('interval_start_time')) {
      context.handle(
        _intervalStartTimeMeta,
        intervalStartTime.isAcceptableOrUnknown(
          data['interval_start_time']!,
          _intervalStartTimeMeta,
        ),
      );
    }
    if (data.containsKey('interval_end_time')) {
      context.handle(
        _intervalEndTimeMeta,
        intervalEndTime.isAcceptableOrUnknown(
          data['interval_end_time']!,
          _intervalEndTimeMeta,
        ),
      );
    }
    if (data.containsKey('specific_times')) {
      context.handle(
        _specificTimesMeta,
        specificTimes.isAcceptableOrUnknown(
          data['specific_times']!,
          _specificTimesMeta,
        ),
      );
    }
    if (data.containsKey('expires_after_minutes')) {
      context.handle(
        _expiresAfterMinutesMeta,
        expiresAfterMinutes.isAcceptableOrUnknown(
          data['expires_after_minutes']!,
          _expiresAfterMinutesMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  NotificationCategorySettingsRow map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return NotificationCategorySettingsRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      category: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}category'],
      )!,
      isEnabled: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_enabled'],
      )!,
      schedulingMode: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}scheduling_mode'],
      )!,
      anchorEventValues: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}anchor_event_values'],
      )!,
      intervalHours: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}interval_hours'],
      ),
      intervalStartTime: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}interval_start_time'],
      ),
      intervalEndTime: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}interval_end_time'],
      ),
      specificTimes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}specific_times'],
      )!,
      expiresAfterMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}expires_after_minutes'],
      )!,
    );
  }

  @override
  $NotificationCategorySettingsTable createAlias(String alias) {
    return $NotificationCategorySettingsTable(attachedDatabase, alias);
  }
}

class NotificationCategorySettingsRow extends DataClass
    implements Insertable<NotificationCategorySettingsRow> {
  final String id;
  final int category;
  final bool isEnabled;
  final int schedulingMode;
  final String anchorEventValues;
  final int? intervalHours;
  final String? intervalStartTime;
  final String? intervalEndTime;
  final String specificTimes;
  final int expiresAfterMinutes;
  const NotificationCategorySettingsRow({
    required this.id,
    required this.category,
    required this.isEnabled,
    required this.schedulingMode,
    required this.anchorEventValues,
    this.intervalHours,
    this.intervalStartTime,
    this.intervalEndTime,
    required this.specificTimes,
    required this.expiresAfterMinutes,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['category'] = Variable<int>(category);
    map['is_enabled'] = Variable<bool>(isEnabled);
    map['scheduling_mode'] = Variable<int>(schedulingMode);
    map['anchor_event_values'] = Variable<String>(anchorEventValues);
    if (!nullToAbsent || intervalHours != null) {
      map['interval_hours'] = Variable<int>(intervalHours);
    }
    if (!nullToAbsent || intervalStartTime != null) {
      map['interval_start_time'] = Variable<String>(intervalStartTime);
    }
    if (!nullToAbsent || intervalEndTime != null) {
      map['interval_end_time'] = Variable<String>(intervalEndTime);
    }
    map['specific_times'] = Variable<String>(specificTimes);
    map['expires_after_minutes'] = Variable<int>(expiresAfterMinutes);
    return map;
  }

  NotificationCategorySettingsCompanion toCompanion(bool nullToAbsent) {
    return NotificationCategorySettingsCompanion(
      id: Value(id),
      category: Value(category),
      isEnabled: Value(isEnabled),
      schedulingMode: Value(schedulingMode),
      anchorEventValues: Value(anchorEventValues),
      intervalHours: intervalHours == null && nullToAbsent
          ? const Value.absent()
          : Value(intervalHours),
      intervalStartTime: intervalStartTime == null && nullToAbsent
          ? const Value.absent()
          : Value(intervalStartTime),
      intervalEndTime: intervalEndTime == null && nullToAbsent
          ? const Value.absent()
          : Value(intervalEndTime),
      specificTimes: Value(specificTimes),
      expiresAfterMinutes: Value(expiresAfterMinutes),
    );
  }

  factory NotificationCategorySettingsRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return NotificationCategorySettingsRow(
      id: serializer.fromJson<String>(json['id']),
      category: serializer.fromJson<int>(json['category']),
      isEnabled: serializer.fromJson<bool>(json['isEnabled']),
      schedulingMode: serializer.fromJson<int>(json['schedulingMode']),
      anchorEventValues: serializer.fromJson<String>(json['anchorEventValues']),
      intervalHours: serializer.fromJson<int?>(json['intervalHours']),
      intervalStartTime: serializer.fromJson<String?>(
        json['intervalStartTime'],
      ),
      intervalEndTime: serializer.fromJson<String?>(json['intervalEndTime']),
      specificTimes: serializer.fromJson<String>(json['specificTimes']),
      expiresAfterMinutes: serializer.fromJson<int>(
        json['expiresAfterMinutes'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'category': serializer.toJson<int>(category),
      'isEnabled': serializer.toJson<bool>(isEnabled),
      'schedulingMode': serializer.toJson<int>(schedulingMode),
      'anchorEventValues': serializer.toJson<String>(anchorEventValues),
      'intervalHours': serializer.toJson<int?>(intervalHours),
      'intervalStartTime': serializer.toJson<String?>(intervalStartTime),
      'intervalEndTime': serializer.toJson<String?>(intervalEndTime),
      'specificTimes': serializer.toJson<String>(specificTimes),
      'expiresAfterMinutes': serializer.toJson<int>(expiresAfterMinutes),
    };
  }

  NotificationCategorySettingsRow copyWith({
    String? id,
    int? category,
    bool? isEnabled,
    int? schedulingMode,
    String? anchorEventValues,
    Value<int?> intervalHours = const Value.absent(),
    Value<String?> intervalStartTime = const Value.absent(),
    Value<String?> intervalEndTime = const Value.absent(),
    String? specificTimes,
    int? expiresAfterMinutes,
  }) => NotificationCategorySettingsRow(
    id: id ?? this.id,
    category: category ?? this.category,
    isEnabled: isEnabled ?? this.isEnabled,
    schedulingMode: schedulingMode ?? this.schedulingMode,
    anchorEventValues: anchorEventValues ?? this.anchorEventValues,
    intervalHours: intervalHours.present
        ? intervalHours.value
        : this.intervalHours,
    intervalStartTime: intervalStartTime.present
        ? intervalStartTime.value
        : this.intervalStartTime,
    intervalEndTime: intervalEndTime.present
        ? intervalEndTime.value
        : this.intervalEndTime,
    specificTimes: specificTimes ?? this.specificTimes,
    expiresAfterMinutes: expiresAfterMinutes ?? this.expiresAfterMinutes,
  );
  NotificationCategorySettingsRow copyWithCompanion(
    NotificationCategorySettingsCompanion data,
  ) {
    return NotificationCategorySettingsRow(
      id: data.id.present ? data.id.value : this.id,
      category: data.category.present ? data.category.value : this.category,
      isEnabled: data.isEnabled.present ? data.isEnabled.value : this.isEnabled,
      schedulingMode: data.schedulingMode.present
          ? data.schedulingMode.value
          : this.schedulingMode,
      anchorEventValues: data.anchorEventValues.present
          ? data.anchorEventValues.value
          : this.anchorEventValues,
      intervalHours: data.intervalHours.present
          ? data.intervalHours.value
          : this.intervalHours,
      intervalStartTime: data.intervalStartTime.present
          ? data.intervalStartTime.value
          : this.intervalStartTime,
      intervalEndTime: data.intervalEndTime.present
          ? data.intervalEndTime.value
          : this.intervalEndTime,
      specificTimes: data.specificTimes.present
          ? data.specificTimes.value
          : this.specificTimes,
      expiresAfterMinutes: data.expiresAfterMinutes.present
          ? data.expiresAfterMinutes.value
          : this.expiresAfterMinutes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('NotificationCategorySettingsRow(')
          ..write('id: $id, ')
          ..write('category: $category, ')
          ..write('isEnabled: $isEnabled, ')
          ..write('schedulingMode: $schedulingMode, ')
          ..write('anchorEventValues: $anchorEventValues, ')
          ..write('intervalHours: $intervalHours, ')
          ..write('intervalStartTime: $intervalStartTime, ')
          ..write('intervalEndTime: $intervalEndTime, ')
          ..write('specificTimes: $specificTimes, ')
          ..write('expiresAfterMinutes: $expiresAfterMinutes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    category,
    isEnabled,
    schedulingMode,
    anchorEventValues,
    intervalHours,
    intervalStartTime,
    intervalEndTime,
    specificTimes,
    expiresAfterMinutes,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is NotificationCategorySettingsRow &&
          other.id == this.id &&
          other.category == this.category &&
          other.isEnabled == this.isEnabled &&
          other.schedulingMode == this.schedulingMode &&
          other.anchorEventValues == this.anchorEventValues &&
          other.intervalHours == this.intervalHours &&
          other.intervalStartTime == this.intervalStartTime &&
          other.intervalEndTime == this.intervalEndTime &&
          other.specificTimes == this.specificTimes &&
          other.expiresAfterMinutes == this.expiresAfterMinutes);
}

class NotificationCategorySettingsCompanion
    extends UpdateCompanion<NotificationCategorySettingsRow> {
  final Value<String> id;
  final Value<int> category;
  final Value<bool> isEnabled;
  final Value<int> schedulingMode;
  final Value<String> anchorEventValues;
  final Value<int?> intervalHours;
  final Value<String?> intervalStartTime;
  final Value<String?> intervalEndTime;
  final Value<String> specificTimes;
  final Value<int> expiresAfterMinutes;
  final Value<int> rowid;
  const NotificationCategorySettingsCompanion({
    this.id = const Value.absent(),
    this.category = const Value.absent(),
    this.isEnabled = const Value.absent(),
    this.schedulingMode = const Value.absent(),
    this.anchorEventValues = const Value.absent(),
    this.intervalHours = const Value.absent(),
    this.intervalStartTime = const Value.absent(),
    this.intervalEndTime = const Value.absent(),
    this.specificTimes = const Value.absent(),
    this.expiresAfterMinutes = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  NotificationCategorySettingsCompanion.insert({
    required String id,
    required int category,
    this.isEnabled = const Value.absent(),
    required int schedulingMode,
    this.anchorEventValues = const Value.absent(),
    this.intervalHours = const Value.absent(),
    this.intervalStartTime = const Value.absent(),
    this.intervalEndTime = const Value.absent(),
    this.specificTimes = const Value.absent(),
    this.expiresAfterMinutes = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       category = Value(category),
       schedulingMode = Value(schedulingMode);
  static Insertable<NotificationCategorySettingsRow> custom({
    Expression<String>? id,
    Expression<int>? category,
    Expression<bool>? isEnabled,
    Expression<int>? schedulingMode,
    Expression<String>? anchorEventValues,
    Expression<int>? intervalHours,
    Expression<String>? intervalStartTime,
    Expression<String>? intervalEndTime,
    Expression<String>? specificTimes,
    Expression<int>? expiresAfterMinutes,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (category != null) 'category': category,
      if (isEnabled != null) 'is_enabled': isEnabled,
      if (schedulingMode != null) 'scheduling_mode': schedulingMode,
      if (anchorEventValues != null) 'anchor_event_values': anchorEventValues,
      if (intervalHours != null) 'interval_hours': intervalHours,
      if (intervalStartTime != null) 'interval_start_time': intervalStartTime,
      if (intervalEndTime != null) 'interval_end_time': intervalEndTime,
      if (specificTimes != null) 'specific_times': specificTimes,
      if (expiresAfterMinutes != null)
        'expires_after_minutes': expiresAfterMinutes,
      if (rowid != null) 'rowid': rowid,
    });
  }

  NotificationCategorySettingsCompanion copyWith({
    Value<String>? id,
    Value<int>? category,
    Value<bool>? isEnabled,
    Value<int>? schedulingMode,
    Value<String>? anchorEventValues,
    Value<int?>? intervalHours,
    Value<String?>? intervalStartTime,
    Value<String?>? intervalEndTime,
    Value<String>? specificTimes,
    Value<int>? expiresAfterMinutes,
    Value<int>? rowid,
  }) {
    return NotificationCategorySettingsCompanion(
      id: id ?? this.id,
      category: category ?? this.category,
      isEnabled: isEnabled ?? this.isEnabled,
      schedulingMode: schedulingMode ?? this.schedulingMode,
      anchorEventValues: anchorEventValues ?? this.anchorEventValues,
      intervalHours: intervalHours ?? this.intervalHours,
      intervalStartTime: intervalStartTime ?? this.intervalStartTime,
      intervalEndTime: intervalEndTime ?? this.intervalEndTime,
      specificTimes: specificTimes ?? this.specificTimes,
      expiresAfterMinutes: expiresAfterMinutes ?? this.expiresAfterMinutes,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (category.present) {
      map['category'] = Variable<int>(category.value);
    }
    if (isEnabled.present) {
      map['is_enabled'] = Variable<bool>(isEnabled.value);
    }
    if (schedulingMode.present) {
      map['scheduling_mode'] = Variable<int>(schedulingMode.value);
    }
    if (anchorEventValues.present) {
      map['anchor_event_values'] = Variable<String>(anchorEventValues.value);
    }
    if (intervalHours.present) {
      map['interval_hours'] = Variable<int>(intervalHours.value);
    }
    if (intervalStartTime.present) {
      map['interval_start_time'] = Variable<String>(intervalStartTime.value);
    }
    if (intervalEndTime.present) {
      map['interval_end_time'] = Variable<String>(intervalEndTime.value);
    }
    if (specificTimes.present) {
      map['specific_times'] = Variable<String>(specificTimes.value);
    }
    if (expiresAfterMinutes.present) {
      map['expires_after_minutes'] = Variable<int>(expiresAfterMinutes.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NotificationCategorySettingsCompanion(')
          ..write('id: $id, ')
          ..write('category: $category, ')
          ..write('isEnabled: $isEnabled, ')
          ..write('schedulingMode: $schedulingMode, ')
          ..write('anchorEventValues: $anchorEventValues, ')
          ..write('intervalHours: $intervalHours, ')
          ..write('intervalStartTime: $intervalStartTime, ')
          ..write('intervalEndTime: $intervalEndTime, ')
          ..write('specificTimes: $specificTimes, ')
          ..write('expiresAfterMinutes: $expiresAfterMinutes, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserSettingsTableTable extends UserSettingsTable
    with TableInfo<$UserSettingsTableTable, UserSettingsRow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserSettingsTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _weightUnitMeta = const VerificationMeta(
    'weightUnit',
  );
  @override
  late final GeneratedColumn<int> weightUnit = GeneratedColumn<int>(
    'weight_unit',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _foodWeightUnitMeta = const VerificationMeta(
    'foodWeightUnit',
  );
  @override
  late final GeneratedColumn<int> foodWeightUnit = GeneratedColumn<int>(
    'food_weight_unit',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _fluidUnitMeta = const VerificationMeta(
    'fluidUnit',
  );
  @override
  late final GeneratedColumn<int> fluidUnit = GeneratedColumn<int>(
    'fluid_unit',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _temperatureUnitMeta = const VerificationMeta(
    'temperatureUnit',
  );
  @override
  late final GeneratedColumn<int> temperatureUnit = GeneratedColumn<int>(
    'temperature_unit',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _energyUnitMeta = const VerificationMeta(
    'energyUnit',
  );
  @override
  late final GeneratedColumn<int> energyUnit = GeneratedColumn<int>(
    'energy_unit',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _macroDisplayMeta = const VerificationMeta(
    'macroDisplay',
  );
  @override
  late final GeneratedColumn<int> macroDisplay = GeneratedColumn<int>(
    'macro_display',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _appLockEnabledMeta = const VerificationMeta(
    'appLockEnabled',
  );
  @override
  late final GeneratedColumn<bool> appLockEnabled = GeneratedColumn<bool>(
    'app_lock_enabled',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("app_lock_enabled" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _biometricEnabledMeta = const VerificationMeta(
    'biometricEnabled',
  );
  @override
  late final GeneratedColumn<bool> biometricEnabled = GeneratedColumn<bool>(
    'biometric_enabled',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("biometric_enabled" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _autoLockMinutesMeta = const VerificationMeta(
    'autoLockMinutes',
  );
  @override
  late final GeneratedColumn<int> autoLockMinutes = GeneratedColumn<int>(
    'auto_lock_minutes',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(5),
  );
  static const VerificationMeta _hideInAppSwitcherMeta = const VerificationMeta(
    'hideInAppSwitcher',
  );
  @override
  late final GeneratedColumn<bool> hideInAppSwitcher = GeneratedColumn<bool>(
    'hide_in_app_switcher',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("hide_in_app_switcher" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _allowBiometricBypassPinMeta =
      const VerificationMeta('allowBiometricBypassPin');
  @override
  late final GeneratedColumn<bool> allowBiometricBypassPin =
      GeneratedColumn<bool>(
        'allow_biometric_bypass_pin',
        aliasedName,
        false,
        type: DriftSqlType.bool,
        requiredDuringInsert: false,
        defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("allow_biometric_bypass_pin" IN (0, 1))',
        ),
        defaultValue: const Constant(false),
      );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    weightUnit,
    foodWeightUnit,
    fluidUnit,
    temperatureUnit,
    energyUnit,
    macroDisplay,
    appLockEnabled,
    biometricEnabled,
    autoLockMinutes,
    hideInAppSwitcher,
    allowBiometricBypassPin,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_settings';
  @override
  VerificationContext validateIntegrity(
    Insertable<UserSettingsRow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('weight_unit')) {
      context.handle(
        _weightUnitMeta,
        weightUnit.isAcceptableOrUnknown(data['weight_unit']!, _weightUnitMeta),
      );
    }
    if (data.containsKey('food_weight_unit')) {
      context.handle(
        _foodWeightUnitMeta,
        foodWeightUnit.isAcceptableOrUnknown(
          data['food_weight_unit']!,
          _foodWeightUnitMeta,
        ),
      );
    }
    if (data.containsKey('fluid_unit')) {
      context.handle(
        _fluidUnitMeta,
        fluidUnit.isAcceptableOrUnknown(data['fluid_unit']!, _fluidUnitMeta),
      );
    }
    if (data.containsKey('temperature_unit')) {
      context.handle(
        _temperatureUnitMeta,
        temperatureUnit.isAcceptableOrUnknown(
          data['temperature_unit']!,
          _temperatureUnitMeta,
        ),
      );
    }
    if (data.containsKey('energy_unit')) {
      context.handle(
        _energyUnitMeta,
        energyUnit.isAcceptableOrUnknown(data['energy_unit']!, _energyUnitMeta),
      );
    }
    if (data.containsKey('macro_display')) {
      context.handle(
        _macroDisplayMeta,
        macroDisplay.isAcceptableOrUnknown(
          data['macro_display']!,
          _macroDisplayMeta,
        ),
      );
    }
    if (data.containsKey('app_lock_enabled')) {
      context.handle(
        _appLockEnabledMeta,
        appLockEnabled.isAcceptableOrUnknown(
          data['app_lock_enabled']!,
          _appLockEnabledMeta,
        ),
      );
    }
    if (data.containsKey('biometric_enabled')) {
      context.handle(
        _biometricEnabledMeta,
        biometricEnabled.isAcceptableOrUnknown(
          data['biometric_enabled']!,
          _biometricEnabledMeta,
        ),
      );
    }
    if (data.containsKey('auto_lock_minutes')) {
      context.handle(
        _autoLockMinutesMeta,
        autoLockMinutes.isAcceptableOrUnknown(
          data['auto_lock_minutes']!,
          _autoLockMinutesMeta,
        ),
      );
    }
    if (data.containsKey('hide_in_app_switcher')) {
      context.handle(
        _hideInAppSwitcherMeta,
        hideInAppSwitcher.isAcceptableOrUnknown(
          data['hide_in_app_switcher']!,
          _hideInAppSwitcherMeta,
        ),
      );
    }
    if (data.containsKey('allow_biometric_bypass_pin')) {
      context.handle(
        _allowBiometricBypassPinMeta,
        allowBiometricBypassPin.isAcceptableOrUnknown(
          data['allow_biometric_bypass_pin']!,
          _allowBiometricBypassPinMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UserSettingsRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserSettingsRow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      weightUnit: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}weight_unit'],
      )!,
      foodWeightUnit: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}food_weight_unit'],
      )!,
      fluidUnit: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}fluid_unit'],
      )!,
      temperatureUnit: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}temperature_unit'],
      )!,
      energyUnit: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}energy_unit'],
      )!,
      macroDisplay: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}macro_display'],
      )!,
      appLockEnabled: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}app_lock_enabled'],
      )!,
      biometricEnabled: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}biometric_enabled'],
      )!,
      autoLockMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}auto_lock_minutes'],
      )!,
      hideInAppSwitcher: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}hide_in_app_switcher'],
      )!,
      allowBiometricBypassPin: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}allow_biometric_bypass_pin'],
      )!,
    );
  }

  @override
  $UserSettingsTableTable createAlias(String alias) {
    return $UserSettingsTableTable(attachedDatabase, alias);
  }
}

class UserSettingsRow extends DataClass implements Insertable<UserSettingsRow> {
  final String id;
  final int weightUnit;
  final int foodWeightUnit;
  final int fluidUnit;
  final int temperatureUnit;
  final int energyUnit;
  final int macroDisplay;
  final bool appLockEnabled;
  final bool biometricEnabled;
  final int autoLockMinutes;
  final bool hideInAppSwitcher;
  final bool allowBiometricBypassPin;
  const UserSettingsRow({
    required this.id,
    required this.weightUnit,
    required this.foodWeightUnit,
    required this.fluidUnit,
    required this.temperatureUnit,
    required this.energyUnit,
    required this.macroDisplay,
    required this.appLockEnabled,
    required this.biometricEnabled,
    required this.autoLockMinutes,
    required this.hideInAppSwitcher,
    required this.allowBiometricBypassPin,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['weight_unit'] = Variable<int>(weightUnit);
    map['food_weight_unit'] = Variable<int>(foodWeightUnit);
    map['fluid_unit'] = Variable<int>(fluidUnit);
    map['temperature_unit'] = Variable<int>(temperatureUnit);
    map['energy_unit'] = Variable<int>(energyUnit);
    map['macro_display'] = Variable<int>(macroDisplay);
    map['app_lock_enabled'] = Variable<bool>(appLockEnabled);
    map['biometric_enabled'] = Variable<bool>(biometricEnabled);
    map['auto_lock_minutes'] = Variable<int>(autoLockMinutes);
    map['hide_in_app_switcher'] = Variable<bool>(hideInAppSwitcher);
    map['allow_biometric_bypass_pin'] = Variable<bool>(allowBiometricBypassPin);
    return map;
  }

  UserSettingsTableCompanion toCompanion(bool nullToAbsent) {
    return UserSettingsTableCompanion(
      id: Value(id),
      weightUnit: Value(weightUnit),
      foodWeightUnit: Value(foodWeightUnit),
      fluidUnit: Value(fluidUnit),
      temperatureUnit: Value(temperatureUnit),
      energyUnit: Value(energyUnit),
      macroDisplay: Value(macroDisplay),
      appLockEnabled: Value(appLockEnabled),
      biometricEnabled: Value(biometricEnabled),
      autoLockMinutes: Value(autoLockMinutes),
      hideInAppSwitcher: Value(hideInAppSwitcher),
      allowBiometricBypassPin: Value(allowBiometricBypassPin),
    );
  }

  factory UserSettingsRow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserSettingsRow(
      id: serializer.fromJson<String>(json['id']),
      weightUnit: serializer.fromJson<int>(json['weightUnit']),
      foodWeightUnit: serializer.fromJson<int>(json['foodWeightUnit']),
      fluidUnit: serializer.fromJson<int>(json['fluidUnit']),
      temperatureUnit: serializer.fromJson<int>(json['temperatureUnit']),
      energyUnit: serializer.fromJson<int>(json['energyUnit']),
      macroDisplay: serializer.fromJson<int>(json['macroDisplay']),
      appLockEnabled: serializer.fromJson<bool>(json['appLockEnabled']),
      biometricEnabled: serializer.fromJson<bool>(json['biometricEnabled']),
      autoLockMinutes: serializer.fromJson<int>(json['autoLockMinutes']),
      hideInAppSwitcher: serializer.fromJson<bool>(json['hideInAppSwitcher']),
      allowBiometricBypassPin: serializer.fromJson<bool>(
        json['allowBiometricBypassPin'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'weightUnit': serializer.toJson<int>(weightUnit),
      'foodWeightUnit': serializer.toJson<int>(foodWeightUnit),
      'fluidUnit': serializer.toJson<int>(fluidUnit),
      'temperatureUnit': serializer.toJson<int>(temperatureUnit),
      'energyUnit': serializer.toJson<int>(energyUnit),
      'macroDisplay': serializer.toJson<int>(macroDisplay),
      'appLockEnabled': serializer.toJson<bool>(appLockEnabled),
      'biometricEnabled': serializer.toJson<bool>(biometricEnabled),
      'autoLockMinutes': serializer.toJson<int>(autoLockMinutes),
      'hideInAppSwitcher': serializer.toJson<bool>(hideInAppSwitcher),
      'allowBiometricBypassPin': serializer.toJson<bool>(
        allowBiometricBypassPin,
      ),
    };
  }

  UserSettingsRow copyWith({
    String? id,
    int? weightUnit,
    int? foodWeightUnit,
    int? fluidUnit,
    int? temperatureUnit,
    int? energyUnit,
    int? macroDisplay,
    bool? appLockEnabled,
    bool? biometricEnabled,
    int? autoLockMinutes,
    bool? hideInAppSwitcher,
    bool? allowBiometricBypassPin,
  }) => UserSettingsRow(
    id: id ?? this.id,
    weightUnit: weightUnit ?? this.weightUnit,
    foodWeightUnit: foodWeightUnit ?? this.foodWeightUnit,
    fluidUnit: fluidUnit ?? this.fluidUnit,
    temperatureUnit: temperatureUnit ?? this.temperatureUnit,
    energyUnit: energyUnit ?? this.energyUnit,
    macroDisplay: macroDisplay ?? this.macroDisplay,
    appLockEnabled: appLockEnabled ?? this.appLockEnabled,
    biometricEnabled: biometricEnabled ?? this.biometricEnabled,
    autoLockMinutes: autoLockMinutes ?? this.autoLockMinutes,
    hideInAppSwitcher: hideInAppSwitcher ?? this.hideInAppSwitcher,
    allowBiometricBypassPin:
        allowBiometricBypassPin ?? this.allowBiometricBypassPin,
  );
  UserSettingsRow copyWithCompanion(UserSettingsTableCompanion data) {
    return UserSettingsRow(
      id: data.id.present ? data.id.value : this.id,
      weightUnit: data.weightUnit.present
          ? data.weightUnit.value
          : this.weightUnit,
      foodWeightUnit: data.foodWeightUnit.present
          ? data.foodWeightUnit.value
          : this.foodWeightUnit,
      fluidUnit: data.fluidUnit.present ? data.fluidUnit.value : this.fluidUnit,
      temperatureUnit: data.temperatureUnit.present
          ? data.temperatureUnit.value
          : this.temperatureUnit,
      energyUnit: data.energyUnit.present
          ? data.energyUnit.value
          : this.energyUnit,
      macroDisplay: data.macroDisplay.present
          ? data.macroDisplay.value
          : this.macroDisplay,
      appLockEnabled: data.appLockEnabled.present
          ? data.appLockEnabled.value
          : this.appLockEnabled,
      biometricEnabled: data.biometricEnabled.present
          ? data.biometricEnabled.value
          : this.biometricEnabled,
      autoLockMinutes: data.autoLockMinutes.present
          ? data.autoLockMinutes.value
          : this.autoLockMinutes,
      hideInAppSwitcher: data.hideInAppSwitcher.present
          ? data.hideInAppSwitcher.value
          : this.hideInAppSwitcher,
      allowBiometricBypassPin: data.allowBiometricBypassPin.present
          ? data.allowBiometricBypassPin.value
          : this.allowBiometricBypassPin,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserSettingsRow(')
          ..write('id: $id, ')
          ..write('weightUnit: $weightUnit, ')
          ..write('foodWeightUnit: $foodWeightUnit, ')
          ..write('fluidUnit: $fluidUnit, ')
          ..write('temperatureUnit: $temperatureUnit, ')
          ..write('energyUnit: $energyUnit, ')
          ..write('macroDisplay: $macroDisplay, ')
          ..write('appLockEnabled: $appLockEnabled, ')
          ..write('biometricEnabled: $biometricEnabled, ')
          ..write('autoLockMinutes: $autoLockMinutes, ')
          ..write('hideInAppSwitcher: $hideInAppSwitcher, ')
          ..write('allowBiometricBypassPin: $allowBiometricBypassPin')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    weightUnit,
    foodWeightUnit,
    fluidUnit,
    temperatureUnit,
    energyUnit,
    macroDisplay,
    appLockEnabled,
    biometricEnabled,
    autoLockMinutes,
    hideInAppSwitcher,
    allowBiometricBypassPin,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserSettingsRow &&
          other.id == this.id &&
          other.weightUnit == this.weightUnit &&
          other.foodWeightUnit == this.foodWeightUnit &&
          other.fluidUnit == this.fluidUnit &&
          other.temperatureUnit == this.temperatureUnit &&
          other.energyUnit == this.energyUnit &&
          other.macroDisplay == this.macroDisplay &&
          other.appLockEnabled == this.appLockEnabled &&
          other.biometricEnabled == this.biometricEnabled &&
          other.autoLockMinutes == this.autoLockMinutes &&
          other.hideInAppSwitcher == this.hideInAppSwitcher &&
          other.allowBiometricBypassPin == this.allowBiometricBypassPin);
}

class UserSettingsTableCompanion extends UpdateCompanion<UserSettingsRow> {
  final Value<String> id;
  final Value<int> weightUnit;
  final Value<int> foodWeightUnit;
  final Value<int> fluidUnit;
  final Value<int> temperatureUnit;
  final Value<int> energyUnit;
  final Value<int> macroDisplay;
  final Value<bool> appLockEnabled;
  final Value<bool> biometricEnabled;
  final Value<int> autoLockMinutes;
  final Value<bool> hideInAppSwitcher;
  final Value<bool> allowBiometricBypassPin;
  final Value<int> rowid;
  const UserSettingsTableCompanion({
    this.id = const Value.absent(),
    this.weightUnit = const Value.absent(),
    this.foodWeightUnit = const Value.absent(),
    this.fluidUnit = const Value.absent(),
    this.temperatureUnit = const Value.absent(),
    this.energyUnit = const Value.absent(),
    this.macroDisplay = const Value.absent(),
    this.appLockEnabled = const Value.absent(),
    this.biometricEnabled = const Value.absent(),
    this.autoLockMinutes = const Value.absent(),
    this.hideInAppSwitcher = const Value.absent(),
    this.allowBiometricBypassPin = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserSettingsTableCompanion.insert({
    required String id,
    this.weightUnit = const Value.absent(),
    this.foodWeightUnit = const Value.absent(),
    this.fluidUnit = const Value.absent(),
    this.temperatureUnit = const Value.absent(),
    this.energyUnit = const Value.absent(),
    this.macroDisplay = const Value.absent(),
    this.appLockEnabled = const Value.absent(),
    this.biometricEnabled = const Value.absent(),
    this.autoLockMinutes = const Value.absent(),
    this.hideInAppSwitcher = const Value.absent(),
    this.allowBiometricBypassPin = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<UserSettingsRow> custom({
    Expression<String>? id,
    Expression<int>? weightUnit,
    Expression<int>? foodWeightUnit,
    Expression<int>? fluidUnit,
    Expression<int>? temperatureUnit,
    Expression<int>? energyUnit,
    Expression<int>? macroDisplay,
    Expression<bool>? appLockEnabled,
    Expression<bool>? biometricEnabled,
    Expression<int>? autoLockMinutes,
    Expression<bool>? hideInAppSwitcher,
    Expression<bool>? allowBiometricBypassPin,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (weightUnit != null) 'weight_unit': weightUnit,
      if (foodWeightUnit != null) 'food_weight_unit': foodWeightUnit,
      if (fluidUnit != null) 'fluid_unit': fluidUnit,
      if (temperatureUnit != null) 'temperature_unit': temperatureUnit,
      if (energyUnit != null) 'energy_unit': energyUnit,
      if (macroDisplay != null) 'macro_display': macroDisplay,
      if (appLockEnabled != null) 'app_lock_enabled': appLockEnabled,
      if (biometricEnabled != null) 'biometric_enabled': biometricEnabled,
      if (autoLockMinutes != null) 'auto_lock_minutes': autoLockMinutes,
      if (hideInAppSwitcher != null) 'hide_in_app_switcher': hideInAppSwitcher,
      if (allowBiometricBypassPin != null)
        'allow_biometric_bypass_pin': allowBiometricBypassPin,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserSettingsTableCompanion copyWith({
    Value<String>? id,
    Value<int>? weightUnit,
    Value<int>? foodWeightUnit,
    Value<int>? fluidUnit,
    Value<int>? temperatureUnit,
    Value<int>? energyUnit,
    Value<int>? macroDisplay,
    Value<bool>? appLockEnabled,
    Value<bool>? biometricEnabled,
    Value<int>? autoLockMinutes,
    Value<bool>? hideInAppSwitcher,
    Value<bool>? allowBiometricBypassPin,
    Value<int>? rowid,
  }) {
    return UserSettingsTableCompanion(
      id: id ?? this.id,
      weightUnit: weightUnit ?? this.weightUnit,
      foodWeightUnit: foodWeightUnit ?? this.foodWeightUnit,
      fluidUnit: fluidUnit ?? this.fluidUnit,
      temperatureUnit: temperatureUnit ?? this.temperatureUnit,
      energyUnit: energyUnit ?? this.energyUnit,
      macroDisplay: macroDisplay ?? this.macroDisplay,
      appLockEnabled: appLockEnabled ?? this.appLockEnabled,
      biometricEnabled: biometricEnabled ?? this.biometricEnabled,
      autoLockMinutes: autoLockMinutes ?? this.autoLockMinutes,
      hideInAppSwitcher: hideInAppSwitcher ?? this.hideInAppSwitcher,
      allowBiometricBypassPin:
          allowBiometricBypassPin ?? this.allowBiometricBypassPin,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (weightUnit.present) {
      map['weight_unit'] = Variable<int>(weightUnit.value);
    }
    if (foodWeightUnit.present) {
      map['food_weight_unit'] = Variable<int>(foodWeightUnit.value);
    }
    if (fluidUnit.present) {
      map['fluid_unit'] = Variable<int>(fluidUnit.value);
    }
    if (temperatureUnit.present) {
      map['temperature_unit'] = Variable<int>(temperatureUnit.value);
    }
    if (energyUnit.present) {
      map['energy_unit'] = Variable<int>(energyUnit.value);
    }
    if (macroDisplay.present) {
      map['macro_display'] = Variable<int>(macroDisplay.value);
    }
    if (appLockEnabled.present) {
      map['app_lock_enabled'] = Variable<bool>(appLockEnabled.value);
    }
    if (biometricEnabled.present) {
      map['biometric_enabled'] = Variable<bool>(biometricEnabled.value);
    }
    if (autoLockMinutes.present) {
      map['auto_lock_minutes'] = Variable<int>(autoLockMinutes.value);
    }
    if (hideInAppSwitcher.present) {
      map['hide_in_app_switcher'] = Variable<bool>(hideInAppSwitcher.value);
    }
    if (allowBiometricBypassPin.present) {
      map['allow_biometric_bypass_pin'] = Variable<bool>(
        allowBiometricBypassPin.value,
      );
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserSettingsTableCompanion(')
          ..write('id: $id, ')
          ..write('weightUnit: $weightUnit, ')
          ..write('foodWeightUnit: $foodWeightUnit, ')
          ..write('fluidUnit: $fluidUnit, ')
          ..write('temperatureUnit: $temperatureUnit, ')
          ..write('energyUnit: $energyUnit, ')
          ..write('macroDisplay: $macroDisplay, ')
          ..write('appLockEnabled: $appLockEnabled, ')
          ..write('biometricEnabled: $biometricEnabled, ')
          ..write('autoLockMinutes: $autoLockMinutes, ')
          ..write('hideInAppSwitcher: $hideInAppSwitcher, ')
          ..write('allowBiometricBypassPin: $allowBiometricBypassPin, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $SupplementsTable supplements = $SupplementsTable(this);
  late final $IntakeLogsTable intakeLogs = $IntakeLogsTable(this);
  late final $ConditionsTable conditions = $ConditionsTable(this);
  late final $ConditionLogsTable conditionLogs = $ConditionLogsTable(this);
  late final $FlareUpsTable flareUps = $FlareUpsTable(this);
  late final $FluidsEntriesTable fluidsEntries = $FluidsEntriesTable(this);
  late final $SleepEntriesTable sleepEntries = $SleepEntriesTable(this);
  late final $ActivitiesTable activities = $ActivitiesTable(this);
  late final $ActivityLogsTable activityLogs = $ActivityLogsTable(this);
  late final $FoodItemsTable foodItems = $FoodItemsTable(this);
  late final $FoodItemComponentsTable foodItemComponents =
      $FoodItemComponentsTable(this);
  late final $FoodBarcodeCacheTable foodBarcodeCache = $FoodBarcodeCacheTable(
    this,
  );
  late final $FoodLogsTable foodLogs = $FoodLogsTable(this);
  late final $JournalEntriesTable journalEntries = $JournalEntriesTable(this);
  late final $PhotoAreasTable photoAreas = $PhotoAreasTable(this);
  late final $PhotoEntriesTable photoEntries = $PhotoEntriesTable(this);
  late final $ProfilesTable profiles = $ProfilesTable(this);
  late final $GuestInvitesTable guestInvites = $GuestInvitesTable(this);
  late final $SupplementLabelPhotosTable supplementLabelPhotos =
      $SupplementLabelPhotosTable(this);
  late final $SupplementBarcodeCacheTable supplementBarcodeCache =
      $SupplementBarcodeCacheTable(this);
  late final $SyncConflictsTable syncConflicts = $SyncConflictsTable(this);
  late final $AnchorEventTimesTable anchorEventTimes = $AnchorEventTimesTable(
    this,
  );
  late final $NotificationCategorySettingsTable notificationCategorySettings =
      $NotificationCategorySettingsTable(this);
  late final $UserSettingsTableTable userSettingsTable =
      $UserSettingsTableTable(this);
  late final SupplementDao supplementDao = SupplementDao(this as AppDatabase);
  late final IntakeLogDao intakeLogDao = IntakeLogDao(this as AppDatabase);
  late final ConditionDao conditionDao = ConditionDao(this as AppDatabase);
  late final ConditionLogDao conditionLogDao = ConditionLogDao(
    this as AppDatabase,
  );
  late final FlareUpDao flareUpDao = FlareUpDao(this as AppDatabase);
  late final FluidsEntryDao fluidsEntryDao = FluidsEntryDao(
    this as AppDatabase,
  );
  late final SleepEntryDao sleepEntryDao = SleepEntryDao(this as AppDatabase);
  late final ActivityDao activityDao = ActivityDao(this as AppDatabase);
  late final ActivityLogDao activityLogDao = ActivityLogDao(
    this as AppDatabase,
  );
  late final FoodItemDao foodItemDao = FoodItemDao(this as AppDatabase);
  late final FoodItemComponentDao foodItemComponentDao = FoodItemComponentDao(
    this as AppDatabase,
  );
  late final FoodBarcodeCacheDao foodBarcodeCacheDao = FoodBarcodeCacheDao(
    this as AppDatabase,
  );
  late final FoodLogDao foodLogDao = FoodLogDao(this as AppDatabase);
  late final JournalEntryDao journalEntryDao = JournalEntryDao(
    this as AppDatabase,
  );
  late final PhotoAreaDao photoAreaDao = PhotoAreaDao(this as AppDatabase);
  late final PhotoEntryDao photoEntryDao = PhotoEntryDao(this as AppDatabase);
  late final ProfileDao profileDao = ProfileDao(this as AppDatabase);
  late final GuestInviteDao guestInviteDao = GuestInviteDao(
    this as AppDatabase,
  );
  late final SupplementLabelPhotoDao supplementLabelPhotoDao =
      SupplementLabelPhotoDao(this as AppDatabase);
  late final SupplementBarcodeCacheDao supplementBarcodeCacheDao =
      SupplementBarcodeCacheDao(this as AppDatabase);
  late final SyncConflictDao syncConflictDao = SyncConflictDao(
    this as AppDatabase,
  );
  late final AnchorEventTimeDao anchorEventTimeDao = AnchorEventTimeDao(
    this as AppDatabase,
  );
  late final NotificationCategorySettingsDao notificationCategorySettingsDao =
      NotificationCategorySettingsDao(this as AppDatabase);
  late final UserSettingsDao userSettingsDao = UserSettingsDao(
    this as AppDatabase,
  );
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    supplements,
    intakeLogs,
    conditions,
    conditionLogs,
    flareUps,
    fluidsEntries,
    sleepEntries,
    activities,
    activityLogs,
    foodItems,
    foodItemComponents,
    foodBarcodeCache,
    foodLogs,
    journalEntries,
    photoAreas,
    photoEntries,
    profiles,
    guestInvites,
    supplementLabelPhotos,
    supplementBarcodeCache,
    syncConflicts,
    anchorEventTimes,
    notificationCategorySettings,
    userSettingsTable,
  ];
}

typedef $$SupplementsTableCreateCompanionBuilder =
    SupplementsCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required String name,
      required int form,
      required int dosageQuantity,
      required int dosageUnit,
      Value<String?> customForm,
      Value<String?> customDosageUnit,
      Value<String> brand,
      Value<String> notes,
      Value<String> ingredients,
      Value<String> schedules,
      Value<int?> startDate,
      Value<int?> endDate,
      Value<bool> isArchived,
      Value<String?> source,
      Value<double?> pricePaid,
      Value<String?> barcode,
      Value<String?> importSource,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$SupplementsTableUpdateCompanionBuilder =
    SupplementsCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<String> name,
      Value<int> form,
      Value<int> dosageQuantity,
      Value<int> dosageUnit,
      Value<String?> customForm,
      Value<String?> customDosageUnit,
      Value<String> brand,
      Value<String> notes,
      Value<String> ingredients,
      Value<String> schedules,
      Value<int?> startDate,
      Value<int?> endDate,
      Value<bool> isArchived,
      Value<String?> source,
      Value<double?> pricePaid,
      Value<String?> barcode,
      Value<String?> importSource,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$SupplementsTableFilterComposer
    extends Composer<_$AppDatabase, $SupplementsTable> {
  $$SupplementsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get form => $composableBuilder(
    column: $table.form,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dosageQuantity => $composableBuilder(
    column: $table.dosageQuantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dosageUnit => $composableBuilder(
    column: $table.dosageUnit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get customForm => $composableBuilder(
    column: $table.customForm,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get customDosageUnit => $composableBuilder(
    column: $table.customDosageUnit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get brand => $composableBuilder(
    column: $table.brand,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ingredients => $composableBuilder(
    column: $table.ingredients,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get schedules => $composableBuilder(
    column: $table.schedules,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get startDate => $composableBuilder(
    column: $table.startDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endDate => $composableBuilder(
    column: $table.endDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get pricePaid => $composableBuilder(
    column: $table.pricePaid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get barcode => $composableBuilder(
    column: $table.barcode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SupplementsTableOrderingComposer
    extends Composer<_$AppDatabase, $SupplementsTable> {
  $$SupplementsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get form => $composableBuilder(
    column: $table.form,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dosageQuantity => $composableBuilder(
    column: $table.dosageQuantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dosageUnit => $composableBuilder(
    column: $table.dosageUnit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get customForm => $composableBuilder(
    column: $table.customForm,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get customDosageUnit => $composableBuilder(
    column: $table.customDosageUnit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get brand => $composableBuilder(
    column: $table.brand,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ingredients => $composableBuilder(
    column: $table.ingredients,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get schedules => $composableBuilder(
    column: $table.schedules,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get startDate => $composableBuilder(
    column: $table.startDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endDate => $composableBuilder(
    column: $table.endDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get pricePaid => $composableBuilder(
    column: $table.pricePaid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get barcode => $composableBuilder(
    column: $table.barcode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SupplementsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SupplementsTable> {
  $$SupplementsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get form =>
      $composableBuilder(column: $table.form, builder: (column) => column);

  GeneratedColumn<int> get dosageQuantity => $composableBuilder(
    column: $table.dosageQuantity,
    builder: (column) => column,
  );

  GeneratedColumn<int> get dosageUnit => $composableBuilder(
    column: $table.dosageUnit,
    builder: (column) => column,
  );

  GeneratedColumn<String> get customForm => $composableBuilder(
    column: $table.customForm,
    builder: (column) => column,
  );

  GeneratedColumn<String> get customDosageUnit => $composableBuilder(
    column: $table.customDosageUnit,
    builder: (column) => column,
  );

  GeneratedColumn<String> get brand =>
      $composableBuilder(column: $table.brand, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get ingredients => $composableBuilder(
    column: $table.ingredients,
    builder: (column) => column,
  );

  GeneratedColumn<String> get schedules =>
      $composableBuilder(column: $table.schedules, builder: (column) => column);

  GeneratedColumn<int> get startDate =>
      $composableBuilder(column: $table.startDate, builder: (column) => column);

  GeneratedColumn<int> get endDate =>
      $composableBuilder(column: $table.endDate, builder: (column) => column);

  GeneratedColumn<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => column,
  );

  GeneratedColumn<String> get source =>
      $composableBuilder(column: $table.source, builder: (column) => column);

  GeneratedColumn<double> get pricePaid =>
      $composableBuilder(column: $table.pricePaid, builder: (column) => column);

  GeneratedColumn<String> get barcode =>
      $composableBuilder(column: $table.barcode, builder: (column) => column);

  GeneratedColumn<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$SupplementsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SupplementsTable,
          SupplementRow,
          $$SupplementsTableFilterComposer,
          $$SupplementsTableOrderingComposer,
          $$SupplementsTableAnnotationComposer,
          $$SupplementsTableCreateCompanionBuilder,
          $$SupplementsTableUpdateCompanionBuilder,
          (
            SupplementRow,
            BaseReferences<_$AppDatabase, $SupplementsTable, SupplementRow>,
          ),
          SupplementRow,
          PrefetchHooks Function()
        > {
  $$SupplementsTableTableManager(_$AppDatabase db, $SupplementsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SupplementsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SupplementsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SupplementsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> form = const Value.absent(),
                Value<int> dosageQuantity = const Value.absent(),
                Value<int> dosageUnit = const Value.absent(),
                Value<String?> customForm = const Value.absent(),
                Value<String?> customDosageUnit = const Value.absent(),
                Value<String> brand = const Value.absent(),
                Value<String> notes = const Value.absent(),
                Value<String> ingredients = const Value.absent(),
                Value<String> schedules = const Value.absent(),
                Value<int?> startDate = const Value.absent(),
                Value<int?> endDate = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                Value<String?> source = const Value.absent(),
                Value<double?> pricePaid = const Value.absent(),
                Value<String?> barcode = const Value.absent(),
                Value<String?> importSource = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SupplementsCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                name: name,
                form: form,
                dosageQuantity: dosageQuantity,
                dosageUnit: dosageUnit,
                customForm: customForm,
                customDosageUnit: customDosageUnit,
                brand: brand,
                notes: notes,
                ingredients: ingredients,
                schedules: schedules,
                startDate: startDate,
                endDate: endDate,
                isArchived: isArchived,
                source: source,
                pricePaid: pricePaid,
                barcode: barcode,
                importSource: importSource,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required String name,
                required int form,
                required int dosageQuantity,
                required int dosageUnit,
                Value<String?> customForm = const Value.absent(),
                Value<String?> customDosageUnit = const Value.absent(),
                Value<String> brand = const Value.absent(),
                Value<String> notes = const Value.absent(),
                Value<String> ingredients = const Value.absent(),
                Value<String> schedules = const Value.absent(),
                Value<int?> startDate = const Value.absent(),
                Value<int?> endDate = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                Value<String?> source = const Value.absent(),
                Value<double?> pricePaid = const Value.absent(),
                Value<String?> barcode = const Value.absent(),
                Value<String?> importSource = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SupplementsCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                name: name,
                form: form,
                dosageQuantity: dosageQuantity,
                dosageUnit: dosageUnit,
                customForm: customForm,
                customDosageUnit: customDosageUnit,
                brand: brand,
                notes: notes,
                ingredients: ingredients,
                schedules: schedules,
                startDate: startDate,
                endDate: endDate,
                isArchived: isArchived,
                source: source,
                pricePaid: pricePaid,
                barcode: barcode,
                importSource: importSource,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SupplementsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SupplementsTable,
      SupplementRow,
      $$SupplementsTableFilterComposer,
      $$SupplementsTableOrderingComposer,
      $$SupplementsTableAnnotationComposer,
      $$SupplementsTableCreateCompanionBuilder,
      $$SupplementsTableUpdateCompanionBuilder,
      (
        SupplementRow,
        BaseReferences<_$AppDatabase, $SupplementsTable, SupplementRow>,
      ),
      SupplementRow,
      PrefetchHooks Function()
    >;
typedef $$IntakeLogsTableCreateCompanionBuilder =
    IntakeLogsCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required String supplementId,
      required int scheduledTime,
      required int status,
      Value<int?> actualTime,
      Value<String?> reason,
      Value<String?> note,
      Value<int?> snoozeDurationMinutes,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$IntakeLogsTableUpdateCompanionBuilder =
    IntakeLogsCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<String> supplementId,
      Value<int> scheduledTime,
      Value<int> status,
      Value<int?> actualTime,
      Value<String?> reason,
      Value<String?> note,
      Value<int?> snoozeDurationMinutes,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$IntakeLogsTableFilterComposer
    extends Composer<_$AppDatabase, $IntakeLogsTable> {
  $$IntakeLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get supplementId => $composableBuilder(
    column: $table.supplementId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get scheduledTime => $composableBuilder(
    column: $table.scheduledTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get actualTime => $composableBuilder(
    column: $table.actualTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get note => $composableBuilder(
    column: $table.note,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get snoozeDurationMinutes => $composableBuilder(
    column: $table.snoozeDurationMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$IntakeLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $IntakeLogsTable> {
  $$IntakeLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get supplementId => $composableBuilder(
    column: $table.supplementId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get scheduledTime => $composableBuilder(
    column: $table.scheduledTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get actualTime => $composableBuilder(
    column: $table.actualTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get note => $composableBuilder(
    column: $table.note,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get snoozeDurationMinutes => $composableBuilder(
    column: $table.snoozeDurationMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$IntakeLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $IntakeLogsTable> {
  $$IntakeLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<String> get supplementId => $composableBuilder(
    column: $table.supplementId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get scheduledTime => $composableBuilder(
    column: $table.scheduledTime,
    builder: (column) => column,
  );

  GeneratedColumn<int> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<int> get actualTime => $composableBuilder(
    column: $table.actualTime,
    builder: (column) => column,
  );

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<String> get note =>
      $composableBuilder(column: $table.note, builder: (column) => column);

  GeneratedColumn<int> get snoozeDurationMinutes => $composableBuilder(
    column: $table.snoozeDurationMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$IntakeLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $IntakeLogsTable,
          IntakeLogRow,
          $$IntakeLogsTableFilterComposer,
          $$IntakeLogsTableOrderingComposer,
          $$IntakeLogsTableAnnotationComposer,
          $$IntakeLogsTableCreateCompanionBuilder,
          $$IntakeLogsTableUpdateCompanionBuilder,
          (
            IntakeLogRow,
            BaseReferences<_$AppDatabase, $IntakeLogsTable, IntakeLogRow>,
          ),
          IntakeLogRow,
          PrefetchHooks Function()
        > {
  $$IntakeLogsTableTableManager(_$AppDatabase db, $IntakeLogsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$IntakeLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$IntakeLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$IntakeLogsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> supplementId = const Value.absent(),
                Value<int> scheduledTime = const Value.absent(),
                Value<int> status = const Value.absent(),
                Value<int?> actualTime = const Value.absent(),
                Value<String?> reason = const Value.absent(),
                Value<String?> note = const Value.absent(),
                Value<int?> snoozeDurationMinutes = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => IntakeLogsCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                supplementId: supplementId,
                scheduledTime: scheduledTime,
                status: status,
                actualTime: actualTime,
                reason: reason,
                note: note,
                snoozeDurationMinutes: snoozeDurationMinutes,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required String supplementId,
                required int scheduledTime,
                required int status,
                Value<int?> actualTime = const Value.absent(),
                Value<String?> reason = const Value.absent(),
                Value<String?> note = const Value.absent(),
                Value<int?> snoozeDurationMinutes = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => IntakeLogsCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                supplementId: supplementId,
                scheduledTime: scheduledTime,
                status: status,
                actualTime: actualTime,
                reason: reason,
                note: note,
                snoozeDurationMinutes: snoozeDurationMinutes,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$IntakeLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $IntakeLogsTable,
      IntakeLogRow,
      $$IntakeLogsTableFilterComposer,
      $$IntakeLogsTableOrderingComposer,
      $$IntakeLogsTableAnnotationComposer,
      $$IntakeLogsTableCreateCompanionBuilder,
      $$IntakeLogsTableUpdateCompanionBuilder,
      (
        IntakeLogRow,
        BaseReferences<_$AppDatabase, $IntakeLogsTable, IntakeLogRow>,
      ),
      IntakeLogRow,
      PrefetchHooks Function()
    >;
typedef $$ConditionsTableCreateCompanionBuilder =
    ConditionsCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required String name,
      required String category,
      Value<String> bodyLocations,
      Value<String> triggers,
      required int startTimeframe,
      required int status,
      Value<String?> description,
      Value<String?> baselinePhotoPath,
      Value<int?> endDate,
      Value<bool> isArchived,
      Value<String?> activityId,
      Value<String?> cloudStorageUrl,
      Value<String?> fileHash,
      Value<int?> fileSizeBytes,
      Value<bool> isFileUploaded,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$ConditionsTableUpdateCompanionBuilder =
    ConditionsCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<String> name,
      Value<String> category,
      Value<String> bodyLocations,
      Value<String> triggers,
      Value<int> startTimeframe,
      Value<int> status,
      Value<String?> description,
      Value<String?> baselinePhotoPath,
      Value<int?> endDate,
      Value<bool> isArchived,
      Value<String?> activityId,
      Value<String?> cloudStorageUrl,
      Value<String?> fileHash,
      Value<int?> fileSizeBytes,
      Value<bool> isFileUploaded,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$ConditionsTableFilterComposer
    extends Composer<_$AppDatabase, $ConditionsTable> {
  $$ConditionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bodyLocations => $composableBuilder(
    column: $table.bodyLocations,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get triggers => $composableBuilder(
    column: $table.triggers,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get startTimeframe => $composableBuilder(
    column: $table.startTimeframe,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get baselinePhotoPath => $composableBuilder(
    column: $table.baselinePhotoPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endDate => $composableBuilder(
    column: $table.endDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get activityId => $composableBuilder(
    column: $table.activityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get cloudStorageUrl => $composableBuilder(
    column: $table.cloudStorageUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fileHash => $composableBuilder(
    column: $table.fileHash,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get fileSizeBytes => $composableBuilder(
    column: $table.fileSizeBytes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFileUploaded => $composableBuilder(
    column: $table.isFileUploaded,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ConditionsTableOrderingComposer
    extends Composer<_$AppDatabase, $ConditionsTable> {
  $$ConditionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bodyLocations => $composableBuilder(
    column: $table.bodyLocations,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get triggers => $composableBuilder(
    column: $table.triggers,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get startTimeframe => $composableBuilder(
    column: $table.startTimeframe,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get baselinePhotoPath => $composableBuilder(
    column: $table.baselinePhotoPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endDate => $composableBuilder(
    column: $table.endDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get activityId => $composableBuilder(
    column: $table.activityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get cloudStorageUrl => $composableBuilder(
    column: $table.cloudStorageUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fileHash => $composableBuilder(
    column: $table.fileHash,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get fileSizeBytes => $composableBuilder(
    column: $table.fileSizeBytes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFileUploaded => $composableBuilder(
    column: $table.isFileUploaded,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ConditionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ConditionsTable> {
  $$ConditionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get category =>
      $composableBuilder(column: $table.category, builder: (column) => column);

  GeneratedColumn<String> get bodyLocations => $composableBuilder(
    column: $table.bodyLocations,
    builder: (column) => column,
  );

  GeneratedColumn<String> get triggers =>
      $composableBuilder(column: $table.triggers, builder: (column) => column);

  GeneratedColumn<int> get startTimeframe => $composableBuilder(
    column: $table.startTimeframe,
    builder: (column) => column,
  );

  GeneratedColumn<int> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<String> get baselinePhotoPath => $composableBuilder(
    column: $table.baselinePhotoPath,
    builder: (column) => column,
  );

  GeneratedColumn<int> get endDate =>
      $composableBuilder(column: $table.endDate, builder: (column) => column);

  GeneratedColumn<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => column,
  );

  GeneratedColumn<String> get activityId => $composableBuilder(
    column: $table.activityId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get cloudStorageUrl => $composableBuilder(
    column: $table.cloudStorageUrl,
    builder: (column) => column,
  );

  GeneratedColumn<String> get fileHash =>
      $composableBuilder(column: $table.fileHash, builder: (column) => column);

  GeneratedColumn<int> get fileSizeBytes => $composableBuilder(
    column: $table.fileSizeBytes,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isFileUploaded => $composableBuilder(
    column: $table.isFileUploaded,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$ConditionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ConditionsTable,
          ConditionRow,
          $$ConditionsTableFilterComposer,
          $$ConditionsTableOrderingComposer,
          $$ConditionsTableAnnotationComposer,
          $$ConditionsTableCreateCompanionBuilder,
          $$ConditionsTableUpdateCompanionBuilder,
          (
            ConditionRow,
            BaseReferences<_$AppDatabase, $ConditionsTable, ConditionRow>,
          ),
          ConditionRow,
          PrefetchHooks Function()
        > {
  $$ConditionsTableTableManager(_$AppDatabase db, $ConditionsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ConditionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ConditionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ConditionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> category = const Value.absent(),
                Value<String> bodyLocations = const Value.absent(),
                Value<String> triggers = const Value.absent(),
                Value<int> startTimeframe = const Value.absent(),
                Value<int> status = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<String?> baselinePhotoPath = const Value.absent(),
                Value<int?> endDate = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                Value<String?> activityId = const Value.absent(),
                Value<String?> cloudStorageUrl = const Value.absent(),
                Value<String?> fileHash = const Value.absent(),
                Value<int?> fileSizeBytes = const Value.absent(),
                Value<bool> isFileUploaded = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ConditionsCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                name: name,
                category: category,
                bodyLocations: bodyLocations,
                triggers: triggers,
                startTimeframe: startTimeframe,
                status: status,
                description: description,
                baselinePhotoPath: baselinePhotoPath,
                endDate: endDate,
                isArchived: isArchived,
                activityId: activityId,
                cloudStorageUrl: cloudStorageUrl,
                fileHash: fileHash,
                fileSizeBytes: fileSizeBytes,
                isFileUploaded: isFileUploaded,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required String name,
                required String category,
                Value<String> bodyLocations = const Value.absent(),
                Value<String> triggers = const Value.absent(),
                required int startTimeframe,
                required int status,
                Value<String?> description = const Value.absent(),
                Value<String?> baselinePhotoPath = const Value.absent(),
                Value<int?> endDate = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                Value<String?> activityId = const Value.absent(),
                Value<String?> cloudStorageUrl = const Value.absent(),
                Value<String?> fileHash = const Value.absent(),
                Value<int?> fileSizeBytes = const Value.absent(),
                Value<bool> isFileUploaded = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ConditionsCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                name: name,
                category: category,
                bodyLocations: bodyLocations,
                triggers: triggers,
                startTimeframe: startTimeframe,
                status: status,
                description: description,
                baselinePhotoPath: baselinePhotoPath,
                endDate: endDate,
                isArchived: isArchived,
                activityId: activityId,
                cloudStorageUrl: cloudStorageUrl,
                fileHash: fileHash,
                fileSizeBytes: fileSizeBytes,
                isFileUploaded: isFileUploaded,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ConditionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ConditionsTable,
      ConditionRow,
      $$ConditionsTableFilterComposer,
      $$ConditionsTableOrderingComposer,
      $$ConditionsTableAnnotationComposer,
      $$ConditionsTableCreateCompanionBuilder,
      $$ConditionsTableUpdateCompanionBuilder,
      (
        ConditionRow,
        BaseReferences<_$AppDatabase, $ConditionsTable, ConditionRow>,
      ),
      ConditionRow,
      PrefetchHooks Function()
    >;
typedef $$ConditionLogsTableCreateCompanionBuilder =
    ConditionLogsCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required String conditionId,
      required int timestamp,
      required int severity,
      required bool isFlare,
      Value<String> flarePhotoIds,
      Value<String?> notes,
      Value<String?> photoPath,
      Value<String?> activityId,
      Value<String?> triggers,
      Value<String?> cloudStorageUrl,
      Value<String?> fileHash,
      Value<int?> fileSizeBytes,
      Value<bool> isFileUploaded,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$ConditionLogsTableUpdateCompanionBuilder =
    ConditionLogsCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<String> conditionId,
      Value<int> timestamp,
      Value<int> severity,
      Value<bool> isFlare,
      Value<String> flarePhotoIds,
      Value<String?> notes,
      Value<String?> photoPath,
      Value<String?> activityId,
      Value<String?> triggers,
      Value<String?> cloudStorageUrl,
      Value<String?> fileHash,
      Value<int?> fileSizeBytes,
      Value<bool> isFileUploaded,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$ConditionLogsTableFilterComposer
    extends Composer<_$AppDatabase, $ConditionLogsTable> {
  $$ConditionLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conditionId => $composableBuilder(
    column: $table.conditionId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get severity => $composableBuilder(
    column: $table.severity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFlare => $composableBuilder(
    column: $table.isFlare,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get flarePhotoIds => $composableBuilder(
    column: $table.flarePhotoIds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get photoPath => $composableBuilder(
    column: $table.photoPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get activityId => $composableBuilder(
    column: $table.activityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get triggers => $composableBuilder(
    column: $table.triggers,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get cloudStorageUrl => $composableBuilder(
    column: $table.cloudStorageUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fileHash => $composableBuilder(
    column: $table.fileHash,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get fileSizeBytes => $composableBuilder(
    column: $table.fileSizeBytes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFileUploaded => $composableBuilder(
    column: $table.isFileUploaded,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ConditionLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $ConditionLogsTable> {
  $$ConditionLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conditionId => $composableBuilder(
    column: $table.conditionId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get severity => $composableBuilder(
    column: $table.severity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFlare => $composableBuilder(
    column: $table.isFlare,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get flarePhotoIds => $composableBuilder(
    column: $table.flarePhotoIds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get photoPath => $composableBuilder(
    column: $table.photoPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get activityId => $composableBuilder(
    column: $table.activityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get triggers => $composableBuilder(
    column: $table.triggers,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get cloudStorageUrl => $composableBuilder(
    column: $table.cloudStorageUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fileHash => $composableBuilder(
    column: $table.fileHash,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get fileSizeBytes => $composableBuilder(
    column: $table.fileSizeBytes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFileUploaded => $composableBuilder(
    column: $table.isFileUploaded,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ConditionLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ConditionLogsTable> {
  $$ConditionLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<String> get conditionId => $composableBuilder(
    column: $table.conditionId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<int> get severity =>
      $composableBuilder(column: $table.severity, builder: (column) => column);

  GeneratedColumn<bool> get isFlare =>
      $composableBuilder(column: $table.isFlare, builder: (column) => column);

  GeneratedColumn<String> get flarePhotoIds => $composableBuilder(
    column: $table.flarePhotoIds,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get photoPath =>
      $composableBuilder(column: $table.photoPath, builder: (column) => column);

  GeneratedColumn<String> get activityId => $composableBuilder(
    column: $table.activityId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get triggers =>
      $composableBuilder(column: $table.triggers, builder: (column) => column);

  GeneratedColumn<String> get cloudStorageUrl => $composableBuilder(
    column: $table.cloudStorageUrl,
    builder: (column) => column,
  );

  GeneratedColumn<String> get fileHash =>
      $composableBuilder(column: $table.fileHash, builder: (column) => column);

  GeneratedColumn<int> get fileSizeBytes => $composableBuilder(
    column: $table.fileSizeBytes,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isFileUploaded => $composableBuilder(
    column: $table.isFileUploaded,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$ConditionLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ConditionLogsTable,
          ConditionLogRow,
          $$ConditionLogsTableFilterComposer,
          $$ConditionLogsTableOrderingComposer,
          $$ConditionLogsTableAnnotationComposer,
          $$ConditionLogsTableCreateCompanionBuilder,
          $$ConditionLogsTableUpdateCompanionBuilder,
          (
            ConditionLogRow,
            BaseReferences<_$AppDatabase, $ConditionLogsTable, ConditionLogRow>,
          ),
          ConditionLogRow,
          PrefetchHooks Function()
        > {
  $$ConditionLogsTableTableManager(_$AppDatabase db, $ConditionLogsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ConditionLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ConditionLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ConditionLogsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> conditionId = const Value.absent(),
                Value<int> timestamp = const Value.absent(),
                Value<int> severity = const Value.absent(),
                Value<bool> isFlare = const Value.absent(),
                Value<String> flarePhotoIds = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> photoPath = const Value.absent(),
                Value<String?> activityId = const Value.absent(),
                Value<String?> triggers = const Value.absent(),
                Value<String?> cloudStorageUrl = const Value.absent(),
                Value<String?> fileHash = const Value.absent(),
                Value<int?> fileSizeBytes = const Value.absent(),
                Value<bool> isFileUploaded = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ConditionLogsCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                conditionId: conditionId,
                timestamp: timestamp,
                severity: severity,
                isFlare: isFlare,
                flarePhotoIds: flarePhotoIds,
                notes: notes,
                photoPath: photoPath,
                activityId: activityId,
                triggers: triggers,
                cloudStorageUrl: cloudStorageUrl,
                fileHash: fileHash,
                fileSizeBytes: fileSizeBytes,
                isFileUploaded: isFileUploaded,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required String conditionId,
                required int timestamp,
                required int severity,
                required bool isFlare,
                Value<String> flarePhotoIds = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> photoPath = const Value.absent(),
                Value<String?> activityId = const Value.absent(),
                Value<String?> triggers = const Value.absent(),
                Value<String?> cloudStorageUrl = const Value.absent(),
                Value<String?> fileHash = const Value.absent(),
                Value<int?> fileSizeBytes = const Value.absent(),
                Value<bool> isFileUploaded = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ConditionLogsCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                conditionId: conditionId,
                timestamp: timestamp,
                severity: severity,
                isFlare: isFlare,
                flarePhotoIds: flarePhotoIds,
                notes: notes,
                photoPath: photoPath,
                activityId: activityId,
                triggers: triggers,
                cloudStorageUrl: cloudStorageUrl,
                fileHash: fileHash,
                fileSizeBytes: fileSizeBytes,
                isFileUploaded: isFileUploaded,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ConditionLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ConditionLogsTable,
      ConditionLogRow,
      $$ConditionLogsTableFilterComposer,
      $$ConditionLogsTableOrderingComposer,
      $$ConditionLogsTableAnnotationComposer,
      $$ConditionLogsTableCreateCompanionBuilder,
      $$ConditionLogsTableUpdateCompanionBuilder,
      (
        ConditionLogRow,
        BaseReferences<_$AppDatabase, $ConditionLogsTable, ConditionLogRow>,
      ),
      ConditionLogRow,
      PrefetchHooks Function()
    >;
typedef $$FlareUpsTableCreateCompanionBuilder =
    FlareUpsCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required String conditionId,
      required int startDate,
      Value<int?> endDate,
      required int severity,
      Value<String?> notes,
      required String triggers,
      Value<String?> activityId,
      Value<String?> photoPath,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$FlareUpsTableUpdateCompanionBuilder =
    FlareUpsCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<String> conditionId,
      Value<int> startDate,
      Value<int?> endDate,
      Value<int> severity,
      Value<String?> notes,
      Value<String> triggers,
      Value<String?> activityId,
      Value<String?> photoPath,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$FlareUpsTableFilterComposer
    extends Composer<_$AppDatabase, $FlareUpsTable> {
  $$FlareUpsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conditionId => $composableBuilder(
    column: $table.conditionId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get startDate => $composableBuilder(
    column: $table.startDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endDate => $composableBuilder(
    column: $table.endDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get severity => $composableBuilder(
    column: $table.severity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get triggers => $composableBuilder(
    column: $table.triggers,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get activityId => $composableBuilder(
    column: $table.activityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get photoPath => $composableBuilder(
    column: $table.photoPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FlareUpsTableOrderingComposer
    extends Composer<_$AppDatabase, $FlareUpsTable> {
  $$FlareUpsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conditionId => $composableBuilder(
    column: $table.conditionId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get startDate => $composableBuilder(
    column: $table.startDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endDate => $composableBuilder(
    column: $table.endDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get severity => $composableBuilder(
    column: $table.severity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get triggers => $composableBuilder(
    column: $table.triggers,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get activityId => $composableBuilder(
    column: $table.activityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get photoPath => $composableBuilder(
    column: $table.photoPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FlareUpsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FlareUpsTable> {
  $$FlareUpsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<String> get conditionId => $composableBuilder(
    column: $table.conditionId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get startDate =>
      $composableBuilder(column: $table.startDate, builder: (column) => column);

  GeneratedColumn<int> get endDate =>
      $composableBuilder(column: $table.endDate, builder: (column) => column);

  GeneratedColumn<int> get severity =>
      $composableBuilder(column: $table.severity, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get triggers =>
      $composableBuilder(column: $table.triggers, builder: (column) => column);

  GeneratedColumn<String> get activityId => $composableBuilder(
    column: $table.activityId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get photoPath =>
      $composableBuilder(column: $table.photoPath, builder: (column) => column);

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$FlareUpsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FlareUpsTable,
          FlareUpRow,
          $$FlareUpsTableFilterComposer,
          $$FlareUpsTableOrderingComposer,
          $$FlareUpsTableAnnotationComposer,
          $$FlareUpsTableCreateCompanionBuilder,
          $$FlareUpsTableUpdateCompanionBuilder,
          (
            FlareUpRow,
            BaseReferences<_$AppDatabase, $FlareUpsTable, FlareUpRow>,
          ),
          FlareUpRow,
          PrefetchHooks Function()
        > {
  $$FlareUpsTableTableManager(_$AppDatabase db, $FlareUpsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FlareUpsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FlareUpsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FlareUpsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> conditionId = const Value.absent(),
                Value<int> startDate = const Value.absent(),
                Value<int?> endDate = const Value.absent(),
                Value<int> severity = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String> triggers = const Value.absent(),
                Value<String?> activityId = const Value.absent(),
                Value<String?> photoPath = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FlareUpsCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                conditionId: conditionId,
                startDate: startDate,
                endDate: endDate,
                severity: severity,
                notes: notes,
                triggers: triggers,
                activityId: activityId,
                photoPath: photoPath,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required String conditionId,
                required int startDate,
                Value<int?> endDate = const Value.absent(),
                required int severity,
                Value<String?> notes = const Value.absent(),
                required String triggers,
                Value<String?> activityId = const Value.absent(),
                Value<String?> photoPath = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FlareUpsCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                conditionId: conditionId,
                startDate: startDate,
                endDate: endDate,
                severity: severity,
                notes: notes,
                triggers: triggers,
                activityId: activityId,
                photoPath: photoPath,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FlareUpsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FlareUpsTable,
      FlareUpRow,
      $$FlareUpsTableFilterComposer,
      $$FlareUpsTableOrderingComposer,
      $$FlareUpsTableAnnotationComposer,
      $$FlareUpsTableCreateCompanionBuilder,
      $$FlareUpsTableUpdateCompanionBuilder,
      (FlareUpRow, BaseReferences<_$AppDatabase, $FlareUpsTable, FlareUpRow>),
      FlareUpRow,
      PrefetchHooks Function()
    >;
typedef $$FluidsEntriesTableCreateCompanionBuilder =
    FluidsEntriesCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required int entryDate,
      Value<int?> waterIntakeMl,
      Value<String?> waterIntakeNotes,
      Value<bool> hasBowelMovement,
      Value<int?> bowelCondition,
      Value<String?> bowelCustomCondition,
      Value<int?> bowelSize,
      Value<String?> bowelPhotoPath,
      Value<bool> hasUrineMovement,
      Value<int?> urineCondition,
      Value<String?> urineCustomCondition,
      Value<int?> urineSize,
      Value<String?> urinePhotoPath,
      Value<int?> menstruationFlow,
      Value<double?> basalBodyTemperature,
      Value<int?> bbtRecordedTime,
      Value<String?> otherFluidName,
      Value<String?> otherFluidAmount,
      Value<String?> otherFluidNotes,
      Value<String?> importSource,
      Value<String?> importExternalId,
      Value<String?> cloudStorageUrl,
      Value<String?> fileHash,
      Value<int?> fileSizeBytes,
      Value<bool> isFileUploaded,
      Value<String> notes,
      Value<String> photoIds,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$FluidsEntriesTableUpdateCompanionBuilder =
    FluidsEntriesCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<int> entryDate,
      Value<int?> waterIntakeMl,
      Value<String?> waterIntakeNotes,
      Value<bool> hasBowelMovement,
      Value<int?> bowelCondition,
      Value<String?> bowelCustomCondition,
      Value<int?> bowelSize,
      Value<String?> bowelPhotoPath,
      Value<bool> hasUrineMovement,
      Value<int?> urineCondition,
      Value<String?> urineCustomCondition,
      Value<int?> urineSize,
      Value<String?> urinePhotoPath,
      Value<int?> menstruationFlow,
      Value<double?> basalBodyTemperature,
      Value<int?> bbtRecordedTime,
      Value<String?> otherFluidName,
      Value<String?> otherFluidAmount,
      Value<String?> otherFluidNotes,
      Value<String?> importSource,
      Value<String?> importExternalId,
      Value<String?> cloudStorageUrl,
      Value<String?> fileHash,
      Value<int?> fileSizeBytes,
      Value<bool> isFileUploaded,
      Value<String> notes,
      Value<String> photoIds,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$FluidsEntriesTableFilterComposer
    extends Composer<_$AppDatabase, $FluidsEntriesTable> {
  $$FluidsEntriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get entryDate => $composableBuilder(
    column: $table.entryDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get waterIntakeMl => $composableBuilder(
    column: $table.waterIntakeMl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get waterIntakeNotes => $composableBuilder(
    column: $table.waterIntakeNotes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get hasBowelMovement => $composableBuilder(
    column: $table.hasBowelMovement,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get bowelCondition => $composableBuilder(
    column: $table.bowelCondition,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowelCustomCondition => $composableBuilder(
    column: $table.bowelCustomCondition,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get bowelSize => $composableBuilder(
    column: $table.bowelSize,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowelPhotoPath => $composableBuilder(
    column: $table.bowelPhotoPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get hasUrineMovement => $composableBuilder(
    column: $table.hasUrineMovement,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get urineCondition => $composableBuilder(
    column: $table.urineCondition,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get urineCustomCondition => $composableBuilder(
    column: $table.urineCustomCondition,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get urineSize => $composableBuilder(
    column: $table.urineSize,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get urinePhotoPath => $composableBuilder(
    column: $table.urinePhotoPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get menstruationFlow => $composableBuilder(
    column: $table.menstruationFlow,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get basalBodyTemperature => $composableBuilder(
    column: $table.basalBodyTemperature,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get bbtRecordedTime => $composableBuilder(
    column: $table.bbtRecordedTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get otherFluidName => $composableBuilder(
    column: $table.otherFluidName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get otherFluidAmount => $composableBuilder(
    column: $table.otherFluidAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get otherFluidNotes => $composableBuilder(
    column: $table.otherFluidNotes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get importExternalId => $composableBuilder(
    column: $table.importExternalId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get cloudStorageUrl => $composableBuilder(
    column: $table.cloudStorageUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fileHash => $composableBuilder(
    column: $table.fileHash,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get fileSizeBytes => $composableBuilder(
    column: $table.fileSizeBytes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFileUploaded => $composableBuilder(
    column: $table.isFileUploaded,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get photoIds => $composableBuilder(
    column: $table.photoIds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FluidsEntriesTableOrderingComposer
    extends Composer<_$AppDatabase, $FluidsEntriesTable> {
  $$FluidsEntriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get entryDate => $composableBuilder(
    column: $table.entryDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get waterIntakeMl => $composableBuilder(
    column: $table.waterIntakeMl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get waterIntakeNotes => $composableBuilder(
    column: $table.waterIntakeNotes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get hasBowelMovement => $composableBuilder(
    column: $table.hasBowelMovement,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get bowelCondition => $composableBuilder(
    column: $table.bowelCondition,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowelCustomCondition => $composableBuilder(
    column: $table.bowelCustomCondition,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get bowelSize => $composableBuilder(
    column: $table.bowelSize,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowelPhotoPath => $composableBuilder(
    column: $table.bowelPhotoPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get hasUrineMovement => $composableBuilder(
    column: $table.hasUrineMovement,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get urineCondition => $composableBuilder(
    column: $table.urineCondition,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get urineCustomCondition => $composableBuilder(
    column: $table.urineCustomCondition,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get urineSize => $composableBuilder(
    column: $table.urineSize,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get urinePhotoPath => $composableBuilder(
    column: $table.urinePhotoPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get menstruationFlow => $composableBuilder(
    column: $table.menstruationFlow,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get basalBodyTemperature => $composableBuilder(
    column: $table.basalBodyTemperature,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get bbtRecordedTime => $composableBuilder(
    column: $table.bbtRecordedTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get otherFluidName => $composableBuilder(
    column: $table.otherFluidName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get otherFluidAmount => $composableBuilder(
    column: $table.otherFluidAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get otherFluidNotes => $composableBuilder(
    column: $table.otherFluidNotes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get importExternalId => $composableBuilder(
    column: $table.importExternalId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get cloudStorageUrl => $composableBuilder(
    column: $table.cloudStorageUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fileHash => $composableBuilder(
    column: $table.fileHash,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get fileSizeBytes => $composableBuilder(
    column: $table.fileSizeBytes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFileUploaded => $composableBuilder(
    column: $table.isFileUploaded,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get photoIds => $composableBuilder(
    column: $table.photoIds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FluidsEntriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $FluidsEntriesTable> {
  $$FluidsEntriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<int> get entryDate =>
      $composableBuilder(column: $table.entryDate, builder: (column) => column);

  GeneratedColumn<int> get waterIntakeMl => $composableBuilder(
    column: $table.waterIntakeMl,
    builder: (column) => column,
  );

  GeneratedColumn<String> get waterIntakeNotes => $composableBuilder(
    column: $table.waterIntakeNotes,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get hasBowelMovement => $composableBuilder(
    column: $table.hasBowelMovement,
    builder: (column) => column,
  );

  GeneratedColumn<int> get bowelCondition => $composableBuilder(
    column: $table.bowelCondition,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bowelCustomCondition => $composableBuilder(
    column: $table.bowelCustomCondition,
    builder: (column) => column,
  );

  GeneratedColumn<int> get bowelSize =>
      $composableBuilder(column: $table.bowelSize, builder: (column) => column);

  GeneratedColumn<String> get bowelPhotoPath => $composableBuilder(
    column: $table.bowelPhotoPath,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get hasUrineMovement => $composableBuilder(
    column: $table.hasUrineMovement,
    builder: (column) => column,
  );

  GeneratedColumn<int> get urineCondition => $composableBuilder(
    column: $table.urineCondition,
    builder: (column) => column,
  );

  GeneratedColumn<String> get urineCustomCondition => $composableBuilder(
    column: $table.urineCustomCondition,
    builder: (column) => column,
  );

  GeneratedColumn<int> get urineSize =>
      $composableBuilder(column: $table.urineSize, builder: (column) => column);

  GeneratedColumn<String> get urinePhotoPath => $composableBuilder(
    column: $table.urinePhotoPath,
    builder: (column) => column,
  );

  GeneratedColumn<int> get menstruationFlow => $composableBuilder(
    column: $table.menstruationFlow,
    builder: (column) => column,
  );

  GeneratedColumn<double> get basalBodyTemperature => $composableBuilder(
    column: $table.basalBodyTemperature,
    builder: (column) => column,
  );

  GeneratedColumn<int> get bbtRecordedTime => $composableBuilder(
    column: $table.bbtRecordedTime,
    builder: (column) => column,
  );

  GeneratedColumn<String> get otherFluidName => $composableBuilder(
    column: $table.otherFluidName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get otherFluidAmount => $composableBuilder(
    column: $table.otherFluidAmount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get otherFluidNotes => $composableBuilder(
    column: $table.otherFluidNotes,
    builder: (column) => column,
  );

  GeneratedColumn<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => column,
  );

  GeneratedColumn<String> get importExternalId => $composableBuilder(
    column: $table.importExternalId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get cloudStorageUrl => $composableBuilder(
    column: $table.cloudStorageUrl,
    builder: (column) => column,
  );

  GeneratedColumn<String> get fileHash =>
      $composableBuilder(column: $table.fileHash, builder: (column) => column);

  GeneratedColumn<int> get fileSizeBytes => $composableBuilder(
    column: $table.fileSizeBytes,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isFileUploaded => $composableBuilder(
    column: $table.isFileUploaded,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get photoIds =>
      $composableBuilder(column: $table.photoIds, builder: (column) => column);

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$FluidsEntriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FluidsEntriesTable,
          FluidsEntryRow,
          $$FluidsEntriesTableFilterComposer,
          $$FluidsEntriesTableOrderingComposer,
          $$FluidsEntriesTableAnnotationComposer,
          $$FluidsEntriesTableCreateCompanionBuilder,
          $$FluidsEntriesTableUpdateCompanionBuilder,
          (
            FluidsEntryRow,
            BaseReferences<_$AppDatabase, $FluidsEntriesTable, FluidsEntryRow>,
          ),
          FluidsEntryRow,
          PrefetchHooks Function()
        > {
  $$FluidsEntriesTableTableManager(_$AppDatabase db, $FluidsEntriesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FluidsEntriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FluidsEntriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FluidsEntriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<int> entryDate = const Value.absent(),
                Value<int?> waterIntakeMl = const Value.absent(),
                Value<String?> waterIntakeNotes = const Value.absent(),
                Value<bool> hasBowelMovement = const Value.absent(),
                Value<int?> bowelCondition = const Value.absent(),
                Value<String?> bowelCustomCondition = const Value.absent(),
                Value<int?> bowelSize = const Value.absent(),
                Value<String?> bowelPhotoPath = const Value.absent(),
                Value<bool> hasUrineMovement = const Value.absent(),
                Value<int?> urineCondition = const Value.absent(),
                Value<String?> urineCustomCondition = const Value.absent(),
                Value<int?> urineSize = const Value.absent(),
                Value<String?> urinePhotoPath = const Value.absent(),
                Value<int?> menstruationFlow = const Value.absent(),
                Value<double?> basalBodyTemperature = const Value.absent(),
                Value<int?> bbtRecordedTime = const Value.absent(),
                Value<String?> otherFluidName = const Value.absent(),
                Value<String?> otherFluidAmount = const Value.absent(),
                Value<String?> otherFluidNotes = const Value.absent(),
                Value<String?> importSource = const Value.absent(),
                Value<String?> importExternalId = const Value.absent(),
                Value<String?> cloudStorageUrl = const Value.absent(),
                Value<String?> fileHash = const Value.absent(),
                Value<int?> fileSizeBytes = const Value.absent(),
                Value<bool> isFileUploaded = const Value.absent(),
                Value<String> notes = const Value.absent(),
                Value<String> photoIds = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FluidsEntriesCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                entryDate: entryDate,
                waterIntakeMl: waterIntakeMl,
                waterIntakeNotes: waterIntakeNotes,
                hasBowelMovement: hasBowelMovement,
                bowelCondition: bowelCondition,
                bowelCustomCondition: bowelCustomCondition,
                bowelSize: bowelSize,
                bowelPhotoPath: bowelPhotoPath,
                hasUrineMovement: hasUrineMovement,
                urineCondition: urineCondition,
                urineCustomCondition: urineCustomCondition,
                urineSize: urineSize,
                urinePhotoPath: urinePhotoPath,
                menstruationFlow: menstruationFlow,
                basalBodyTemperature: basalBodyTemperature,
                bbtRecordedTime: bbtRecordedTime,
                otherFluidName: otherFluidName,
                otherFluidAmount: otherFluidAmount,
                otherFluidNotes: otherFluidNotes,
                importSource: importSource,
                importExternalId: importExternalId,
                cloudStorageUrl: cloudStorageUrl,
                fileHash: fileHash,
                fileSizeBytes: fileSizeBytes,
                isFileUploaded: isFileUploaded,
                notes: notes,
                photoIds: photoIds,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required int entryDate,
                Value<int?> waterIntakeMl = const Value.absent(),
                Value<String?> waterIntakeNotes = const Value.absent(),
                Value<bool> hasBowelMovement = const Value.absent(),
                Value<int?> bowelCondition = const Value.absent(),
                Value<String?> bowelCustomCondition = const Value.absent(),
                Value<int?> bowelSize = const Value.absent(),
                Value<String?> bowelPhotoPath = const Value.absent(),
                Value<bool> hasUrineMovement = const Value.absent(),
                Value<int?> urineCondition = const Value.absent(),
                Value<String?> urineCustomCondition = const Value.absent(),
                Value<int?> urineSize = const Value.absent(),
                Value<String?> urinePhotoPath = const Value.absent(),
                Value<int?> menstruationFlow = const Value.absent(),
                Value<double?> basalBodyTemperature = const Value.absent(),
                Value<int?> bbtRecordedTime = const Value.absent(),
                Value<String?> otherFluidName = const Value.absent(),
                Value<String?> otherFluidAmount = const Value.absent(),
                Value<String?> otherFluidNotes = const Value.absent(),
                Value<String?> importSource = const Value.absent(),
                Value<String?> importExternalId = const Value.absent(),
                Value<String?> cloudStorageUrl = const Value.absent(),
                Value<String?> fileHash = const Value.absent(),
                Value<int?> fileSizeBytes = const Value.absent(),
                Value<bool> isFileUploaded = const Value.absent(),
                Value<String> notes = const Value.absent(),
                Value<String> photoIds = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FluidsEntriesCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                entryDate: entryDate,
                waterIntakeMl: waterIntakeMl,
                waterIntakeNotes: waterIntakeNotes,
                hasBowelMovement: hasBowelMovement,
                bowelCondition: bowelCondition,
                bowelCustomCondition: bowelCustomCondition,
                bowelSize: bowelSize,
                bowelPhotoPath: bowelPhotoPath,
                hasUrineMovement: hasUrineMovement,
                urineCondition: urineCondition,
                urineCustomCondition: urineCustomCondition,
                urineSize: urineSize,
                urinePhotoPath: urinePhotoPath,
                menstruationFlow: menstruationFlow,
                basalBodyTemperature: basalBodyTemperature,
                bbtRecordedTime: bbtRecordedTime,
                otherFluidName: otherFluidName,
                otherFluidAmount: otherFluidAmount,
                otherFluidNotes: otherFluidNotes,
                importSource: importSource,
                importExternalId: importExternalId,
                cloudStorageUrl: cloudStorageUrl,
                fileHash: fileHash,
                fileSizeBytes: fileSizeBytes,
                isFileUploaded: isFileUploaded,
                notes: notes,
                photoIds: photoIds,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FluidsEntriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FluidsEntriesTable,
      FluidsEntryRow,
      $$FluidsEntriesTableFilterComposer,
      $$FluidsEntriesTableOrderingComposer,
      $$FluidsEntriesTableAnnotationComposer,
      $$FluidsEntriesTableCreateCompanionBuilder,
      $$FluidsEntriesTableUpdateCompanionBuilder,
      (
        FluidsEntryRow,
        BaseReferences<_$AppDatabase, $FluidsEntriesTable, FluidsEntryRow>,
      ),
      FluidsEntryRow,
      PrefetchHooks Function()
    >;
typedef $$SleepEntriesTableCreateCompanionBuilder =
    SleepEntriesCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required int bedTime,
      Value<int?> wakeTime,
      Value<int> deepSleepMinutes,
      Value<int> lightSleepMinutes,
      Value<int> restlessSleepMinutes,
      Value<int> dreamType,
      Value<int> wakingFeeling,
      Value<String?> notes,
      Value<String?> importSource,
      Value<String?> importExternalId,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$SleepEntriesTableUpdateCompanionBuilder =
    SleepEntriesCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<int> bedTime,
      Value<int?> wakeTime,
      Value<int> deepSleepMinutes,
      Value<int> lightSleepMinutes,
      Value<int> restlessSleepMinutes,
      Value<int> dreamType,
      Value<int> wakingFeeling,
      Value<String?> notes,
      Value<String?> importSource,
      Value<String?> importExternalId,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$SleepEntriesTableFilterComposer
    extends Composer<_$AppDatabase, $SleepEntriesTable> {
  $$SleepEntriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get bedTime => $composableBuilder(
    column: $table.bedTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get wakeTime => $composableBuilder(
    column: $table.wakeTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get deepSleepMinutes => $composableBuilder(
    column: $table.deepSleepMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lightSleepMinutes => $composableBuilder(
    column: $table.lightSleepMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get restlessSleepMinutes => $composableBuilder(
    column: $table.restlessSleepMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dreamType => $composableBuilder(
    column: $table.dreamType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get wakingFeeling => $composableBuilder(
    column: $table.wakingFeeling,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get importExternalId => $composableBuilder(
    column: $table.importExternalId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SleepEntriesTableOrderingComposer
    extends Composer<_$AppDatabase, $SleepEntriesTable> {
  $$SleepEntriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get bedTime => $composableBuilder(
    column: $table.bedTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get wakeTime => $composableBuilder(
    column: $table.wakeTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get deepSleepMinutes => $composableBuilder(
    column: $table.deepSleepMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lightSleepMinutes => $composableBuilder(
    column: $table.lightSleepMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get restlessSleepMinutes => $composableBuilder(
    column: $table.restlessSleepMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dreamType => $composableBuilder(
    column: $table.dreamType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get wakingFeeling => $composableBuilder(
    column: $table.wakingFeeling,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get importExternalId => $composableBuilder(
    column: $table.importExternalId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SleepEntriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $SleepEntriesTable> {
  $$SleepEntriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<int> get bedTime =>
      $composableBuilder(column: $table.bedTime, builder: (column) => column);

  GeneratedColumn<int> get wakeTime =>
      $composableBuilder(column: $table.wakeTime, builder: (column) => column);

  GeneratedColumn<int> get deepSleepMinutes => $composableBuilder(
    column: $table.deepSleepMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<int> get lightSleepMinutes => $composableBuilder(
    column: $table.lightSleepMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<int> get restlessSleepMinutes => $composableBuilder(
    column: $table.restlessSleepMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<int> get dreamType =>
      $composableBuilder(column: $table.dreamType, builder: (column) => column);

  GeneratedColumn<int> get wakingFeeling => $composableBuilder(
    column: $table.wakingFeeling,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => column,
  );

  GeneratedColumn<String> get importExternalId => $composableBuilder(
    column: $table.importExternalId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$SleepEntriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SleepEntriesTable,
          SleepEntryRow,
          $$SleepEntriesTableFilterComposer,
          $$SleepEntriesTableOrderingComposer,
          $$SleepEntriesTableAnnotationComposer,
          $$SleepEntriesTableCreateCompanionBuilder,
          $$SleepEntriesTableUpdateCompanionBuilder,
          (
            SleepEntryRow,
            BaseReferences<_$AppDatabase, $SleepEntriesTable, SleepEntryRow>,
          ),
          SleepEntryRow,
          PrefetchHooks Function()
        > {
  $$SleepEntriesTableTableManager(_$AppDatabase db, $SleepEntriesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SleepEntriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SleepEntriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SleepEntriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<int> bedTime = const Value.absent(),
                Value<int?> wakeTime = const Value.absent(),
                Value<int> deepSleepMinutes = const Value.absent(),
                Value<int> lightSleepMinutes = const Value.absent(),
                Value<int> restlessSleepMinutes = const Value.absent(),
                Value<int> dreamType = const Value.absent(),
                Value<int> wakingFeeling = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> importSource = const Value.absent(),
                Value<String?> importExternalId = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SleepEntriesCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                bedTime: bedTime,
                wakeTime: wakeTime,
                deepSleepMinutes: deepSleepMinutes,
                lightSleepMinutes: lightSleepMinutes,
                restlessSleepMinutes: restlessSleepMinutes,
                dreamType: dreamType,
                wakingFeeling: wakingFeeling,
                notes: notes,
                importSource: importSource,
                importExternalId: importExternalId,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required int bedTime,
                Value<int?> wakeTime = const Value.absent(),
                Value<int> deepSleepMinutes = const Value.absent(),
                Value<int> lightSleepMinutes = const Value.absent(),
                Value<int> restlessSleepMinutes = const Value.absent(),
                Value<int> dreamType = const Value.absent(),
                Value<int> wakingFeeling = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> importSource = const Value.absent(),
                Value<String?> importExternalId = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SleepEntriesCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                bedTime: bedTime,
                wakeTime: wakeTime,
                deepSleepMinutes: deepSleepMinutes,
                lightSleepMinutes: lightSleepMinutes,
                restlessSleepMinutes: restlessSleepMinutes,
                dreamType: dreamType,
                wakingFeeling: wakingFeeling,
                notes: notes,
                importSource: importSource,
                importExternalId: importExternalId,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SleepEntriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SleepEntriesTable,
      SleepEntryRow,
      $$SleepEntriesTableFilterComposer,
      $$SleepEntriesTableOrderingComposer,
      $$SleepEntriesTableAnnotationComposer,
      $$SleepEntriesTableCreateCompanionBuilder,
      $$SleepEntriesTableUpdateCompanionBuilder,
      (
        SleepEntryRow,
        BaseReferences<_$AppDatabase, $SleepEntriesTable, SleepEntryRow>,
      ),
      SleepEntryRow,
      PrefetchHooks Function()
    >;
typedef $$ActivitiesTableCreateCompanionBuilder =
    ActivitiesCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required String name,
      Value<String?> description,
      Value<String?> location,
      Value<String?> triggers,
      required int durationMinutes,
      Value<bool> isArchived,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$ActivitiesTableUpdateCompanionBuilder =
    ActivitiesCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<String> name,
      Value<String?> description,
      Value<String?> location,
      Value<String?> triggers,
      Value<int> durationMinutes,
      Value<bool> isArchived,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$ActivitiesTableFilterComposer
    extends Composer<_$AppDatabase, $ActivitiesTable> {
  $$ActivitiesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get triggers => $composableBuilder(
    column: $table.triggers,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ActivitiesTableOrderingComposer
    extends Composer<_$AppDatabase, $ActivitiesTable> {
  $$ActivitiesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get triggers => $composableBuilder(
    column: $table.triggers,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ActivitiesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActivitiesTable> {
  $$ActivitiesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<String> get location =>
      $composableBuilder(column: $table.location, builder: (column) => column);

  GeneratedColumn<String> get triggers =>
      $composableBuilder(column: $table.triggers, builder: (column) => column);

  GeneratedColumn<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$ActivitiesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ActivitiesTable,
          ActivityRow,
          $$ActivitiesTableFilterComposer,
          $$ActivitiesTableOrderingComposer,
          $$ActivitiesTableAnnotationComposer,
          $$ActivitiesTableCreateCompanionBuilder,
          $$ActivitiesTableUpdateCompanionBuilder,
          (
            ActivityRow,
            BaseReferences<_$AppDatabase, $ActivitiesTable, ActivityRow>,
          ),
          ActivityRow,
          PrefetchHooks Function()
        > {
  $$ActivitiesTableTableManager(_$AppDatabase db, $ActivitiesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActivitiesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ActivitiesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ActivitiesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> triggers = const Value.absent(),
                Value<int> durationMinutes = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivitiesCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                name: name,
                description: description,
                location: location,
                triggers: triggers,
                durationMinutes: durationMinutes,
                isArchived: isArchived,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required String name,
                Value<String?> description = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> triggers = const Value.absent(),
                required int durationMinutes,
                Value<bool> isArchived = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivitiesCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                name: name,
                description: description,
                location: location,
                triggers: triggers,
                durationMinutes: durationMinutes,
                isArchived: isArchived,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ActivitiesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ActivitiesTable,
      ActivityRow,
      $$ActivitiesTableFilterComposer,
      $$ActivitiesTableOrderingComposer,
      $$ActivitiesTableAnnotationComposer,
      $$ActivitiesTableCreateCompanionBuilder,
      $$ActivitiesTableUpdateCompanionBuilder,
      (
        ActivityRow,
        BaseReferences<_$AppDatabase, $ActivitiesTable, ActivityRow>,
      ),
      ActivityRow,
      PrefetchHooks Function()
    >;
typedef $$ActivityLogsTableCreateCompanionBuilder =
    ActivityLogsCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required int timestamp,
      required String activityIds,
      required String adHocActivities,
      Value<int?> duration,
      Value<String?> notes,
      Value<String?> importSource,
      Value<String?> importExternalId,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$ActivityLogsTableUpdateCompanionBuilder =
    ActivityLogsCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<int> timestamp,
      Value<String> activityIds,
      Value<String> adHocActivities,
      Value<int?> duration,
      Value<String?> notes,
      Value<String?> importSource,
      Value<String?> importExternalId,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$ActivityLogsTableFilterComposer
    extends Composer<_$AppDatabase, $ActivityLogsTable> {
  $$ActivityLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get activityIds => $composableBuilder(
    column: $table.activityIds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get adHocActivities => $composableBuilder(
    column: $table.adHocActivities,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get duration => $composableBuilder(
    column: $table.duration,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get importExternalId => $composableBuilder(
    column: $table.importExternalId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ActivityLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $ActivityLogsTable> {
  $$ActivityLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get activityIds => $composableBuilder(
    column: $table.activityIds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get adHocActivities => $composableBuilder(
    column: $table.adHocActivities,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get duration => $composableBuilder(
    column: $table.duration,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get importExternalId => $composableBuilder(
    column: $table.importExternalId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ActivityLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActivityLogsTable> {
  $$ActivityLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<int> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<String> get activityIds => $composableBuilder(
    column: $table.activityIds,
    builder: (column) => column,
  );

  GeneratedColumn<String> get adHocActivities => $composableBuilder(
    column: $table.adHocActivities,
    builder: (column) => column,
  );

  GeneratedColumn<int> get duration =>
      $composableBuilder(column: $table.duration, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => column,
  );

  GeneratedColumn<String> get importExternalId => $composableBuilder(
    column: $table.importExternalId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$ActivityLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ActivityLogsTable,
          ActivityLogRow,
          $$ActivityLogsTableFilterComposer,
          $$ActivityLogsTableOrderingComposer,
          $$ActivityLogsTableAnnotationComposer,
          $$ActivityLogsTableCreateCompanionBuilder,
          $$ActivityLogsTableUpdateCompanionBuilder,
          (
            ActivityLogRow,
            BaseReferences<_$AppDatabase, $ActivityLogsTable, ActivityLogRow>,
          ),
          ActivityLogRow,
          PrefetchHooks Function()
        > {
  $$ActivityLogsTableTableManager(_$AppDatabase db, $ActivityLogsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActivityLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ActivityLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ActivityLogsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<int> timestamp = const Value.absent(),
                Value<String> activityIds = const Value.absent(),
                Value<String> adHocActivities = const Value.absent(),
                Value<int?> duration = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> importSource = const Value.absent(),
                Value<String?> importExternalId = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivityLogsCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                timestamp: timestamp,
                activityIds: activityIds,
                adHocActivities: adHocActivities,
                duration: duration,
                notes: notes,
                importSource: importSource,
                importExternalId: importExternalId,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required int timestamp,
                required String activityIds,
                required String adHocActivities,
                Value<int?> duration = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> importSource = const Value.absent(),
                Value<String?> importExternalId = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivityLogsCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                timestamp: timestamp,
                activityIds: activityIds,
                adHocActivities: adHocActivities,
                duration: duration,
                notes: notes,
                importSource: importSource,
                importExternalId: importExternalId,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ActivityLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ActivityLogsTable,
      ActivityLogRow,
      $$ActivityLogsTableFilterComposer,
      $$ActivityLogsTableOrderingComposer,
      $$ActivityLogsTableAnnotationComposer,
      $$ActivityLogsTableCreateCompanionBuilder,
      $$ActivityLogsTableUpdateCompanionBuilder,
      (
        ActivityLogRow,
        BaseReferences<_$AppDatabase, $ActivityLogsTable, ActivityLogRow>,
      ),
      ActivityLogRow,
      PrefetchHooks Function()
    >;
typedef $$FoodItemsTableCreateCompanionBuilder =
    FoodItemsCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required String name,
      Value<int> type,
      Value<String?> simpleItemIds,
      Value<bool> isUserCreated,
      Value<bool> isArchived,
      Value<double?> servingSize,
      Value<String?> servingUnit,
      Value<double?> calories,
      Value<double?> carbsGrams,
      Value<double?> fatGrams,
      Value<double?> proteinGrams,
      Value<double?> fiberGrams,
      Value<double?> sugarGrams,
      Value<double?> sodiumMg,
      Value<String?> barcode,
      Value<String?> brand,
      Value<String?> ingredientsText,
      Value<String?> openFoodFactsId,
      Value<String?> importSource,
      Value<String?> imageUrl,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$FoodItemsTableUpdateCompanionBuilder =
    FoodItemsCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<String> name,
      Value<int> type,
      Value<String?> simpleItemIds,
      Value<bool> isUserCreated,
      Value<bool> isArchived,
      Value<double?> servingSize,
      Value<String?> servingUnit,
      Value<double?> calories,
      Value<double?> carbsGrams,
      Value<double?> fatGrams,
      Value<double?> proteinGrams,
      Value<double?> fiberGrams,
      Value<double?> sugarGrams,
      Value<double?> sodiumMg,
      Value<String?> barcode,
      Value<String?> brand,
      Value<String?> ingredientsText,
      Value<String?> openFoodFactsId,
      Value<String?> importSource,
      Value<String?> imageUrl,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$FoodItemsTableFilterComposer
    extends Composer<_$AppDatabase, $FoodItemsTable> {
  $$FoodItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get simpleItemIds => $composableBuilder(
    column: $table.simpleItemIds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isUserCreated => $composableBuilder(
    column: $table.isUserCreated,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get servingSize => $composableBuilder(
    column: $table.servingSize,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get servingUnit => $composableBuilder(
    column: $table.servingUnit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get calories => $composableBuilder(
    column: $table.calories,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get carbsGrams => $composableBuilder(
    column: $table.carbsGrams,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get fatGrams => $composableBuilder(
    column: $table.fatGrams,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get proteinGrams => $composableBuilder(
    column: $table.proteinGrams,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get fiberGrams => $composableBuilder(
    column: $table.fiberGrams,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sugarGrams => $composableBuilder(
    column: $table.sugarGrams,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sodiumMg => $composableBuilder(
    column: $table.sodiumMg,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get barcode => $composableBuilder(
    column: $table.barcode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get brand => $composableBuilder(
    column: $table.brand,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ingredientsText => $composableBuilder(
    column: $table.ingredientsText,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get openFoodFactsId => $composableBuilder(
    column: $table.openFoodFactsId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FoodItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $FoodItemsTable> {
  $$FoodItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get simpleItemIds => $composableBuilder(
    column: $table.simpleItemIds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isUserCreated => $composableBuilder(
    column: $table.isUserCreated,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get servingSize => $composableBuilder(
    column: $table.servingSize,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get servingUnit => $composableBuilder(
    column: $table.servingUnit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get calories => $composableBuilder(
    column: $table.calories,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get carbsGrams => $composableBuilder(
    column: $table.carbsGrams,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get fatGrams => $composableBuilder(
    column: $table.fatGrams,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get proteinGrams => $composableBuilder(
    column: $table.proteinGrams,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get fiberGrams => $composableBuilder(
    column: $table.fiberGrams,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sugarGrams => $composableBuilder(
    column: $table.sugarGrams,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sodiumMg => $composableBuilder(
    column: $table.sodiumMg,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get barcode => $composableBuilder(
    column: $table.barcode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get brand => $composableBuilder(
    column: $table.brand,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ingredientsText => $composableBuilder(
    column: $table.ingredientsText,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get openFoodFactsId => $composableBuilder(
    column: $table.openFoodFactsId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FoodItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FoodItemsTable> {
  $$FoodItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get simpleItemIds => $composableBuilder(
    column: $table.simpleItemIds,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isUserCreated => $composableBuilder(
    column: $table.isUserCreated,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => column,
  );

  GeneratedColumn<double> get servingSize => $composableBuilder(
    column: $table.servingSize,
    builder: (column) => column,
  );

  GeneratedColumn<String> get servingUnit => $composableBuilder(
    column: $table.servingUnit,
    builder: (column) => column,
  );

  GeneratedColumn<double> get calories =>
      $composableBuilder(column: $table.calories, builder: (column) => column);

  GeneratedColumn<double> get carbsGrams => $composableBuilder(
    column: $table.carbsGrams,
    builder: (column) => column,
  );

  GeneratedColumn<double> get fatGrams =>
      $composableBuilder(column: $table.fatGrams, builder: (column) => column);

  GeneratedColumn<double> get proteinGrams => $composableBuilder(
    column: $table.proteinGrams,
    builder: (column) => column,
  );

  GeneratedColumn<double> get fiberGrams => $composableBuilder(
    column: $table.fiberGrams,
    builder: (column) => column,
  );

  GeneratedColumn<double> get sugarGrams => $composableBuilder(
    column: $table.sugarGrams,
    builder: (column) => column,
  );

  GeneratedColumn<double> get sodiumMg =>
      $composableBuilder(column: $table.sodiumMg, builder: (column) => column);

  GeneratedColumn<String> get barcode =>
      $composableBuilder(column: $table.barcode, builder: (column) => column);

  GeneratedColumn<String> get brand =>
      $composableBuilder(column: $table.brand, builder: (column) => column);

  GeneratedColumn<String> get ingredientsText => $composableBuilder(
    column: $table.ingredientsText,
    builder: (column) => column,
  );

  GeneratedColumn<String> get openFoodFactsId => $composableBuilder(
    column: $table.openFoodFactsId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get importSource => $composableBuilder(
    column: $table.importSource,
    builder: (column) => column,
  );

  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$FoodItemsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FoodItemsTable,
          FoodItemRow,
          $$FoodItemsTableFilterComposer,
          $$FoodItemsTableOrderingComposer,
          $$FoodItemsTableAnnotationComposer,
          $$FoodItemsTableCreateCompanionBuilder,
          $$FoodItemsTableUpdateCompanionBuilder,
          (
            FoodItemRow,
            BaseReferences<_$AppDatabase, $FoodItemsTable, FoodItemRow>,
          ),
          FoodItemRow,
          PrefetchHooks Function()
        > {
  $$FoodItemsTableTableManager(_$AppDatabase db, $FoodItemsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FoodItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FoodItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FoodItemsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> type = const Value.absent(),
                Value<String?> simpleItemIds = const Value.absent(),
                Value<bool> isUserCreated = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                Value<double?> servingSize = const Value.absent(),
                Value<String?> servingUnit = const Value.absent(),
                Value<double?> calories = const Value.absent(),
                Value<double?> carbsGrams = const Value.absent(),
                Value<double?> fatGrams = const Value.absent(),
                Value<double?> proteinGrams = const Value.absent(),
                Value<double?> fiberGrams = const Value.absent(),
                Value<double?> sugarGrams = const Value.absent(),
                Value<double?> sodiumMg = const Value.absent(),
                Value<String?> barcode = const Value.absent(),
                Value<String?> brand = const Value.absent(),
                Value<String?> ingredientsText = const Value.absent(),
                Value<String?> openFoodFactsId = const Value.absent(),
                Value<String?> importSource = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FoodItemsCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                name: name,
                type: type,
                simpleItemIds: simpleItemIds,
                isUserCreated: isUserCreated,
                isArchived: isArchived,
                servingSize: servingSize,
                servingUnit: servingUnit,
                calories: calories,
                carbsGrams: carbsGrams,
                fatGrams: fatGrams,
                proteinGrams: proteinGrams,
                fiberGrams: fiberGrams,
                sugarGrams: sugarGrams,
                sodiumMg: sodiumMg,
                barcode: barcode,
                brand: brand,
                ingredientsText: ingredientsText,
                openFoodFactsId: openFoodFactsId,
                importSource: importSource,
                imageUrl: imageUrl,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required String name,
                Value<int> type = const Value.absent(),
                Value<String?> simpleItemIds = const Value.absent(),
                Value<bool> isUserCreated = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                Value<double?> servingSize = const Value.absent(),
                Value<String?> servingUnit = const Value.absent(),
                Value<double?> calories = const Value.absent(),
                Value<double?> carbsGrams = const Value.absent(),
                Value<double?> fatGrams = const Value.absent(),
                Value<double?> proteinGrams = const Value.absent(),
                Value<double?> fiberGrams = const Value.absent(),
                Value<double?> sugarGrams = const Value.absent(),
                Value<double?> sodiumMg = const Value.absent(),
                Value<String?> barcode = const Value.absent(),
                Value<String?> brand = const Value.absent(),
                Value<String?> ingredientsText = const Value.absent(),
                Value<String?> openFoodFactsId = const Value.absent(),
                Value<String?> importSource = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FoodItemsCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                name: name,
                type: type,
                simpleItemIds: simpleItemIds,
                isUserCreated: isUserCreated,
                isArchived: isArchived,
                servingSize: servingSize,
                servingUnit: servingUnit,
                calories: calories,
                carbsGrams: carbsGrams,
                fatGrams: fatGrams,
                proteinGrams: proteinGrams,
                fiberGrams: fiberGrams,
                sugarGrams: sugarGrams,
                sodiumMg: sodiumMg,
                barcode: barcode,
                brand: brand,
                ingredientsText: ingredientsText,
                openFoodFactsId: openFoodFactsId,
                importSource: importSource,
                imageUrl: imageUrl,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FoodItemsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FoodItemsTable,
      FoodItemRow,
      $$FoodItemsTableFilterComposer,
      $$FoodItemsTableOrderingComposer,
      $$FoodItemsTableAnnotationComposer,
      $$FoodItemsTableCreateCompanionBuilder,
      $$FoodItemsTableUpdateCompanionBuilder,
      (
        FoodItemRow,
        BaseReferences<_$AppDatabase, $FoodItemsTable, FoodItemRow>,
      ),
      FoodItemRow,
      PrefetchHooks Function()
    >;
typedef $$FoodItemComponentsTableCreateCompanionBuilder =
    FoodItemComponentsCompanion Function({
      required String id,
      required String composedFoodItemId,
      required String simpleFoodItemId,
      Value<double> quantity,
      Value<int> sortOrder,
      Value<int> rowid,
    });
typedef $$FoodItemComponentsTableUpdateCompanionBuilder =
    FoodItemComponentsCompanion Function({
      Value<String> id,
      Value<String> composedFoodItemId,
      Value<String> simpleFoodItemId,
      Value<double> quantity,
      Value<int> sortOrder,
      Value<int> rowid,
    });

class $$FoodItemComponentsTableFilterComposer
    extends Composer<_$AppDatabase, $FoodItemComponentsTable> {
  $$FoodItemComponentsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get composedFoodItemId => $composableBuilder(
    column: $table.composedFoodItemId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get simpleFoodItemId => $composableBuilder(
    column: $table.simpleFoodItemId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FoodItemComponentsTableOrderingComposer
    extends Composer<_$AppDatabase, $FoodItemComponentsTable> {
  $$FoodItemComponentsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get composedFoodItemId => $composableBuilder(
    column: $table.composedFoodItemId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get simpleFoodItemId => $composableBuilder(
    column: $table.simpleFoodItemId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FoodItemComponentsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FoodItemComponentsTable> {
  $$FoodItemComponentsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get composedFoodItemId => $composableBuilder(
    column: $table.composedFoodItemId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get simpleFoodItemId => $composableBuilder(
    column: $table.simpleFoodItemId,
    builder: (column) => column,
  );

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);
}

class $$FoodItemComponentsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FoodItemComponentsTable,
          FoodItemComponentRow,
          $$FoodItemComponentsTableFilterComposer,
          $$FoodItemComponentsTableOrderingComposer,
          $$FoodItemComponentsTableAnnotationComposer,
          $$FoodItemComponentsTableCreateCompanionBuilder,
          $$FoodItemComponentsTableUpdateCompanionBuilder,
          (
            FoodItemComponentRow,
            BaseReferences<
              _$AppDatabase,
              $FoodItemComponentsTable,
              FoodItemComponentRow
            >,
          ),
          FoodItemComponentRow,
          PrefetchHooks Function()
        > {
  $$FoodItemComponentsTableTableManager(
    _$AppDatabase db,
    $FoodItemComponentsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FoodItemComponentsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FoodItemComponentsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FoodItemComponentsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> composedFoodItemId = const Value.absent(),
                Value<String> simpleFoodItemId = const Value.absent(),
                Value<double> quantity = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FoodItemComponentsCompanion(
                id: id,
                composedFoodItemId: composedFoodItemId,
                simpleFoodItemId: simpleFoodItemId,
                quantity: quantity,
                sortOrder: sortOrder,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String composedFoodItemId,
                required String simpleFoodItemId,
                Value<double> quantity = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FoodItemComponentsCompanion.insert(
                id: id,
                composedFoodItemId: composedFoodItemId,
                simpleFoodItemId: simpleFoodItemId,
                quantity: quantity,
                sortOrder: sortOrder,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FoodItemComponentsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FoodItemComponentsTable,
      FoodItemComponentRow,
      $$FoodItemComponentsTableFilterComposer,
      $$FoodItemComponentsTableOrderingComposer,
      $$FoodItemComponentsTableAnnotationComposer,
      $$FoodItemComponentsTableCreateCompanionBuilder,
      $$FoodItemComponentsTableUpdateCompanionBuilder,
      (
        FoodItemComponentRow,
        BaseReferences<
          _$AppDatabase,
          $FoodItemComponentsTable,
          FoodItemComponentRow
        >,
      ),
      FoodItemComponentRow,
      PrefetchHooks Function()
    >;
typedef $$FoodBarcodeCacheTableCreateCompanionBuilder =
    FoodBarcodeCacheCompanion Function({
      required String id,
      required String barcode,
      Value<String?> productName,
      Value<String?> brand,
      Value<String?> ingredientsText,
      Value<double?> calories,
      Value<double?> carbs,
      Value<double?> fat,
      Value<double?> protein,
      Value<double?> fiber,
      Value<double?> sugar,
      Value<double?> sodiumMg,
      Value<String?> openFoodFactsId,
      Value<String?> imageUrl,
      Value<String?> rawResponse,
      required int fetchedAt,
      required int expiresAt,
      Value<int> rowid,
    });
typedef $$FoodBarcodeCacheTableUpdateCompanionBuilder =
    FoodBarcodeCacheCompanion Function({
      Value<String> id,
      Value<String> barcode,
      Value<String?> productName,
      Value<String?> brand,
      Value<String?> ingredientsText,
      Value<double?> calories,
      Value<double?> carbs,
      Value<double?> fat,
      Value<double?> protein,
      Value<double?> fiber,
      Value<double?> sugar,
      Value<double?> sodiumMg,
      Value<String?> openFoodFactsId,
      Value<String?> imageUrl,
      Value<String?> rawResponse,
      Value<int> fetchedAt,
      Value<int> expiresAt,
      Value<int> rowid,
    });

class $$FoodBarcodeCacheTableFilterComposer
    extends Composer<_$AppDatabase, $FoodBarcodeCacheTable> {
  $$FoodBarcodeCacheTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get barcode => $composableBuilder(
    column: $table.barcode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get brand => $composableBuilder(
    column: $table.brand,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ingredientsText => $composableBuilder(
    column: $table.ingredientsText,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get calories => $composableBuilder(
    column: $table.calories,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get carbs => $composableBuilder(
    column: $table.carbs,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get fat => $composableBuilder(
    column: $table.fat,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get protein => $composableBuilder(
    column: $table.protein,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get fiber => $composableBuilder(
    column: $table.fiber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sugar => $composableBuilder(
    column: $table.sugar,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sodiumMg => $composableBuilder(
    column: $table.sodiumMg,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get openFoodFactsId => $composableBuilder(
    column: $table.openFoodFactsId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get rawResponse => $composableBuilder(
    column: $table.rawResponse,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get fetchedAt => $composableBuilder(
    column: $table.fetchedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FoodBarcodeCacheTableOrderingComposer
    extends Composer<_$AppDatabase, $FoodBarcodeCacheTable> {
  $$FoodBarcodeCacheTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get barcode => $composableBuilder(
    column: $table.barcode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get brand => $composableBuilder(
    column: $table.brand,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ingredientsText => $composableBuilder(
    column: $table.ingredientsText,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get calories => $composableBuilder(
    column: $table.calories,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get carbs => $composableBuilder(
    column: $table.carbs,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get fat => $composableBuilder(
    column: $table.fat,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get protein => $composableBuilder(
    column: $table.protein,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get fiber => $composableBuilder(
    column: $table.fiber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sugar => $composableBuilder(
    column: $table.sugar,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sodiumMg => $composableBuilder(
    column: $table.sodiumMg,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get openFoodFactsId => $composableBuilder(
    column: $table.openFoodFactsId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get rawResponse => $composableBuilder(
    column: $table.rawResponse,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get fetchedAt => $composableBuilder(
    column: $table.fetchedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FoodBarcodeCacheTableAnnotationComposer
    extends Composer<_$AppDatabase, $FoodBarcodeCacheTable> {
  $$FoodBarcodeCacheTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get barcode =>
      $composableBuilder(column: $table.barcode, builder: (column) => column);

  GeneratedColumn<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get brand =>
      $composableBuilder(column: $table.brand, builder: (column) => column);

  GeneratedColumn<String> get ingredientsText => $composableBuilder(
    column: $table.ingredientsText,
    builder: (column) => column,
  );

  GeneratedColumn<double> get calories =>
      $composableBuilder(column: $table.calories, builder: (column) => column);

  GeneratedColumn<double> get carbs =>
      $composableBuilder(column: $table.carbs, builder: (column) => column);

  GeneratedColumn<double> get fat =>
      $composableBuilder(column: $table.fat, builder: (column) => column);

  GeneratedColumn<double> get protein =>
      $composableBuilder(column: $table.protein, builder: (column) => column);

  GeneratedColumn<double> get fiber =>
      $composableBuilder(column: $table.fiber, builder: (column) => column);

  GeneratedColumn<double> get sugar =>
      $composableBuilder(column: $table.sugar, builder: (column) => column);

  GeneratedColumn<double> get sodiumMg =>
      $composableBuilder(column: $table.sodiumMg, builder: (column) => column);

  GeneratedColumn<String> get openFoodFactsId => $composableBuilder(
    column: $table.openFoodFactsId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumn<String> get rawResponse => $composableBuilder(
    column: $table.rawResponse,
    builder: (column) => column,
  );

  GeneratedColumn<int> get fetchedAt =>
      $composableBuilder(column: $table.fetchedAt, builder: (column) => column);

  GeneratedColumn<int> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);
}

class $$FoodBarcodeCacheTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FoodBarcodeCacheTable,
          FoodBarcodeCacheRow,
          $$FoodBarcodeCacheTableFilterComposer,
          $$FoodBarcodeCacheTableOrderingComposer,
          $$FoodBarcodeCacheTableAnnotationComposer,
          $$FoodBarcodeCacheTableCreateCompanionBuilder,
          $$FoodBarcodeCacheTableUpdateCompanionBuilder,
          (
            FoodBarcodeCacheRow,
            BaseReferences<
              _$AppDatabase,
              $FoodBarcodeCacheTable,
              FoodBarcodeCacheRow
            >,
          ),
          FoodBarcodeCacheRow,
          PrefetchHooks Function()
        > {
  $$FoodBarcodeCacheTableTableManager(
    _$AppDatabase db,
    $FoodBarcodeCacheTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FoodBarcodeCacheTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FoodBarcodeCacheTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FoodBarcodeCacheTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> barcode = const Value.absent(),
                Value<String?> productName = const Value.absent(),
                Value<String?> brand = const Value.absent(),
                Value<String?> ingredientsText = const Value.absent(),
                Value<double?> calories = const Value.absent(),
                Value<double?> carbs = const Value.absent(),
                Value<double?> fat = const Value.absent(),
                Value<double?> protein = const Value.absent(),
                Value<double?> fiber = const Value.absent(),
                Value<double?> sugar = const Value.absent(),
                Value<double?> sodiumMg = const Value.absent(),
                Value<String?> openFoodFactsId = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                Value<String?> rawResponse = const Value.absent(),
                Value<int> fetchedAt = const Value.absent(),
                Value<int> expiresAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FoodBarcodeCacheCompanion(
                id: id,
                barcode: barcode,
                productName: productName,
                brand: brand,
                ingredientsText: ingredientsText,
                calories: calories,
                carbs: carbs,
                fat: fat,
                protein: protein,
                fiber: fiber,
                sugar: sugar,
                sodiumMg: sodiumMg,
                openFoodFactsId: openFoodFactsId,
                imageUrl: imageUrl,
                rawResponse: rawResponse,
                fetchedAt: fetchedAt,
                expiresAt: expiresAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String barcode,
                Value<String?> productName = const Value.absent(),
                Value<String?> brand = const Value.absent(),
                Value<String?> ingredientsText = const Value.absent(),
                Value<double?> calories = const Value.absent(),
                Value<double?> carbs = const Value.absent(),
                Value<double?> fat = const Value.absent(),
                Value<double?> protein = const Value.absent(),
                Value<double?> fiber = const Value.absent(),
                Value<double?> sugar = const Value.absent(),
                Value<double?> sodiumMg = const Value.absent(),
                Value<String?> openFoodFactsId = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                Value<String?> rawResponse = const Value.absent(),
                required int fetchedAt,
                required int expiresAt,
                Value<int> rowid = const Value.absent(),
              }) => FoodBarcodeCacheCompanion.insert(
                id: id,
                barcode: barcode,
                productName: productName,
                brand: brand,
                ingredientsText: ingredientsText,
                calories: calories,
                carbs: carbs,
                fat: fat,
                protein: protein,
                fiber: fiber,
                sugar: sugar,
                sodiumMg: sodiumMg,
                openFoodFactsId: openFoodFactsId,
                imageUrl: imageUrl,
                rawResponse: rawResponse,
                fetchedAt: fetchedAt,
                expiresAt: expiresAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FoodBarcodeCacheTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FoodBarcodeCacheTable,
      FoodBarcodeCacheRow,
      $$FoodBarcodeCacheTableFilterComposer,
      $$FoodBarcodeCacheTableOrderingComposer,
      $$FoodBarcodeCacheTableAnnotationComposer,
      $$FoodBarcodeCacheTableCreateCompanionBuilder,
      $$FoodBarcodeCacheTableUpdateCompanionBuilder,
      (
        FoodBarcodeCacheRow,
        BaseReferences<
          _$AppDatabase,
          $FoodBarcodeCacheTable,
          FoodBarcodeCacheRow
        >,
      ),
      FoodBarcodeCacheRow,
      PrefetchHooks Function()
    >;
typedef $$FoodLogsTableCreateCompanionBuilder =
    FoodLogsCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required int timestamp,
      Value<int?> mealType,
      required String foodItemIds,
      required String adHocItems,
      Value<String?> notes,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$FoodLogsTableUpdateCompanionBuilder =
    FoodLogsCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<int> timestamp,
      Value<int?> mealType,
      Value<String> foodItemIds,
      Value<String> adHocItems,
      Value<String?> notes,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$FoodLogsTableFilterComposer
    extends Composer<_$AppDatabase, $FoodLogsTable> {
  $$FoodLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mealType => $composableBuilder(
    column: $table.mealType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get foodItemIds => $composableBuilder(
    column: $table.foodItemIds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get adHocItems => $composableBuilder(
    column: $table.adHocItems,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FoodLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $FoodLogsTable> {
  $$FoodLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mealType => $composableBuilder(
    column: $table.mealType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get foodItemIds => $composableBuilder(
    column: $table.foodItemIds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get adHocItems => $composableBuilder(
    column: $table.adHocItems,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FoodLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FoodLogsTable> {
  $$FoodLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<int> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<int> get mealType =>
      $composableBuilder(column: $table.mealType, builder: (column) => column);

  GeneratedColumn<String> get foodItemIds => $composableBuilder(
    column: $table.foodItemIds,
    builder: (column) => column,
  );

  GeneratedColumn<String> get adHocItems => $composableBuilder(
    column: $table.adHocItems,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$FoodLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FoodLogsTable,
          FoodLogRow,
          $$FoodLogsTableFilterComposer,
          $$FoodLogsTableOrderingComposer,
          $$FoodLogsTableAnnotationComposer,
          $$FoodLogsTableCreateCompanionBuilder,
          $$FoodLogsTableUpdateCompanionBuilder,
          (
            FoodLogRow,
            BaseReferences<_$AppDatabase, $FoodLogsTable, FoodLogRow>,
          ),
          FoodLogRow,
          PrefetchHooks Function()
        > {
  $$FoodLogsTableTableManager(_$AppDatabase db, $FoodLogsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FoodLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FoodLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FoodLogsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<int> timestamp = const Value.absent(),
                Value<int?> mealType = const Value.absent(),
                Value<String> foodItemIds = const Value.absent(),
                Value<String> adHocItems = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FoodLogsCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                timestamp: timestamp,
                mealType: mealType,
                foodItemIds: foodItemIds,
                adHocItems: adHocItems,
                notes: notes,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required int timestamp,
                Value<int?> mealType = const Value.absent(),
                required String foodItemIds,
                required String adHocItems,
                Value<String?> notes = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FoodLogsCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                timestamp: timestamp,
                mealType: mealType,
                foodItemIds: foodItemIds,
                adHocItems: adHocItems,
                notes: notes,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FoodLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FoodLogsTable,
      FoodLogRow,
      $$FoodLogsTableFilterComposer,
      $$FoodLogsTableOrderingComposer,
      $$FoodLogsTableAnnotationComposer,
      $$FoodLogsTableCreateCompanionBuilder,
      $$FoodLogsTableUpdateCompanionBuilder,
      (FoodLogRow, BaseReferences<_$AppDatabase, $FoodLogsTable, FoodLogRow>),
      FoodLogRow,
      PrefetchHooks Function()
    >;
typedef $$JournalEntriesTableCreateCompanionBuilder =
    JournalEntriesCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required int timestamp,
      required String content,
      Value<String?> title,
      Value<int?> mood,
      Value<String?> tags,
      Value<String?> audioUrl,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$JournalEntriesTableUpdateCompanionBuilder =
    JournalEntriesCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<int> timestamp,
      Value<String> content,
      Value<String?> title,
      Value<int?> mood,
      Value<String?> tags,
      Value<String?> audioUrl,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$JournalEntriesTableFilterComposer
    extends Composer<_$AppDatabase, $JournalEntriesTable> {
  $$JournalEntriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get content => $composableBuilder(
    column: $table.content,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mood => $composableBuilder(
    column: $table.mood,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tags => $composableBuilder(
    column: $table.tags,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get audioUrl => $composableBuilder(
    column: $table.audioUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$JournalEntriesTableOrderingComposer
    extends Composer<_$AppDatabase, $JournalEntriesTable> {
  $$JournalEntriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get content => $composableBuilder(
    column: $table.content,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mood => $composableBuilder(
    column: $table.mood,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tags => $composableBuilder(
    column: $table.tags,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get audioUrl => $composableBuilder(
    column: $table.audioUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$JournalEntriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $JournalEntriesTable> {
  $$JournalEntriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<int> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<String> get content =>
      $composableBuilder(column: $table.content, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<int> get mood =>
      $composableBuilder(column: $table.mood, builder: (column) => column);

  GeneratedColumn<String> get tags =>
      $composableBuilder(column: $table.tags, builder: (column) => column);

  GeneratedColumn<String> get audioUrl =>
      $composableBuilder(column: $table.audioUrl, builder: (column) => column);

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$JournalEntriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $JournalEntriesTable,
          JournalEntryRow,
          $$JournalEntriesTableFilterComposer,
          $$JournalEntriesTableOrderingComposer,
          $$JournalEntriesTableAnnotationComposer,
          $$JournalEntriesTableCreateCompanionBuilder,
          $$JournalEntriesTableUpdateCompanionBuilder,
          (
            JournalEntryRow,
            BaseReferences<
              _$AppDatabase,
              $JournalEntriesTable,
              JournalEntryRow
            >,
          ),
          JournalEntryRow,
          PrefetchHooks Function()
        > {
  $$JournalEntriesTableTableManager(
    _$AppDatabase db,
    $JournalEntriesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$JournalEntriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$JournalEntriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$JournalEntriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<int> timestamp = const Value.absent(),
                Value<String> content = const Value.absent(),
                Value<String?> title = const Value.absent(),
                Value<int?> mood = const Value.absent(),
                Value<String?> tags = const Value.absent(),
                Value<String?> audioUrl = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => JournalEntriesCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                timestamp: timestamp,
                content: content,
                title: title,
                mood: mood,
                tags: tags,
                audioUrl: audioUrl,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required int timestamp,
                required String content,
                Value<String?> title = const Value.absent(),
                Value<int?> mood = const Value.absent(),
                Value<String?> tags = const Value.absent(),
                Value<String?> audioUrl = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => JournalEntriesCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                timestamp: timestamp,
                content: content,
                title: title,
                mood: mood,
                tags: tags,
                audioUrl: audioUrl,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$JournalEntriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $JournalEntriesTable,
      JournalEntryRow,
      $$JournalEntriesTableFilterComposer,
      $$JournalEntriesTableOrderingComposer,
      $$JournalEntriesTableAnnotationComposer,
      $$JournalEntriesTableCreateCompanionBuilder,
      $$JournalEntriesTableUpdateCompanionBuilder,
      (
        JournalEntryRow,
        BaseReferences<_$AppDatabase, $JournalEntriesTable, JournalEntryRow>,
      ),
      JournalEntryRow,
      PrefetchHooks Function()
    >;
typedef $$PhotoAreasTableCreateCompanionBuilder =
    PhotoAreasCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required String name,
      Value<String?> description,
      Value<String?> consistencyNotes,
      Value<int> sortOrder,
      Value<bool> isArchived,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$PhotoAreasTableUpdateCompanionBuilder =
    PhotoAreasCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<String> name,
      Value<String?> description,
      Value<String?> consistencyNotes,
      Value<int> sortOrder,
      Value<bool> isArchived,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$PhotoAreasTableFilterComposer
    extends Composer<_$AppDatabase, $PhotoAreasTable> {
  $$PhotoAreasTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get consistencyNotes => $composableBuilder(
    column: $table.consistencyNotes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$PhotoAreasTableOrderingComposer
    extends Composer<_$AppDatabase, $PhotoAreasTable> {
  $$PhotoAreasTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get consistencyNotes => $composableBuilder(
    column: $table.consistencyNotes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$PhotoAreasTableAnnotationComposer
    extends Composer<_$AppDatabase, $PhotoAreasTable> {
  $$PhotoAreasTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<String> get consistencyNotes => $composableBuilder(
    column: $table.consistencyNotes,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$PhotoAreasTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PhotoAreasTable,
          PhotoAreaRow,
          $$PhotoAreasTableFilterComposer,
          $$PhotoAreasTableOrderingComposer,
          $$PhotoAreasTableAnnotationComposer,
          $$PhotoAreasTableCreateCompanionBuilder,
          $$PhotoAreasTableUpdateCompanionBuilder,
          (
            PhotoAreaRow,
            BaseReferences<_$AppDatabase, $PhotoAreasTable, PhotoAreaRow>,
          ),
          PhotoAreaRow,
          PrefetchHooks Function()
        > {
  $$PhotoAreasTableTableManager(_$AppDatabase db, $PhotoAreasTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PhotoAreasTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PhotoAreasTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PhotoAreasTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<String?> consistencyNotes = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PhotoAreasCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                name: name,
                description: description,
                consistencyNotes: consistencyNotes,
                sortOrder: sortOrder,
                isArchived: isArchived,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required String name,
                Value<String?> description = const Value.absent(),
                Value<String?> consistencyNotes = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PhotoAreasCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                name: name,
                description: description,
                consistencyNotes: consistencyNotes,
                sortOrder: sortOrder,
                isArchived: isArchived,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$PhotoAreasTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PhotoAreasTable,
      PhotoAreaRow,
      $$PhotoAreasTableFilterComposer,
      $$PhotoAreasTableOrderingComposer,
      $$PhotoAreasTableAnnotationComposer,
      $$PhotoAreasTableCreateCompanionBuilder,
      $$PhotoAreasTableUpdateCompanionBuilder,
      (
        PhotoAreaRow,
        BaseReferences<_$AppDatabase, $PhotoAreasTable, PhotoAreaRow>,
      ),
      PhotoAreaRow,
      PrefetchHooks Function()
    >;
typedef $$PhotoEntriesTableCreateCompanionBuilder =
    PhotoEntriesCompanion Function({
      required String id,
      required String clientId,
      required String profileId,
      required String photoAreaId,
      required int timestamp,
      required String filePath,
      Value<String?> notes,
      Value<String?> cloudStorageUrl,
      Value<String?> fileHash,
      Value<int?> fileSizeBytes,
      Value<bool> isFileUploaded,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$PhotoEntriesTableUpdateCompanionBuilder =
    PhotoEntriesCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> profileId,
      Value<String> photoAreaId,
      Value<int> timestamp,
      Value<String> filePath,
      Value<String?> notes,
      Value<String?> cloudStorageUrl,
      Value<String?> fileHash,
      Value<int?> fileSizeBytes,
      Value<bool> isFileUploaded,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$PhotoEntriesTableFilterComposer
    extends Composer<_$AppDatabase, $PhotoEntriesTable> {
  $$PhotoEntriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get photoAreaId => $composableBuilder(
    column: $table.photoAreaId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get filePath => $composableBuilder(
    column: $table.filePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get cloudStorageUrl => $composableBuilder(
    column: $table.cloudStorageUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fileHash => $composableBuilder(
    column: $table.fileHash,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get fileSizeBytes => $composableBuilder(
    column: $table.fileSizeBytes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFileUploaded => $composableBuilder(
    column: $table.isFileUploaded,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$PhotoEntriesTableOrderingComposer
    extends Composer<_$AppDatabase, $PhotoEntriesTable> {
  $$PhotoEntriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get photoAreaId => $composableBuilder(
    column: $table.photoAreaId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get filePath => $composableBuilder(
    column: $table.filePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get cloudStorageUrl => $composableBuilder(
    column: $table.cloudStorageUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fileHash => $composableBuilder(
    column: $table.fileHash,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get fileSizeBytes => $composableBuilder(
    column: $table.fileSizeBytes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFileUploaded => $composableBuilder(
    column: $table.isFileUploaded,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$PhotoEntriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $PhotoEntriesTable> {
  $$PhotoEntriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<String> get photoAreaId => $composableBuilder(
    column: $table.photoAreaId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<String> get filePath =>
      $composableBuilder(column: $table.filePath, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get cloudStorageUrl => $composableBuilder(
    column: $table.cloudStorageUrl,
    builder: (column) => column,
  );

  GeneratedColumn<String> get fileHash =>
      $composableBuilder(column: $table.fileHash, builder: (column) => column);

  GeneratedColumn<int> get fileSizeBytes => $composableBuilder(
    column: $table.fileSizeBytes,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isFileUploaded => $composableBuilder(
    column: $table.isFileUploaded,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$PhotoEntriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PhotoEntriesTable,
          PhotoEntryRow,
          $$PhotoEntriesTableFilterComposer,
          $$PhotoEntriesTableOrderingComposer,
          $$PhotoEntriesTableAnnotationComposer,
          $$PhotoEntriesTableCreateCompanionBuilder,
          $$PhotoEntriesTableUpdateCompanionBuilder,
          (
            PhotoEntryRow,
            BaseReferences<_$AppDatabase, $PhotoEntriesTable, PhotoEntryRow>,
          ),
          PhotoEntryRow,
          PrefetchHooks Function()
        > {
  $$PhotoEntriesTableTableManager(_$AppDatabase db, $PhotoEntriesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PhotoEntriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PhotoEntriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PhotoEntriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> photoAreaId = const Value.absent(),
                Value<int> timestamp = const Value.absent(),
                Value<String> filePath = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> cloudStorageUrl = const Value.absent(),
                Value<String?> fileHash = const Value.absent(),
                Value<int?> fileSizeBytes = const Value.absent(),
                Value<bool> isFileUploaded = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PhotoEntriesCompanion(
                id: id,
                clientId: clientId,
                profileId: profileId,
                photoAreaId: photoAreaId,
                timestamp: timestamp,
                filePath: filePath,
                notes: notes,
                cloudStorageUrl: cloudStorageUrl,
                fileHash: fileHash,
                fileSizeBytes: fileSizeBytes,
                isFileUploaded: isFileUploaded,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String profileId,
                required String photoAreaId,
                required int timestamp,
                required String filePath,
                Value<String?> notes = const Value.absent(),
                Value<String?> cloudStorageUrl = const Value.absent(),
                Value<String?> fileHash = const Value.absent(),
                Value<int?> fileSizeBytes = const Value.absent(),
                Value<bool> isFileUploaded = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PhotoEntriesCompanion.insert(
                id: id,
                clientId: clientId,
                profileId: profileId,
                photoAreaId: photoAreaId,
                timestamp: timestamp,
                filePath: filePath,
                notes: notes,
                cloudStorageUrl: cloudStorageUrl,
                fileHash: fileHash,
                fileSizeBytes: fileSizeBytes,
                isFileUploaded: isFileUploaded,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$PhotoEntriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PhotoEntriesTable,
      PhotoEntryRow,
      $$PhotoEntriesTableFilterComposer,
      $$PhotoEntriesTableOrderingComposer,
      $$PhotoEntriesTableAnnotationComposer,
      $$PhotoEntriesTableCreateCompanionBuilder,
      $$PhotoEntriesTableUpdateCompanionBuilder,
      (
        PhotoEntryRow,
        BaseReferences<_$AppDatabase, $PhotoEntriesTable, PhotoEntryRow>,
      ),
      PhotoEntryRow,
      PrefetchHooks Function()
    >;
typedef $$ProfilesTableCreateCompanionBuilder =
    ProfilesCompanion Function({
      required String id,
      required String clientId,
      required String name,
      Value<int?> birthDate,
      Value<int?> biologicalSex,
      Value<String?> ethnicity,
      Value<String?> notes,
      Value<String?> ownerId,
      Value<int> dietType,
      Value<String?> dietDescription,
      required int syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });
typedef $$ProfilesTableUpdateCompanionBuilder =
    ProfilesCompanion Function({
      Value<String> id,
      Value<String> clientId,
      Value<String> name,
      Value<int?> birthDate,
      Value<int?> biologicalSex,
      Value<String?> ethnicity,
      Value<String?> notes,
      Value<String?> ownerId,
      Value<int> dietType,
      Value<String?> dietDescription,
      Value<int> syncCreatedAt,
      Value<int?> syncUpdatedAt,
      Value<int?> syncDeletedAt,
      Value<int?> syncLastSyncedAt,
      Value<int> syncStatus,
      Value<int> syncVersion,
      Value<String?> syncDeviceId,
      Value<bool> syncIsDirty,
      Value<String?> conflictData,
      Value<int> rowid,
    });

class $$ProfilesTableFilterComposer
    extends Composer<_$AppDatabase, $ProfilesTable> {
  $$ProfilesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get birthDate => $composableBuilder(
    column: $table.birthDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get biologicalSex => $composableBuilder(
    column: $table.biologicalSex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ethnicity => $composableBuilder(
    column: $table.ethnicity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ownerId => $composableBuilder(
    column: $table.ownerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dietType => $composableBuilder(
    column: $table.dietType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get dietDescription => $composableBuilder(
    column: $table.dietDescription,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ProfilesTableOrderingComposer
    extends Composer<_$AppDatabase, $ProfilesTable> {
  $$ProfilesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clientId => $composableBuilder(
    column: $table.clientId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get birthDate => $composableBuilder(
    column: $table.birthDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get biologicalSex => $composableBuilder(
    column: $table.biologicalSex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ethnicity => $composableBuilder(
    column: $table.ethnicity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ownerId => $composableBuilder(
    column: $table.ownerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dietType => $composableBuilder(
    column: $table.dietType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get dietDescription => $composableBuilder(
    column: $table.dietDescription,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ProfilesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProfilesTable> {
  $$ProfilesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get clientId =>
      $composableBuilder(column: $table.clientId, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get birthDate =>
      $composableBuilder(column: $table.birthDate, builder: (column) => column);

  GeneratedColumn<int> get biologicalSex => $composableBuilder(
    column: $table.biologicalSex,
    builder: (column) => column,
  );

  GeneratedColumn<String> get ethnicity =>
      $composableBuilder(column: $table.ethnicity, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get ownerId =>
      $composableBuilder(column: $table.ownerId, builder: (column) => column);

  GeneratedColumn<int> get dietType =>
      $composableBuilder(column: $table.dietType, builder: (column) => column);

  GeneratedColumn<String> get dietDescription => $composableBuilder(
    column: $table.dietDescription,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncCreatedAt => $composableBuilder(
    column: $table.syncCreatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncUpdatedAt => $composableBuilder(
    column: $table.syncUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncDeletedAt => $composableBuilder(
    column: $table.syncDeletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncLastSyncedAt => $composableBuilder(
    column: $table.syncLastSyncedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncVersion => $composableBuilder(
    column: $table.syncVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncDeviceId => $composableBuilder(
    column: $table.syncDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get syncIsDirty => $composableBuilder(
    column: $table.syncIsDirty,
    builder: (column) => column,
  );

  GeneratedColumn<String> get conflictData => $composableBuilder(
    column: $table.conflictData,
    builder: (column) => column,
  );
}

class $$ProfilesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ProfilesTable,
          ProfileRow,
          $$ProfilesTableFilterComposer,
          $$ProfilesTableOrderingComposer,
          $$ProfilesTableAnnotationComposer,
          $$ProfilesTableCreateCompanionBuilder,
          $$ProfilesTableUpdateCompanionBuilder,
          (
            ProfileRow,
            BaseReferences<_$AppDatabase, $ProfilesTable, ProfileRow>,
          ),
          ProfileRow,
          PrefetchHooks Function()
        > {
  $$ProfilesTableTableManager(_$AppDatabase db, $ProfilesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProfilesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProfilesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProfilesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> clientId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int?> birthDate = const Value.absent(),
                Value<int?> biologicalSex = const Value.absent(),
                Value<String?> ethnicity = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> ownerId = const Value.absent(),
                Value<int> dietType = const Value.absent(),
                Value<String?> dietDescription = const Value.absent(),
                Value<int> syncCreatedAt = const Value.absent(),
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProfilesCompanion(
                id: id,
                clientId: clientId,
                name: name,
                birthDate: birthDate,
                biologicalSex: biologicalSex,
                ethnicity: ethnicity,
                notes: notes,
                ownerId: ownerId,
                dietType: dietType,
                dietDescription: dietDescription,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String clientId,
                required String name,
                Value<int?> birthDate = const Value.absent(),
                Value<int?> biologicalSex = const Value.absent(),
                Value<String?> ethnicity = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> ownerId = const Value.absent(),
                Value<int> dietType = const Value.absent(),
                Value<String?> dietDescription = const Value.absent(),
                required int syncCreatedAt,
                Value<int?> syncUpdatedAt = const Value.absent(),
                Value<int?> syncDeletedAt = const Value.absent(),
                Value<int?> syncLastSyncedAt = const Value.absent(),
                Value<int> syncStatus = const Value.absent(),
                Value<int> syncVersion = const Value.absent(),
                Value<String?> syncDeviceId = const Value.absent(),
                Value<bool> syncIsDirty = const Value.absent(),
                Value<String?> conflictData = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProfilesCompanion.insert(
                id: id,
                clientId: clientId,
                name: name,
                birthDate: birthDate,
                biologicalSex: biologicalSex,
                ethnicity: ethnicity,
                notes: notes,
                ownerId: ownerId,
                dietType: dietType,
                dietDescription: dietDescription,
                syncCreatedAt: syncCreatedAt,
                syncUpdatedAt: syncUpdatedAt,
                syncDeletedAt: syncDeletedAt,
                syncLastSyncedAt: syncLastSyncedAt,
                syncStatus: syncStatus,
                syncVersion: syncVersion,
                syncDeviceId: syncDeviceId,
                syncIsDirty: syncIsDirty,
                conflictData: conflictData,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ProfilesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ProfilesTable,
      ProfileRow,
      $$ProfilesTableFilterComposer,
      $$ProfilesTableOrderingComposer,
      $$ProfilesTableAnnotationComposer,
      $$ProfilesTableCreateCompanionBuilder,
      $$ProfilesTableUpdateCompanionBuilder,
      (ProfileRow, BaseReferences<_$AppDatabase, $ProfilesTable, ProfileRow>),
      ProfileRow,
      PrefetchHooks Function()
    >;
typedef $$GuestInvitesTableCreateCompanionBuilder =
    GuestInvitesCompanion Function({
      required String id,
      required String profileId,
      required String token,
      Value<String> label,
      required int createdAt,
      Value<int?> expiresAt,
      Value<bool> isRevoked,
      Value<int?> lastSeenAt,
      Value<String?> activeDeviceId,
      Value<int> rowid,
    });
typedef $$GuestInvitesTableUpdateCompanionBuilder =
    GuestInvitesCompanion Function({
      Value<String> id,
      Value<String> profileId,
      Value<String> token,
      Value<String> label,
      Value<int> createdAt,
      Value<int?> expiresAt,
      Value<bool> isRevoked,
      Value<int?> lastSeenAt,
      Value<String?> activeDeviceId,
      Value<int> rowid,
    });

class $$GuestInvitesTableFilterComposer
    extends Composer<_$AppDatabase, $GuestInvitesTable> {
  $$GuestInvitesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get token => $composableBuilder(
    column: $table.token,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get label => $composableBuilder(
    column: $table.label,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isRevoked => $composableBuilder(
    column: $table.isRevoked,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lastSeenAt => $composableBuilder(
    column: $table.lastSeenAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get activeDeviceId => $composableBuilder(
    column: $table.activeDeviceId,
    builder: (column) => ColumnFilters(column),
  );
}

class $$GuestInvitesTableOrderingComposer
    extends Composer<_$AppDatabase, $GuestInvitesTable> {
  $$GuestInvitesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get token => $composableBuilder(
    column: $table.token,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get label => $composableBuilder(
    column: $table.label,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isRevoked => $composableBuilder(
    column: $table.isRevoked,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lastSeenAt => $composableBuilder(
    column: $table.lastSeenAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get activeDeviceId => $composableBuilder(
    column: $table.activeDeviceId,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$GuestInvitesTableAnnotationComposer
    extends Composer<_$AppDatabase, $GuestInvitesTable> {
  $$GuestInvitesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<String> get token =>
      $composableBuilder(column: $table.token, builder: (column) => column);

  GeneratedColumn<String> get label =>
      $composableBuilder(column: $table.label, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);

  GeneratedColumn<bool> get isRevoked =>
      $composableBuilder(column: $table.isRevoked, builder: (column) => column);

  GeneratedColumn<int> get lastSeenAt => $composableBuilder(
    column: $table.lastSeenAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get activeDeviceId => $composableBuilder(
    column: $table.activeDeviceId,
    builder: (column) => column,
  );
}

class $$GuestInvitesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $GuestInvitesTable,
          GuestInviteRow,
          $$GuestInvitesTableFilterComposer,
          $$GuestInvitesTableOrderingComposer,
          $$GuestInvitesTableAnnotationComposer,
          $$GuestInvitesTableCreateCompanionBuilder,
          $$GuestInvitesTableUpdateCompanionBuilder,
          (
            GuestInviteRow,
            BaseReferences<_$AppDatabase, $GuestInvitesTable, GuestInviteRow>,
          ),
          GuestInviteRow,
          PrefetchHooks Function()
        > {
  $$GuestInvitesTableTableManager(_$AppDatabase db, $GuestInvitesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GuestInvitesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GuestInvitesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GuestInvitesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> token = const Value.absent(),
                Value<String> label = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int?> expiresAt = const Value.absent(),
                Value<bool> isRevoked = const Value.absent(),
                Value<int?> lastSeenAt = const Value.absent(),
                Value<String?> activeDeviceId = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => GuestInvitesCompanion(
                id: id,
                profileId: profileId,
                token: token,
                label: label,
                createdAt: createdAt,
                expiresAt: expiresAt,
                isRevoked: isRevoked,
                lastSeenAt: lastSeenAt,
                activeDeviceId: activeDeviceId,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String profileId,
                required String token,
                Value<String> label = const Value.absent(),
                required int createdAt,
                Value<int?> expiresAt = const Value.absent(),
                Value<bool> isRevoked = const Value.absent(),
                Value<int?> lastSeenAt = const Value.absent(),
                Value<String?> activeDeviceId = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => GuestInvitesCompanion.insert(
                id: id,
                profileId: profileId,
                token: token,
                label: label,
                createdAt: createdAt,
                expiresAt: expiresAt,
                isRevoked: isRevoked,
                lastSeenAt: lastSeenAt,
                activeDeviceId: activeDeviceId,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$GuestInvitesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $GuestInvitesTable,
      GuestInviteRow,
      $$GuestInvitesTableFilterComposer,
      $$GuestInvitesTableOrderingComposer,
      $$GuestInvitesTableAnnotationComposer,
      $$GuestInvitesTableCreateCompanionBuilder,
      $$GuestInvitesTableUpdateCompanionBuilder,
      (
        GuestInviteRow,
        BaseReferences<_$AppDatabase, $GuestInvitesTable, GuestInviteRow>,
      ),
      GuestInviteRow,
      PrefetchHooks Function()
    >;
typedef $$SupplementLabelPhotosTableCreateCompanionBuilder =
    SupplementLabelPhotosCompanion Function({
      required String id,
      required String supplementId,
      required String filePath,
      required int capturedAt,
      Value<int> sortOrder,
      Value<int> rowid,
    });
typedef $$SupplementLabelPhotosTableUpdateCompanionBuilder =
    SupplementLabelPhotosCompanion Function({
      Value<String> id,
      Value<String> supplementId,
      Value<String> filePath,
      Value<int> capturedAt,
      Value<int> sortOrder,
      Value<int> rowid,
    });

class $$SupplementLabelPhotosTableFilterComposer
    extends Composer<_$AppDatabase, $SupplementLabelPhotosTable> {
  $$SupplementLabelPhotosTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get supplementId => $composableBuilder(
    column: $table.supplementId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get filePath => $composableBuilder(
    column: $table.filePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get capturedAt => $composableBuilder(
    column: $table.capturedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SupplementLabelPhotosTableOrderingComposer
    extends Composer<_$AppDatabase, $SupplementLabelPhotosTable> {
  $$SupplementLabelPhotosTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get supplementId => $composableBuilder(
    column: $table.supplementId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get filePath => $composableBuilder(
    column: $table.filePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get capturedAt => $composableBuilder(
    column: $table.capturedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SupplementLabelPhotosTableAnnotationComposer
    extends Composer<_$AppDatabase, $SupplementLabelPhotosTable> {
  $$SupplementLabelPhotosTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get supplementId => $composableBuilder(
    column: $table.supplementId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get filePath =>
      $composableBuilder(column: $table.filePath, builder: (column) => column);

  GeneratedColumn<int> get capturedAt => $composableBuilder(
    column: $table.capturedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);
}

class $$SupplementLabelPhotosTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SupplementLabelPhotosTable,
          SupplementLabelPhotoRow,
          $$SupplementLabelPhotosTableFilterComposer,
          $$SupplementLabelPhotosTableOrderingComposer,
          $$SupplementLabelPhotosTableAnnotationComposer,
          $$SupplementLabelPhotosTableCreateCompanionBuilder,
          $$SupplementLabelPhotosTableUpdateCompanionBuilder,
          (
            SupplementLabelPhotoRow,
            BaseReferences<
              _$AppDatabase,
              $SupplementLabelPhotosTable,
              SupplementLabelPhotoRow
            >,
          ),
          SupplementLabelPhotoRow,
          PrefetchHooks Function()
        > {
  $$SupplementLabelPhotosTableTableManager(
    _$AppDatabase db,
    $SupplementLabelPhotosTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SupplementLabelPhotosTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$SupplementLabelPhotosTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$SupplementLabelPhotosTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> supplementId = const Value.absent(),
                Value<String> filePath = const Value.absent(),
                Value<int> capturedAt = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SupplementLabelPhotosCompanion(
                id: id,
                supplementId: supplementId,
                filePath: filePath,
                capturedAt: capturedAt,
                sortOrder: sortOrder,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String supplementId,
                required String filePath,
                required int capturedAt,
                Value<int> sortOrder = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SupplementLabelPhotosCompanion.insert(
                id: id,
                supplementId: supplementId,
                filePath: filePath,
                capturedAt: capturedAt,
                sortOrder: sortOrder,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SupplementLabelPhotosTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SupplementLabelPhotosTable,
      SupplementLabelPhotoRow,
      $$SupplementLabelPhotosTableFilterComposer,
      $$SupplementLabelPhotosTableOrderingComposer,
      $$SupplementLabelPhotosTableAnnotationComposer,
      $$SupplementLabelPhotosTableCreateCompanionBuilder,
      $$SupplementLabelPhotosTableUpdateCompanionBuilder,
      (
        SupplementLabelPhotoRow,
        BaseReferences<
          _$AppDatabase,
          $SupplementLabelPhotosTable,
          SupplementLabelPhotoRow
        >,
      ),
      SupplementLabelPhotoRow,
      PrefetchHooks Function()
    >;
typedef $$SupplementBarcodeCacheTableCreateCompanionBuilder =
    SupplementBarcodeCacheCompanion Function({
      required String id,
      required String barcode,
      Value<String?> productName,
      Value<String?> brand,
      Value<String?> servingSize,
      Value<double?> servingsPerContainer,
      Value<String?> ingredientsJson,
      Value<String?> dsldId,
      Value<String?> rawResponse,
      required int fetchedAt,
      required int expiresAt,
      Value<int> rowid,
    });
typedef $$SupplementBarcodeCacheTableUpdateCompanionBuilder =
    SupplementBarcodeCacheCompanion Function({
      Value<String> id,
      Value<String> barcode,
      Value<String?> productName,
      Value<String?> brand,
      Value<String?> servingSize,
      Value<double?> servingsPerContainer,
      Value<String?> ingredientsJson,
      Value<String?> dsldId,
      Value<String?> rawResponse,
      Value<int> fetchedAt,
      Value<int> expiresAt,
      Value<int> rowid,
    });

class $$SupplementBarcodeCacheTableFilterComposer
    extends Composer<_$AppDatabase, $SupplementBarcodeCacheTable> {
  $$SupplementBarcodeCacheTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get barcode => $composableBuilder(
    column: $table.barcode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get brand => $composableBuilder(
    column: $table.brand,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get servingSize => $composableBuilder(
    column: $table.servingSize,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get servingsPerContainer => $composableBuilder(
    column: $table.servingsPerContainer,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ingredientsJson => $composableBuilder(
    column: $table.ingredientsJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get dsldId => $composableBuilder(
    column: $table.dsldId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get rawResponse => $composableBuilder(
    column: $table.rawResponse,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get fetchedAt => $composableBuilder(
    column: $table.fetchedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SupplementBarcodeCacheTableOrderingComposer
    extends Composer<_$AppDatabase, $SupplementBarcodeCacheTable> {
  $$SupplementBarcodeCacheTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get barcode => $composableBuilder(
    column: $table.barcode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get brand => $composableBuilder(
    column: $table.brand,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get servingSize => $composableBuilder(
    column: $table.servingSize,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get servingsPerContainer => $composableBuilder(
    column: $table.servingsPerContainer,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ingredientsJson => $composableBuilder(
    column: $table.ingredientsJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get dsldId => $composableBuilder(
    column: $table.dsldId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get rawResponse => $composableBuilder(
    column: $table.rawResponse,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get fetchedAt => $composableBuilder(
    column: $table.fetchedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SupplementBarcodeCacheTableAnnotationComposer
    extends Composer<_$AppDatabase, $SupplementBarcodeCacheTable> {
  $$SupplementBarcodeCacheTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get barcode =>
      $composableBuilder(column: $table.barcode, builder: (column) => column);

  GeneratedColumn<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get brand =>
      $composableBuilder(column: $table.brand, builder: (column) => column);

  GeneratedColumn<String> get servingSize => $composableBuilder(
    column: $table.servingSize,
    builder: (column) => column,
  );

  GeneratedColumn<double> get servingsPerContainer => $composableBuilder(
    column: $table.servingsPerContainer,
    builder: (column) => column,
  );

  GeneratedColumn<String> get ingredientsJson => $composableBuilder(
    column: $table.ingredientsJson,
    builder: (column) => column,
  );

  GeneratedColumn<String> get dsldId =>
      $composableBuilder(column: $table.dsldId, builder: (column) => column);

  GeneratedColumn<String> get rawResponse => $composableBuilder(
    column: $table.rawResponse,
    builder: (column) => column,
  );

  GeneratedColumn<int> get fetchedAt =>
      $composableBuilder(column: $table.fetchedAt, builder: (column) => column);

  GeneratedColumn<int> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);
}

class $$SupplementBarcodeCacheTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SupplementBarcodeCacheTable,
          SupplementBarcodeCacheRow,
          $$SupplementBarcodeCacheTableFilterComposer,
          $$SupplementBarcodeCacheTableOrderingComposer,
          $$SupplementBarcodeCacheTableAnnotationComposer,
          $$SupplementBarcodeCacheTableCreateCompanionBuilder,
          $$SupplementBarcodeCacheTableUpdateCompanionBuilder,
          (
            SupplementBarcodeCacheRow,
            BaseReferences<
              _$AppDatabase,
              $SupplementBarcodeCacheTable,
              SupplementBarcodeCacheRow
            >,
          ),
          SupplementBarcodeCacheRow,
          PrefetchHooks Function()
        > {
  $$SupplementBarcodeCacheTableTableManager(
    _$AppDatabase db,
    $SupplementBarcodeCacheTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SupplementBarcodeCacheTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$SupplementBarcodeCacheTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$SupplementBarcodeCacheTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> barcode = const Value.absent(),
                Value<String?> productName = const Value.absent(),
                Value<String?> brand = const Value.absent(),
                Value<String?> servingSize = const Value.absent(),
                Value<double?> servingsPerContainer = const Value.absent(),
                Value<String?> ingredientsJson = const Value.absent(),
                Value<String?> dsldId = const Value.absent(),
                Value<String?> rawResponse = const Value.absent(),
                Value<int> fetchedAt = const Value.absent(),
                Value<int> expiresAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SupplementBarcodeCacheCompanion(
                id: id,
                barcode: barcode,
                productName: productName,
                brand: brand,
                servingSize: servingSize,
                servingsPerContainer: servingsPerContainer,
                ingredientsJson: ingredientsJson,
                dsldId: dsldId,
                rawResponse: rawResponse,
                fetchedAt: fetchedAt,
                expiresAt: expiresAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String barcode,
                Value<String?> productName = const Value.absent(),
                Value<String?> brand = const Value.absent(),
                Value<String?> servingSize = const Value.absent(),
                Value<double?> servingsPerContainer = const Value.absent(),
                Value<String?> ingredientsJson = const Value.absent(),
                Value<String?> dsldId = const Value.absent(),
                Value<String?> rawResponse = const Value.absent(),
                required int fetchedAt,
                required int expiresAt,
                Value<int> rowid = const Value.absent(),
              }) => SupplementBarcodeCacheCompanion.insert(
                id: id,
                barcode: barcode,
                productName: productName,
                brand: brand,
                servingSize: servingSize,
                servingsPerContainer: servingsPerContainer,
                ingredientsJson: ingredientsJson,
                dsldId: dsldId,
                rawResponse: rawResponse,
                fetchedAt: fetchedAt,
                expiresAt: expiresAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SupplementBarcodeCacheTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SupplementBarcodeCacheTable,
      SupplementBarcodeCacheRow,
      $$SupplementBarcodeCacheTableFilterComposer,
      $$SupplementBarcodeCacheTableOrderingComposer,
      $$SupplementBarcodeCacheTableAnnotationComposer,
      $$SupplementBarcodeCacheTableCreateCompanionBuilder,
      $$SupplementBarcodeCacheTableUpdateCompanionBuilder,
      (
        SupplementBarcodeCacheRow,
        BaseReferences<
          _$AppDatabase,
          $SupplementBarcodeCacheTable,
          SupplementBarcodeCacheRow
        >,
      ),
      SupplementBarcodeCacheRow,
      PrefetchHooks Function()
    >;
typedef $$SyncConflictsTableCreateCompanionBuilder =
    SyncConflictsCompanion Function({
      required String id,
      required String entityType,
      required String entityId,
      required String profileId,
      required int localVersion,
      required int remoteVersion,
      required String localData,
      required String remoteData,
      required int detectedAt,
      Value<bool> isResolved,
      Value<int?> resolution,
      Value<int?> resolvedAt,
      Value<int> rowid,
    });
typedef $$SyncConflictsTableUpdateCompanionBuilder =
    SyncConflictsCompanion Function({
      Value<String> id,
      Value<String> entityType,
      Value<String> entityId,
      Value<String> profileId,
      Value<int> localVersion,
      Value<int> remoteVersion,
      Value<String> localData,
      Value<String> remoteData,
      Value<int> detectedAt,
      Value<bool> isResolved,
      Value<int?> resolution,
      Value<int?> resolvedAt,
      Value<int> rowid,
    });

class $$SyncConflictsTableFilterComposer
    extends Composer<_$AppDatabase, $SyncConflictsTable> {
  $$SyncConflictsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get localVersion => $composableBuilder(
    column: $table.localVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get remoteVersion => $composableBuilder(
    column: $table.remoteVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get localData => $composableBuilder(
    column: $table.localData,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get remoteData => $composableBuilder(
    column: $table.remoteData,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get detectedAt => $composableBuilder(
    column: $table.detectedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isResolved => $composableBuilder(
    column: $table.isResolved,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get resolution => $composableBuilder(
    column: $table.resolution,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get resolvedAt => $composableBuilder(
    column: $table.resolvedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SyncConflictsTableOrderingComposer
    extends Composer<_$AppDatabase, $SyncConflictsTable> {
  $$SyncConflictsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get profileId => $composableBuilder(
    column: $table.profileId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get localVersion => $composableBuilder(
    column: $table.localVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get remoteVersion => $composableBuilder(
    column: $table.remoteVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get localData => $composableBuilder(
    column: $table.localData,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get remoteData => $composableBuilder(
    column: $table.remoteData,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get detectedAt => $composableBuilder(
    column: $table.detectedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isResolved => $composableBuilder(
    column: $table.isResolved,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get resolution => $composableBuilder(
    column: $table.resolution,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get resolvedAt => $composableBuilder(
    column: $table.resolvedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SyncConflictsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SyncConflictsTable> {
  $$SyncConflictsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityId =>
      $composableBuilder(column: $table.entityId, builder: (column) => column);

  GeneratedColumn<String> get profileId =>
      $composableBuilder(column: $table.profileId, builder: (column) => column);

  GeneratedColumn<int> get localVersion => $composableBuilder(
    column: $table.localVersion,
    builder: (column) => column,
  );

  GeneratedColumn<int> get remoteVersion => $composableBuilder(
    column: $table.remoteVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get localData =>
      $composableBuilder(column: $table.localData, builder: (column) => column);

  GeneratedColumn<String> get remoteData => $composableBuilder(
    column: $table.remoteData,
    builder: (column) => column,
  );

  GeneratedColumn<int> get detectedAt => $composableBuilder(
    column: $table.detectedAt,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isResolved => $composableBuilder(
    column: $table.isResolved,
    builder: (column) => column,
  );

  GeneratedColumn<int> get resolution => $composableBuilder(
    column: $table.resolution,
    builder: (column) => column,
  );

  GeneratedColumn<int> get resolvedAt => $composableBuilder(
    column: $table.resolvedAt,
    builder: (column) => column,
  );
}

class $$SyncConflictsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SyncConflictsTable,
          SyncConflictRow,
          $$SyncConflictsTableFilterComposer,
          $$SyncConflictsTableOrderingComposer,
          $$SyncConflictsTableAnnotationComposer,
          $$SyncConflictsTableCreateCompanionBuilder,
          $$SyncConflictsTableUpdateCompanionBuilder,
          (
            SyncConflictRow,
            BaseReferences<_$AppDatabase, $SyncConflictsTable, SyncConflictRow>,
          ),
          SyncConflictRow,
          PrefetchHooks Function()
        > {
  $$SyncConflictsTableTableManager(_$AppDatabase db, $SyncConflictsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SyncConflictsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SyncConflictsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SyncConflictsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String> entityId = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<int> localVersion = const Value.absent(),
                Value<int> remoteVersion = const Value.absent(),
                Value<String> localData = const Value.absent(),
                Value<String> remoteData = const Value.absent(),
                Value<int> detectedAt = const Value.absent(),
                Value<bool> isResolved = const Value.absent(),
                Value<int?> resolution = const Value.absent(),
                Value<int?> resolvedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SyncConflictsCompanion(
                id: id,
                entityType: entityType,
                entityId: entityId,
                profileId: profileId,
                localVersion: localVersion,
                remoteVersion: remoteVersion,
                localData: localData,
                remoteData: remoteData,
                detectedAt: detectedAt,
                isResolved: isResolved,
                resolution: resolution,
                resolvedAt: resolvedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String entityType,
                required String entityId,
                required String profileId,
                required int localVersion,
                required int remoteVersion,
                required String localData,
                required String remoteData,
                required int detectedAt,
                Value<bool> isResolved = const Value.absent(),
                Value<int?> resolution = const Value.absent(),
                Value<int?> resolvedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SyncConflictsCompanion.insert(
                id: id,
                entityType: entityType,
                entityId: entityId,
                profileId: profileId,
                localVersion: localVersion,
                remoteVersion: remoteVersion,
                localData: localData,
                remoteData: remoteData,
                detectedAt: detectedAt,
                isResolved: isResolved,
                resolution: resolution,
                resolvedAt: resolvedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SyncConflictsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SyncConflictsTable,
      SyncConflictRow,
      $$SyncConflictsTableFilterComposer,
      $$SyncConflictsTableOrderingComposer,
      $$SyncConflictsTableAnnotationComposer,
      $$SyncConflictsTableCreateCompanionBuilder,
      $$SyncConflictsTableUpdateCompanionBuilder,
      (
        SyncConflictRow,
        BaseReferences<_$AppDatabase, $SyncConflictsTable, SyncConflictRow>,
      ),
      SyncConflictRow,
      PrefetchHooks Function()
    >;
typedef $$AnchorEventTimesTableCreateCompanionBuilder =
    AnchorEventTimesCompanion Function({
      required String id,
      required int name,
      required String timeOfDay,
      Value<bool> isEnabled,
      Value<int> rowid,
    });
typedef $$AnchorEventTimesTableUpdateCompanionBuilder =
    AnchorEventTimesCompanion Function({
      Value<String> id,
      Value<int> name,
      Value<String> timeOfDay,
      Value<bool> isEnabled,
      Value<int> rowid,
    });

class $$AnchorEventTimesTableFilterComposer
    extends Composer<_$AppDatabase, $AnchorEventTimesTable> {
  $$AnchorEventTimesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get timeOfDay => $composableBuilder(
    column: $table.timeOfDay,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isEnabled => $composableBuilder(
    column: $table.isEnabled,
    builder: (column) => ColumnFilters(column),
  );
}

class $$AnchorEventTimesTableOrderingComposer
    extends Composer<_$AppDatabase, $AnchorEventTimesTable> {
  $$AnchorEventTimesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get timeOfDay => $composableBuilder(
    column: $table.timeOfDay,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isEnabled => $composableBuilder(
    column: $table.isEnabled,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AnchorEventTimesTableAnnotationComposer
    extends Composer<_$AppDatabase, $AnchorEventTimesTable> {
  $$AnchorEventTimesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get timeOfDay =>
      $composableBuilder(column: $table.timeOfDay, builder: (column) => column);

  GeneratedColumn<bool> get isEnabled =>
      $composableBuilder(column: $table.isEnabled, builder: (column) => column);
}

class $$AnchorEventTimesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AnchorEventTimesTable,
          AnchorEventTimeRow,
          $$AnchorEventTimesTableFilterComposer,
          $$AnchorEventTimesTableOrderingComposer,
          $$AnchorEventTimesTableAnnotationComposer,
          $$AnchorEventTimesTableCreateCompanionBuilder,
          $$AnchorEventTimesTableUpdateCompanionBuilder,
          (
            AnchorEventTimeRow,
            BaseReferences<
              _$AppDatabase,
              $AnchorEventTimesTable,
              AnchorEventTimeRow
            >,
          ),
          AnchorEventTimeRow,
          PrefetchHooks Function()
        > {
  $$AnchorEventTimesTableTableManager(
    _$AppDatabase db,
    $AnchorEventTimesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AnchorEventTimesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AnchorEventTimesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AnchorEventTimesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<int> name = const Value.absent(),
                Value<String> timeOfDay = const Value.absent(),
                Value<bool> isEnabled = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AnchorEventTimesCompanion(
                id: id,
                name: name,
                timeOfDay: timeOfDay,
                isEnabled: isEnabled,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required int name,
                required String timeOfDay,
                Value<bool> isEnabled = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AnchorEventTimesCompanion.insert(
                id: id,
                name: name,
                timeOfDay: timeOfDay,
                isEnabled: isEnabled,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$AnchorEventTimesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AnchorEventTimesTable,
      AnchorEventTimeRow,
      $$AnchorEventTimesTableFilterComposer,
      $$AnchorEventTimesTableOrderingComposer,
      $$AnchorEventTimesTableAnnotationComposer,
      $$AnchorEventTimesTableCreateCompanionBuilder,
      $$AnchorEventTimesTableUpdateCompanionBuilder,
      (
        AnchorEventTimeRow,
        BaseReferences<
          _$AppDatabase,
          $AnchorEventTimesTable,
          AnchorEventTimeRow
        >,
      ),
      AnchorEventTimeRow,
      PrefetchHooks Function()
    >;
typedef $$NotificationCategorySettingsTableCreateCompanionBuilder =
    NotificationCategorySettingsCompanion Function({
      required String id,
      required int category,
      Value<bool> isEnabled,
      required int schedulingMode,
      Value<String> anchorEventValues,
      Value<int?> intervalHours,
      Value<String?> intervalStartTime,
      Value<String?> intervalEndTime,
      Value<String> specificTimes,
      Value<int> expiresAfterMinutes,
      Value<int> rowid,
    });
typedef $$NotificationCategorySettingsTableUpdateCompanionBuilder =
    NotificationCategorySettingsCompanion Function({
      Value<String> id,
      Value<int> category,
      Value<bool> isEnabled,
      Value<int> schedulingMode,
      Value<String> anchorEventValues,
      Value<int?> intervalHours,
      Value<String?> intervalStartTime,
      Value<String?> intervalEndTime,
      Value<String> specificTimes,
      Value<int> expiresAfterMinutes,
      Value<int> rowid,
    });

class $$NotificationCategorySettingsTableFilterComposer
    extends Composer<_$AppDatabase, $NotificationCategorySettingsTable> {
  $$NotificationCategorySettingsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isEnabled => $composableBuilder(
    column: $table.isEnabled,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get schedulingMode => $composableBuilder(
    column: $table.schedulingMode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get anchorEventValues => $composableBuilder(
    column: $table.anchorEventValues,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get intervalHours => $composableBuilder(
    column: $table.intervalHours,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get intervalStartTime => $composableBuilder(
    column: $table.intervalStartTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get intervalEndTime => $composableBuilder(
    column: $table.intervalEndTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get specificTimes => $composableBuilder(
    column: $table.specificTimes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get expiresAfterMinutes => $composableBuilder(
    column: $table.expiresAfterMinutes,
    builder: (column) => ColumnFilters(column),
  );
}

class $$NotificationCategorySettingsTableOrderingComposer
    extends Composer<_$AppDatabase, $NotificationCategorySettingsTable> {
  $$NotificationCategorySettingsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isEnabled => $composableBuilder(
    column: $table.isEnabled,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get schedulingMode => $composableBuilder(
    column: $table.schedulingMode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get anchorEventValues => $composableBuilder(
    column: $table.anchorEventValues,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get intervalHours => $composableBuilder(
    column: $table.intervalHours,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get intervalStartTime => $composableBuilder(
    column: $table.intervalStartTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get intervalEndTime => $composableBuilder(
    column: $table.intervalEndTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get specificTimes => $composableBuilder(
    column: $table.specificTimes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get expiresAfterMinutes => $composableBuilder(
    column: $table.expiresAfterMinutes,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$NotificationCategorySettingsTableAnnotationComposer
    extends Composer<_$AppDatabase, $NotificationCategorySettingsTable> {
  $$NotificationCategorySettingsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get category =>
      $composableBuilder(column: $table.category, builder: (column) => column);

  GeneratedColumn<bool> get isEnabled =>
      $composableBuilder(column: $table.isEnabled, builder: (column) => column);

  GeneratedColumn<int> get schedulingMode => $composableBuilder(
    column: $table.schedulingMode,
    builder: (column) => column,
  );

  GeneratedColumn<String> get anchorEventValues => $composableBuilder(
    column: $table.anchorEventValues,
    builder: (column) => column,
  );

  GeneratedColumn<int> get intervalHours => $composableBuilder(
    column: $table.intervalHours,
    builder: (column) => column,
  );

  GeneratedColumn<String> get intervalStartTime => $composableBuilder(
    column: $table.intervalStartTime,
    builder: (column) => column,
  );

  GeneratedColumn<String> get intervalEndTime => $composableBuilder(
    column: $table.intervalEndTime,
    builder: (column) => column,
  );

  GeneratedColumn<String> get specificTimes => $composableBuilder(
    column: $table.specificTimes,
    builder: (column) => column,
  );

  GeneratedColumn<int> get expiresAfterMinutes => $composableBuilder(
    column: $table.expiresAfterMinutes,
    builder: (column) => column,
  );
}

class $$NotificationCategorySettingsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $NotificationCategorySettingsTable,
          NotificationCategorySettingsRow,
          $$NotificationCategorySettingsTableFilterComposer,
          $$NotificationCategorySettingsTableOrderingComposer,
          $$NotificationCategorySettingsTableAnnotationComposer,
          $$NotificationCategorySettingsTableCreateCompanionBuilder,
          $$NotificationCategorySettingsTableUpdateCompanionBuilder,
          (
            NotificationCategorySettingsRow,
            BaseReferences<
              _$AppDatabase,
              $NotificationCategorySettingsTable,
              NotificationCategorySettingsRow
            >,
          ),
          NotificationCategorySettingsRow,
          PrefetchHooks Function()
        > {
  $$NotificationCategorySettingsTableTableManager(
    _$AppDatabase db,
    $NotificationCategorySettingsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$NotificationCategorySettingsTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$NotificationCategorySettingsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$NotificationCategorySettingsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<int> category = const Value.absent(),
                Value<bool> isEnabled = const Value.absent(),
                Value<int> schedulingMode = const Value.absent(),
                Value<String> anchorEventValues = const Value.absent(),
                Value<int?> intervalHours = const Value.absent(),
                Value<String?> intervalStartTime = const Value.absent(),
                Value<String?> intervalEndTime = const Value.absent(),
                Value<String> specificTimes = const Value.absent(),
                Value<int> expiresAfterMinutes = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => NotificationCategorySettingsCompanion(
                id: id,
                category: category,
                isEnabled: isEnabled,
                schedulingMode: schedulingMode,
                anchorEventValues: anchorEventValues,
                intervalHours: intervalHours,
                intervalStartTime: intervalStartTime,
                intervalEndTime: intervalEndTime,
                specificTimes: specificTimes,
                expiresAfterMinutes: expiresAfterMinutes,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required int category,
                Value<bool> isEnabled = const Value.absent(),
                required int schedulingMode,
                Value<String> anchorEventValues = const Value.absent(),
                Value<int?> intervalHours = const Value.absent(),
                Value<String?> intervalStartTime = const Value.absent(),
                Value<String?> intervalEndTime = const Value.absent(),
                Value<String> specificTimes = const Value.absent(),
                Value<int> expiresAfterMinutes = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => NotificationCategorySettingsCompanion.insert(
                id: id,
                category: category,
                isEnabled: isEnabled,
                schedulingMode: schedulingMode,
                anchorEventValues: anchorEventValues,
                intervalHours: intervalHours,
                intervalStartTime: intervalStartTime,
                intervalEndTime: intervalEndTime,
                specificTimes: specificTimes,
                expiresAfterMinutes: expiresAfterMinutes,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$NotificationCategorySettingsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $NotificationCategorySettingsTable,
      NotificationCategorySettingsRow,
      $$NotificationCategorySettingsTableFilterComposer,
      $$NotificationCategorySettingsTableOrderingComposer,
      $$NotificationCategorySettingsTableAnnotationComposer,
      $$NotificationCategorySettingsTableCreateCompanionBuilder,
      $$NotificationCategorySettingsTableUpdateCompanionBuilder,
      (
        NotificationCategorySettingsRow,
        BaseReferences<
          _$AppDatabase,
          $NotificationCategorySettingsTable,
          NotificationCategorySettingsRow
        >,
      ),
      NotificationCategorySettingsRow,
      PrefetchHooks Function()
    >;
typedef $$UserSettingsTableTableCreateCompanionBuilder =
    UserSettingsTableCompanion Function({
      required String id,
      Value<int> weightUnit,
      Value<int> foodWeightUnit,
      Value<int> fluidUnit,
      Value<int> temperatureUnit,
      Value<int> energyUnit,
      Value<int> macroDisplay,
      Value<bool> appLockEnabled,
      Value<bool> biometricEnabled,
      Value<int> autoLockMinutes,
      Value<bool> hideInAppSwitcher,
      Value<bool> allowBiometricBypassPin,
      Value<int> rowid,
    });
typedef $$UserSettingsTableTableUpdateCompanionBuilder =
    UserSettingsTableCompanion Function({
      Value<String> id,
      Value<int> weightUnit,
      Value<int> foodWeightUnit,
      Value<int> fluidUnit,
      Value<int> temperatureUnit,
      Value<int> energyUnit,
      Value<int> macroDisplay,
      Value<bool> appLockEnabled,
      Value<bool> biometricEnabled,
      Value<int> autoLockMinutes,
      Value<bool> hideInAppSwitcher,
      Value<bool> allowBiometricBypassPin,
      Value<int> rowid,
    });

class $$UserSettingsTableTableFilterComposer
    extends Composer<_$AppDatabase, $UserSettingsTableTable> {
  $$UserSettingsTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get weightUnit => $composableBuilder(
    column: $table.weightUnit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get foodWeightUnit => $composableBuilder(
    column: $table.foodWeightUnit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get fluidUnit => $composableBuilder(
    column: $table.fluidUnit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get temperatureUnit => $composableBuilder(
    column: $table.temperatureUnit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get energyUnit => $composableBuilder(
    column: $table.energyUnit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get macroDisplay => $composableBuilder(
    column: $table.macroDisplay,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get appLockEnabled => $composableBuilder(
    column: $table.appLockEnabled,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get biometricEnabled => $composableBuilder(
    column: $table.biometricEnabled,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get autoLockMinutes => $composableBuilder(
    column: $table.autoLockMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get hideInAppSwitcher => $composableBuilder(
    column: $table.hideInAppSwitcher,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get allowBiometricBypassPin => $composableBuilder(
    column: $table.allowBiometricBypassPin,
    builder: (column) => ColumnFilters(column),
  );
}

class $$UserSettingsTableTableOrderingComposer
    extends Composer<_$AppDatabase, $UserSettingsTableTable> {
  $$UserSettingsTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get weightUnit => $composableBuilder(
    column: $table.weightUnit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get foodWeightUnit => $composableBuilder(
    column: $table.foodWeightUnit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get fluidUnit => $composableBuilder(
    column: $table.fluidUnit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get temperatureUnit => $composableBuilder(
    column: $table.temperatureUnit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get energyUnit => $composableBuilder(
    column: $table.energyUnit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get macroDisplay => $composableBuilder(
    column: $table.macroDisplay,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get appLockEnabled => $composableBuilder(
    column: $table.appLockEnabled,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get biometricEnabled => $composableBuilder(
    column: $table.biometricEnabled,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get autoLockMinutes => $composableBuilder(
    column: $table.autoLockMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get hideInAppSwitcher => $composableBuilder(
    column: $table.hideInAppSwitcher,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get allowBiometricBypassPin => $composableBuilder(
    column: $table.allowBiometricBypassPin,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$UserSettingsTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserSettingsTableTable> {
  $$UserSettingsTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get weightUnit => $composableBuilder(
    column: $table.weightUnit,
    builder: (column) => column,
  );

  GeneratedColumn<int> get foodWeightUnit => $composableBuilder(
    column: $table.foodWeightUnit,
    builder: (column) => column,
  );

  GeneratedColumn<int> get fluidUnit =>
      $composableBuilder(column: $table.fluidUnit, builder: (column) => column);

  GeneratedColumn<int> get temperatureUnit => $composableBuilder(
    column: $table.temperatureUnit,
    builder: (column) => column,
  );

  GeneratedColumn<int> get energyUnit => $composableBuilder(
    column: $table.energyUnit,
    builder: (column) => column,
  );

  GeneratedColumn<int> get macroDisplay => $composableBuilder(
    column: $table.macroDisplay,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get appLockEnabled => $composableBuilder(
    column: $table.appLockEnabled,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get biometricEnabled => $composableBuilder(
    column: $table.biometricEnabled,
    builder: (column) => column,
  );

  GeneratedColumn<int> get autoLockMinutes => $composableBuilder(
    column: $table.autoLockMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get hideInAppSwitcher => $composableBuilder(
    column: $table.hideInAppSwitcher,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get allowBiometricBypassPin => $composableBuilder(
    column: $table.allowBiometricBypassPin,
    builder: (column) => column,
  );
}

class $$UserSettingsTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UserSettingsTableTable,
          UserSettingsRow,
          $$UserSettingsTableTableFilterComposer,
          $$UserSettingsTableTableOrderingComposer,
          $$UserSettingsTableTableAnnotationComposer,
          $$UserSettingsTableTableCreateCompanionBuilder,
          $$UserSettingsTableTableUpdateCompanionBuilder,
          (
            UserSettingsRow,
            BaseReferences<
              _$AppDatabase,
              $UserSettingsTableTable,
              UserSettingsRow
            >,
          ),
          UserSettingsRow,
          PrefetchHooks Function()
        > {
  $$UserSettingsTableTableTableManager(
    _$AppDatabase db,
    $UserSettingsTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserSettingsTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserSettingsTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UserSettingsTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<int> weightUnit = const Value.absent(),
                Value<int> foodWeightUnit = const Value.absent(),
                Value<int> fluidUnit = const Value.absent(),
                Value<int> temperatureUnit = const Value.absent(),
                Value<int> energyUnit = const Value.absent(),
                Value<int> macroDisplay = const Value.absent(),
                Value<bool> appLockEnabled = const Value.absent(),
                Value<bool> biometricEnabled = const Value.absent(),
                Value<int> autoLockMinutes = const Value.absent(),
                Value<bool> hideInAppSwitcher = const Value.absent(),
                Value<bool> allowBiometricBypassPin = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserSettingsTableCompanion(
                id: id,
                weightUnit: weightUnit,
                foodWeightUnit: foodWeightUnit,
                fluidUnit: fluidUnit,
                temperatureUnit: temperatureUnit,
                energyUnit: energyUnit,
                macroDisplay: macroDisplay,
                appLockEnabled: appLockEnabled,
                biometricEnabled: biometricEnabled,
                autoLockMinutes: autoLockMinutes,
                hideInAppSwitcher: hideInAppSwitcher,
                allowBiometricBypassPin: allowBiometricBypassPin,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<int> weightUnit = const Value.absent(),
                Value<int> foodWeightUnit = const Value.absent(),
                Value<int> fluidUnit = const Value.absent(),
                Value<int> temperatureUnit = const Value.absent(),
                Value<int> energyUnit = const Value.absent(),
                Value<int> macroDisplay = const Value.absent(),
                Value<bool> appLockEnabled = const Value.absent(),
                Value<bool> biometricEnabled = const Value.absent(),
                Value<int> autoLockMinutes = const Value.absent(),
                Value<bool> hideInAppSwitcher = const Value.absent(),
                Value<bool> allowBiometricBypassPin = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserSettingsTableCompanion.insert(
                id: id,
                weightUnit: weightUnit,
                foodWeightUnit: foodWeightUnit,
                fluidUnit: fluidUnit,
                temperatureUnit: temperatureUnit,
                energyUnit: energyUnit,
                macroDisplay: macroDisplay,
                appLockEnabled: appLockEnabled,
                biometricEnabled: biometricEnabled,
                autoLockMinutes: autoLockMinutes,
                hideInAppSwitcher: hideInAppSwitcher,
                allowBiometricBypassPin: allowBiometricBypassPin,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$UserSettingsTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UserSettingsTableTable,
      UserSettingsRow,
      $$UserSettingsTableTableFilterComposer,
      $$UserSettingsTableTableOrderingComposer,
      $$UserSettingsTableTableAnnotationComposer,
      $$UserSettingsTableTableCreateCompanionBuilder,
      $$UserSettingsTableTableUpdateCompanionBuilder,
      (
        UserSettingsRow,
        BaseReferences<_$AppDatabase, $UserSettingsTableTable, UserSettingsRow>,
      ),
      UserSettingsRow,
      PrefetchHooks Function()
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$SupplementsTableTableManager get supplements =>
      $$SupplementsTableTableManager(_db, _db.supplements);
  $$IntakeLogsTableTableManager get intakeLogs =>
      $$IntakeLogsTableTableManager(_db, _db.intakeLogs);
  $$ConditionsTableTableManager get conditions =>
      $$ConditionsTableTableManager(_db, _db.conditions);
  $$ConditionLogsTableTableManager get conditionLogs =>
      $$ConditionLogsTableTableManager(_db, _db.conditionLogs);
  $$FlareUpsTableTableManager get flareUps =>
      $$FlareUpsTableTableManager(_db, _db.flareUps);
  $$FluidsEntriesTableTableManager get fluidsEntries =>
      $$FluidsEntriesTableTableManager(_db, _db.fluidsEntries);
  $$SleepEntriesTableTableManager get sleepEntries =>
      $$SleepEntriesTableTableManager(_db, _db.sleepEntries);
  $$ActivitiesTableTableManager get activities =>
      $$ActivitiesTableTableManager(_db, _db.activities);
  $$ActivityLogsTableTableManager get activityLogs =>
      $$ActivityLogsTableTableManager(_db, _db.activityLogs);
  $$FoodItemsTableTableManager get foodItems =>
      $$FoodItemsTableTableManager(_db, _db.foodItems);
  $$FoodItemComponentsTableTableManager get foodItemComponents =>
      $$FoodItemComponentsTableTableManager(_db, _db.foodItemComponents);
  $$FoodBarcodeCacheTableTableManager get foodBarcodeCache =>
      $$FoodBarcodeCacheTableTableManager(_db, _db.foodBarcodeCache);
  $$FoodLogsTableTableManager get foodLogs =>
      $$FoodLogsTableTableManager(_db, _db.foodLogs);
  $$JournalEntriesTableTableManager get journalEntries =>
      $$JournalEntriesTableTableManager(_db, _db.journalEntries);
  $$PhotoAreasTableTableManager get photoAreas =>
      $$PhotoAreasTableTableManager(_db, _db.photoAreas);
  $$PhotoEntriesTableTableManager get photoEntries =>
      $$PhotoEntriesTableTableManager(_db, _db.photoEntries);
  $$ProfilesTableTableManager get profiles =>
      $$ProfilesTableTableManager(_db, _db.profiles);
  $$GuestInvitesTableTableManager get guestInvites =>
      $$GuestInvitesTableTableManager(_db, _db.guestInvites);
  $$SupplementLabelPhotosTableTableManager get supplementLabelPhotos =>
      $$SupplementLabelPhotosTableTableManager(_db, _db.supplementLabelPhotos);
  $$SupplementBarcodeCacheTableTableManager get supplementBarcodeCache =>
      $$SupplementBarcodeCacheTableTableManager(
        _db,
        _db.supplementBarcodeCache,
      );
  $$SyncConflictsTableTableManager get syncConflicts =>
      $$SyncConflictsTableTableManager(_db, _db.syncConflicts);
  $$AnchorEventTimesTableTableManager get anchorEventTimes =>
      $$AnchorEventTimesTableTableManager(_db, _db.anchorEventTimes);
  $$NotificationCategorySettingsTableTableManager
  get notificationCategorySettings =>
      $$NotificationCategorySettingsTableTableManager(
        _db,
        _db.notificationCategorySettings,
      );
  $$UserSettingsTableTableTableManager get userSettingsTable =>
      $$UserSettingsTableTableTableManager(_db, _db.userSettingsTable);
}
